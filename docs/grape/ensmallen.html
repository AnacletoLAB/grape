<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.0" />
    <title>grape.ensmallen API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../grape.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;grape</a>

                        <img src="https://raw.githubusercontent.com/AnacletoLAB/grape/main/images/GRAPE.jpg" class="logo" alt="project logo"/>

                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>


                    <h2>Submodules</h2>
                    <ul>
                            <li>grape.ensmallen.ensmallen.edge_list_utils</li>
                            <li>grape.ensmallen.ensmallen.preprocessing</li>
                            <li><a href="ensmallen/datasets.html">grape.ensmallen.datasets</a></li>
                    </ul>

                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="module" href="#edge_list_utils">edge_list_utils</a>
            </li>
            <li>
                    <a class="class" href="#Graph">Graph</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Graph.__init__">Graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.dump_edges">dump_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.hash">hash</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_laplacian_coo_matrix">get_laplacian_coo_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_random_walk_normalized_laplacian_coo_matrix">get_random_walk_normalized_laplacian_coo_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_symmetric_normalized_laplacian_coo_matrix">get_symmetric_normalized_laplacian_coo_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_symmetric_normalized_coo_matrix">get_symmetric_normalized_coo_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.dump_nodes">dump_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_subgraphs">get_subgraphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_ids_from_node_ids">get_edge_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_sparse_subgraphs">get_sparse_subgraphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_sparse_undirected_laplacian_subgraphs">get_sparse_undirected_laplacian_subgraphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_prediction_subgraphs">get_edge_prediction_subgraphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_prediction_subgraphs_from_node_ids">get_edge_prediction_subgraphs_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.spanning_arborescence">spanning_arborescence</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.random_walks">random_walks</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.complete_walks">complete_walks</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_degree_centrality">get_degree_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_degree_centrality">get_weighted_degree_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_closeness_centrality_from_node_id">get_unchecked_closeness_centrality_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_closeness_centrality_from_node_id">get_unchecked_weighted_closeness_centrality_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_closeness_centrality">get_closeness_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_closeness_centrality">get_weighted_closeness_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_harmonic_centrality_from_node_id">get_unchecked_harmonic_centrality_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_harmonic_centrality_from_node_id">get_unchecked_weighted_harmonic_centrality_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_harmonic_centrality">get_harmonic_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_harmonic_centrality">get_weighted_harmonic_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_stress_centrality">get_stress_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_betweenness_centrality">get_betweenness_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_eigenvector_centrality">get_eigenvector_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_eigenvector_centrality">get_weighted_eigenvector_centrality</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.encode_edge">encode_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.decode_edge">decode_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_max_encodable_edge_number">get_max_encodable_edge_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_dense_binary_adjacency_matrix">get_dense_binary_adjacency_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_dense_weighted_adjacency_matrix">get_dense_weighted_adjacency_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_breadth_first_search_predecessors_parallel_from_node_id">get_unchecked_breadth_first_search_predecessors_parallel_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_breadth_first_search_distances_parallel_from_node_id">get_unchecked_breadth_first_search_distances_parallel_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_breadth_first_search_distances_sequential_from_node_id">get_unchecked_breadth_first_search_distances_sequential_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_breadth_first_search_from_node_ids">get_unchecked_breadth_first_search_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_shortest_path_node_ids_from_node_ids">get_unchecked_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_shortest_path_node_names_from_node_ids">get_unchecked_shortest_path_node_names_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_shortest_path_node_ids_from_node_ids">get_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_shortest_path_node_ids_from_node_names">get_shortest_path_node_ids_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_shortest_path_node_names_from_node_names">get_shortest_path_node_names_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids">get_unchecked_k_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_k_shortest_path_node_ids_from_node_ids">get_k_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_k_shortest_path_node_ids_from_node_names">get_k_shortest_path_node_ids_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_k_shortest_path_node_names_from_node_names">get_k_shortest_path_node_names_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_eccentricity_and_most_distant_node_id_from_node_id">get_unchecked_eccentricity_and_most_distant_node_id_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_eccentricity_from_node_id">get_unchecked_weighted_eccentricity_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_eccentricity_and_most_distant_node_id_from_node_id">get_eccentricity_and_most_distant_node_id_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_eccentricity_from_node_id">get_weighted_eccentricity_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_eccentricity_from_node_name">get_eccentricity_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_eccentricity_from_node_name">get_weighted_eccentricity_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_dijkstra_from_node_ids">get_unchecked_dijkstra_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids">get_unchecked_weighted_shortest_path_node_names_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_shortest_path_node_ids_from_node_ids">get_weighted_shortest_path_node_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_shortest_path_node_ids_from_node_names">get_weighted_shortest_path_node_ids_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_shortest_path_node_names_from_node_names">get_weighted_shortest_path_node_names_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_breadth_first_search_from_node_ids">get_breadth_first_search_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_dijkstra_from_node_ids">get_dijkstra_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_diameter_naive">get_diameter_naive</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_diameter">get_diameter</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_diameter_naive">get_weighted_diameter_naive</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_breadth_first_search_from_node_names">get_breadth_first_search_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_dijkstra_from_node_names">get_dijkstra_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_bipartite_edges">get_bipartite_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_bipartite_edge_names">get_bipartite_edge_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_star_edges">get_star_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_star_edge_names">get_star_edge_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_clique_edges">get_clique_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_clique_edge_names">get_clique_edge_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_minimum_preferential_attachment">get_unchecked_minimum_preferential_attachment</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_maximum_preferential_attachment">get_unchecked_maximum_preferential_attachment</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_minimum_preferential_attachment">get_unchecked_weighted_minimum_preferential_attachment</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_maximum_preferential_attachment">get_unchecked_weighted_maximum_preferential_attachment</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_preferential_attachment_from_node_ids">get_unchecked_preferential_attachment_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_preferential_attachment_from_node_ids">get_preferential_attachment_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_preferential_attachment_from_node_names">get_preferential_attachment_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_preferential_attachment_from_node_ids">get_unchecked_weighted_preferential_attachment_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_preferential_attachment_from_node_ids">get_weighted_preferential_attachment_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_preferential_attachment_from_node_names">get_weighted_preferential_attachment_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_jaccard_coefficient_from_node_ids">get_unchecked_jaccard_coefficient_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_jaccard_coefficient_from_node_ids">get_jaccard_coefficient_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_jaccard_coefficient_from_node_names">get_jaccard_coefficient_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_adamic_adar_index_from_node_ids">get_unchecked_adamic_adar_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_adamic_adar_index_from_node_ids">get_adamic_adar_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_adamic_adar_index_from_node_names">get_adamic_adar_index_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_resource_allocation_index_from_node_ids">get_unchecked_resource_allocation_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids">get_unchecked_weighted_resource_allocation_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_resource_allocation_index_from_node_ids">get_resource_allocation_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_resource_allocation_index_from_node_names">get_resource_allocation_index_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_resource_allocation_index_from_node_ids">get_weighted_resource_allocation_index_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_resource_allocation_index_from_node_names">get_weighted_resource_allocation_index_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_all_edge_metrics_from_node_ids">get_unchecked_all_edge_metrics_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.filter_from_ids">filter_from_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.filter_from_names">filter_from_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_unknown_node_types">drop_unknown_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_unknown_edge_types">drop_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_singleton_nodes">drop_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_singleton_nodes_with_selfloops">drop_singleton_nodes_with_selfloops</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_disconnected_nodes">drop_disconnected_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_selfloops">drop_selfloops</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.drop_parallel_edges">drop_parallel_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.from_csv">from_csv</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_connected_components_number">get_connected_components_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_connected_nodes">get_number_of_connected_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_nodes_with_selfloops_number">get_singleton_nodes_with_selfloops_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_singleton_nodes">get_number_of_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_disconnected_nodes">get_number_of_disconnected_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_node_ids">get_singleton_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_node_names">get_singleton_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_with_selfloops_node_ids">get_singleton_with_selfloops_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_with_selfloops_node_names">get_singleton_with_selfloops_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_density">get_density</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_trap_nodes_rate">get_trap_nodes_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degrees_mean">get_node_degrees_mean</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_node_degrees_mean">get_weighted_node_degrees_mean</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_undirected_edges_number">get_undirected_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_undirected_edges_number">get_unique_undirected_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edges_number">get_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_edges_number">get_unique_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degrees_median">get_node_degrees_median</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_node_degrees_median">get_weighted_node_degrees_median</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_maximum_node_degree">get_maximum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_most_central_node_id">get_unchecked_most_central_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_most_central_node_id">get_most_central_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_minimum_node_degree">get_minimum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degrees_mode">get_node_degrees_mode</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_selfloop_nodes_rate">get_selfloop_nodes_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_name">get_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_trap_nodes">get_number_of_trap_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_source_node_ids">get_source_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_source_node_ids">get_directed_source_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_source_names">get_source_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_destination_node_ids">get_destination_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_destination_node_ids">get_directed_destination_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_destination_names">get_destination_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_names">get_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_urls">get_node_urls</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ontologies">get_node_ontologies</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids">get_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_ids">get_edge_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_edge_type_ids">get_unique_edge_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_names">get_edge_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_edge_type_names">get_unique_edge_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weights">get_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_node_indegrees">get_weighted_node_indegrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_ids">get_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_known_node_types_mask">get_known_node_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unknown_node_types_mask">get_unknown_node_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_one_hot_encoded_node_types">get_one_hot_encoded_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_one_hot_encoded_known_node_types">get_one_hot_encoded_known_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_one_hot_encoded_edge_types">get_one_hot_encoded_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_one_hot_encoded_known_edge_types">get_one_hot_encoded_known_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_names">get_node_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_node_type_ids">get_unique_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_node_type_names">get_unique_node_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_directed_edges_number">get_unique_directed_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_nodes_mapping">get_nodes_mapping</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_ids">get_edge_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_edge_node_ids">get_directed_edge_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_names">get_edge_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_edge_node_names">get_directed_edge_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unknown_node_types_number">get_unknown_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_known_node_types_number">get_known_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unknown_node_types_rate">get_unknown_node_types_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_known_node_types_rate">get_known_node_types_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_minimum_node_types_number">get_minimum_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_maximum_node_types_number">get_maximum_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_maximum_multilabel_count">get_maximum_multilabel_count</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_node_types_number">get_singleton_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_node_type_ids">get_singleton_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_node_type_names">get_singleton_node_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unknown_edge_types_number">get_unknown_edge_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_ids_with_unknown_edge_types">get_edge_ids_with_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_ids_with_known_edge_types">get_edge_ids_with_known_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_ids_with_unknown_edge_types">get_edge_node_ids_with_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_ids_with_known_edge_types">get_edge_node_ids_with_known_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_names_with_unknown_edge_types">get_edge_node_names_with_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_names_with_known_edge_types">get_edge_node_names_with_known_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_ids_with_unknown_edge_types_mask">get_edge_ids_with_unknown_edge_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_ids_with_known_edge_types_mask">get_edge_ids_with_known_edge_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_with_unknown_node_types">get_node_ids_with_unknown_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_with_known_node_types">get_node_ids_with_known_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_names_with_unknown_node_types">get_node_names_with_unknown_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_names_with_known_node_types">get_node_names_with_known_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_with_unknown_node_types_mask">get_node_ids_with_unknown_node_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_with_known_node_types_mask">get_node_ids_with_known_node_types_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_known_edge_types_number">get_known_edge_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unknown_edge_types_rate">get_unknown_edge_types_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_known_edge_types_rate">get_known_edge_types_rate</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_minimum_edge_types_number">get_minimum_edge_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_edge_types_number">get_singleton_edge_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_edge_type_ids">get_singleton_edge_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_singleton_edge_type_names">get_singleton_edge_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_nodes">get_number_of_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_connected_component_ids">get_node_connected_component_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_edges_number">get_directed_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_types_number">get_edge_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_types_number">get_node_types_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degrees">get_node_degrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_indegrees">get_node_indegrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_node_degrees">get_weighted_node_degrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_not_singletons_node_ids">get_not_singletons_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_dense_nodes_mapping">get_dense_nodes_mapping</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_parallel_edges_number">get_parallel_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_cumulative_node_degrees">get_cumulative_node_degrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_reciprocal_sqrt_degrees">get_reciprocal_sqrt_degrees</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_unique_source_nodes">get_number_of_unique_source_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_id_counts_hashmap">get_edge_type_id_counts_hashmap</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_names_counts_hashmap">get_edge_type_names_counts_hashmap</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_id_counts_hashmap">get_node_type_id_counts_hashmap</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_names_counts_hashmap">get_node_type_names_counts_hashmap</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_default_graph_name">has_default_graph_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_nodes">has_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edges">has_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_trap_nodes">has_trap_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_directed">is_directed</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_weights">has_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_weights_representing_probabilities">has_edge_weights_representing_probabilities</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_weighted_singleton_nodes">has_weighted_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_constant_edge_weights">has_constant_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_negative_edge_weights">has_negative_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_types">has_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_selfloops">has_selfloops</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_disconnected_nodes">has_disconnected_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_singleton_nodes">has_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_singleton_nodes_with_selfloops">has_singleton_nodes_with_selfloops</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_connected">is_connected</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_types">has_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_multilabel_node_types">has_multilabel_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_unknown_node_types">has_unknown_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_known_node_types">has_known_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_unknown_edge_types">has_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_known_edge_types">has_known_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_homogeneous_node_types">has_homogeneous_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_homogeneous_edge_types">has_homogeneous_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_singleton_node_types">has_singleton_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_oddities">has_node_oddities</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_types_oddities">has_node_types_oddities</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_singleton_edge_types">has_singleton_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_types_oddities">has_edge_types_oddities</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_multigraph">is_multigraph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_nodes_sorted_by_decreasing_outbound_node_degree">has_nodes_sorted_by_decreasing_outbound_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_nodes_sorted_by_lexicographic_order">has_nodes_sorted_by_lexicographic_order</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.contains_identity_matrix">contains_identity_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_nodes_sorted_by_increasing_outbound_node_degree">has_nodes_sorted_by_increasing_outbound_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_total_edge_weights">get_total_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_mininum_edge_weight">get_mininum_edge_weight</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_maximum_edge_weight">get_maximum_edge_weight</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_maximum_node_degree">get_unchecked_maximum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_minimum_node_degree">get_unchecked_minimum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_maximum_node_degree">get_weighted_maximum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_minimum_node_degree">get_weighted_minimum_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_weighted_singleton_nodes">get_number_of_weighted_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_selfloops_number">get_selfloops_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unique_selfloops_number">get_unique_selfloops_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.overlaps">overlaps</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.contains">contains</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.sample_negatives">sample_negatives</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.connected_holdout">connected_holdout</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.random_holdout">random_holdout</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_holdout_indices">get_node_label_holdout_indices</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_holdout_labels">get_node_label_holdout_labels</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_holdout_graphs">get_node_label_holdout_graphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_label_holdout_graphs">get_edge_label_holdout_graphs</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_random_subgraph">get_random_subgraph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_random_holdout">get_node_label_random_holdout</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_kfold">get_node_label_kfold</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_label_random_holdout">get_edge_label_random_holdout</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_label_kfold">get_edge_label_kfold</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_prediction_kfold">get_edge_prediction_kfold</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_laplacian_transformed_graph">get_laplacian_transformed_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_laplacian_coo_matrix_edges_number">get_laplacian_coo_matrix_edges_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_random_walk_normalized_laplacian_transformed_graph">get_random_walk_normalized_laplacian_transformed_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_symmetric_normalized_laplacian_transformed_graph">get_symmetric_normalized_laplacian_transformed_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_symmetric_normalized_transformed_graph">get_symmetric_normalized_transformed_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_undirected_louvain_community_detection">get_undirected_louvain_community_detection</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_directed_modularity_from_node_community_memberships">get_directed_modularity_from_node_community_memberships</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_undirected_modularity_from_node_community_memberships">get_undirected_modularity_from_node_community_memberships</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_memory_stats">get_memory_stats</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_total_memory_used">get_total_memory_used</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_nodes_total_memory_requirement">get_nodes_total_memory_requirement</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_nodes_total_memory_requirement_human_readable">get_nodes_total_memory_requirement_human_readable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edges_total_memory_requirement">get_edges_total_memory_requirement</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edges_total_memory_requirement_human_readable">get_edges_total_memory_requirement_human_readable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weights_total_memory_requirements">get_edge_weights_total_memory_requirements</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weights_total_memory_requirements_human_readable">get_edge_weights_total_memory_requirements_human_readable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_types_total_memory_requirements">get_node_types_total_memory_requirements</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_types_total_memory_requirements_human_readable">get_node_types_total_memory_requirements_human_readable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_types_total_memory_requirements">get_edge_types_total_memory_requirements</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_types_total_memory_requirements_human_readable">get_edge_types_total_memory_requirements_human_readable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.enable">enable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_random_nodes">get_random_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_breadth_first_search_random_nodes">get_breadth_first_search_random_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_uniform_random_walk_random_nodes">get_uniform_random_walk_random_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_sampling_methods">get_node_sampling_methods</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_subsampled_nodes">get_subsampled_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_compatible">is_compatible</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_same_adjacency_matrix">has_same_adjacency_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_node_id">validate_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_node_ids">validate_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_edge_id">validate_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_edge_ids">validate_edge_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_not_contain_unknown_node_types">must_not_contain_unknown_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_not_contain_unknown_edge_types">must_not_contain_unknown_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_node_type_id">validate_node_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_node_type_ids">validate_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_edge_type_id">validate_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.validate_edge_type_ids">validate_edge_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_be_undirected">must_be_undirected</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_be_multigraph">must_be_multigraph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_not_be_multigraph">must_not_be_multigraph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_contain_identity_matrix">must_contain_identity_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_not_contain_weighted_singleton_nodes">must_not_contain_weighted_singleton_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_have_edges">must_have_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_have_nodes">must_have_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.must_be_connected">must_be_connected</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_triangles">get_number_of_triangles</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_triads_number">get_triads_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_triads_number">get_weighted_triads_number</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_transitivity">get_transitivity</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_number_of_triangles_per_node">get_number_of_triangles_per_node</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_clustering_coefficient_per_node">get_clustering_coefficient_per_node</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_clustering_coefficient">get_clustering_coefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_average_clustering_coefficient">get_average_clustering_coefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_okapi_bm25_node_feature_propagation">get_okapi_bm25_node_feature_propagation</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_okapi_bm25_node_label_propagation">get_okapi_bm25_node_label_propagation</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_weight_from_edge_id">get_unchecked_edge_weight_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_weight_from_node_ids">get_unchecked_edge_weight_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_id_from_node_name">get_unchecked_node_id_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_type_id_from_edge_type_name">get_unchecked_edge_type_id_from_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_type_name_from_edge_type_id">get_unchecked_edge_type_name_from_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_count_from_edge_type_id">get_unchecked_edge_count_from_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id">get_unchecked_edge_id_from_node_ids_and_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_minmax_edge_ids_from_node_ids">get_unchecked_minmax_edge_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_ids_from_edge_id">get_unchecked_node_ids_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_names_from_edge_id">get_unchecked_node_names_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_source_node_id_from_edge_id">get_unchecked_source_node_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_destination_node_id_from_edge_id">get_unchecked_destination_node_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_source_node_id_from_edge_id">get_source_node_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_destination_node_id_from_edge_id">get_destination_node_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_source_node_name_from_edge_id">get_unchecked_source_node_name_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_destination_node_name_from_edge_id">get_unchecked_destination_node_name_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_source_node_name_from_edge_id">get_source_node_name_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_destination_node_name_from_edge_id">get_destination_node_name_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_names_from_edge_id">get_node_names_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_from_edge_id">get_node_ids_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_id_from_node_ids">get_unchecked_edge_id_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_id_from_node_ids">get_edge_id_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_unique_source_node_id">get_unchecked_unique_source_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id">get_unchecked_node_ids_and_edge_type_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_and_edge_type_id_from_edge_id">get_node_ids_and_edge_type_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_top_k_central_node_ids">get_top_k_central_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_top_k_central_node_ids">get_weighted_top_k_central_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_degree_from_node_id">get_unchecked_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_weighted_node_degree_from_node_id">get_unchecked_weighted_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degree_from_node_id">get_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_comulative_node_degree_from_node_id">get_unchecked_comulative_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_comulative_node_degree_from_node_id">get_comulative_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_reciprocal_sqrt_degree_from_node_id">get_unchecked_reciprocal_sqrt_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_reciprocal_sqrt_degree_from_node_id">get_reciprocal_sqrt_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_reciprocal_sqrt_degrees_from_node_ids">get_unchecked_reciprocal_sqrt_degrees_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_node_degree_from_node_id">get_weighted_node_degree_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_degree_from_node_name">get_node_degree_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_top_k_central_node_names">get_top_k_central_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_type_id_from_node_id">get_unchecked_node_type_id_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_ids_from_node_id">get_node_type_ids_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_type_id_from_edge_id">get_unchecked_edge_type_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_id_from_edge_id">get_edge_type_id_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_type_names_from_node_id">get_unchecked_node_type_names_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_names_from_node_id">get_node_type_names_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_names_from_node_name">get_node_type_names_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_name_from_edge_id">get_edge_type_name_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_name_from_edge_type_id">get_edge_type_name_from_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weight_from_edge_id">get_edge_weight_from_edge_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weight_from_node_ids">get_edge_weight_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weight_from_node_ids_and_edge_type_id">get_edge_weight_from_node_ids_and_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weight_from_node_names_and_edge_type_name">get_edge_weight_from_node_names_and_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weight_from_node_names">get_edge_weight_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_name_from_node_id">get_unchecked_node_name_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_name_from_node_id">get_node_name_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_id_from_node_name">get_node_id_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_ids_from_node_names">get_node_ids_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_ids_from_edge_node_names">get_edge_node_ids_from_edge_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_node_names_from_edge_node_ids">get_edge_node_names_from_edge_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_ids_from_node_name">get_node_type_ids_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_name_from_node_name">get_node_type_name_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_count_from_edge_type_id">get_edge_count_from_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_id_from_edge_type_name">get_edge_type_id_from_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_count_from_edge_type_name">get_edge_count_from_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_id_from_node_type_name">get_node_type_id_from_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_count_from_node_type_id">get_node_count_from_node_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_count_from_node_type_name">get_node_count_from_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_neighbour_node_ids_from_node_id">get_neighbour_node_ids_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_neighbour_node_ids_from_node_name">get_neighbour_node_ids_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_neighbour_node_names_from_node_name">get_neighbour_node_names_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_minmax_edge_ids_from_node_ids">get_minmax_edge_ids_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_id_from_node_ids_and_edge_type_id">get_edge_id_from_node_ids_and_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_id_from_node_names">get_edge_id_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_id_from_node_names_and_edge_type_name">get_edge_id_from_node_names_and_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_type_ids_from_edge_type_names">get_edge_type_ids_from_edge_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_ids_from_node_type_names">get_node_type_ids_from_node_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_multiple_node_type_ids_from_node_type_names">get_multiple_node_type_ids_from_node_type_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_minmax_edge_ids_from_source_node_id">get_unchecked_minmax_edge_ids_from_source_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_minmax_edge_ids_from_source_node_id">get_minmax_edge_ids_from_source_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_type_name_from_node_type_id">get_node_type_name_from_node_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_node_type_names_from_node_type_ids">get_unchecked_node_type_names_from_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_connected_from_node_id">is_unchecked_connected_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_disconnected_node_from_node_id">is_unchecked_disconnected_node_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_singleton_from_node_id">is_unchecked_singleton_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_singleton_from_node_id">is_singleton_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_singleton_with_selfloops_from_node_id">is_unchecked_singleton_with_selfloops_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_singleton_with_selfloops_from_node_id">is_singleton_with_selfloops_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_singleton_from_node_name">is_unchecked_singleton_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_singleton_from_node_name">is_singleton_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_name">has_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_type_id">has_node_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_type_name">has_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_type_id">has_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_type_name">has_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_from_node_ids">has_edge_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_selfloop_from_node_id">has_selfloop_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_from_node_ids_and_edge_type_id">has_edge_from_node_ids_and_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_unchecked_trap_node_from_node_id">is_unchecked_trap_node_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.is_trap_node_from_node_id">is_trap_node_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_node_name_and_node_type_name">has_node_name_and_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_from_node_names">has_edge_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.has_edge_from_node_names_and_edge_type_name">has_edge_from_node_names_and_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_random_connected_graph">generate_random_connected_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_random_spanning_tree">generate_random_spanning_tree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_circle_graph">generate_circle_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_chain_graph">generate_chain_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_complete_graph">generate_complete_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_barbell_graph">generate_barbell_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.are_nodes_remappable">are_nodes_remappable</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remap_unchecked_from_node_ids">remap_unchecked_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remap_from_node_ids">remap_from_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remap_from_node_names">remap_from_node_names</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remap_from_graph">remap_from_graph</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_components">remove_components</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.replace">replace</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.report">report</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.overlap_textual_report">overlap_textual_report</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_report_from_node_id">get_node_report_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_report_from_node_name">get_node_report_from_node_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.textual_report">textual_report</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.add_selfloops">add_selfloops</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.set_inplace_all_edge_types">set_inplace_all_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.set_all_edge_types">set_all_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.set_inplace_all_node_types">set_inplace_all_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.set_all_node_types">set_all_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_node_type_ids">remove_inplace_node_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_singleton_node_types">remove_inplace_singleton_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_edge_type_ids">remove_inplace_edge_type_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_singleton_edge_types">remove_inplace_singleton_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_node_type_name">remove_inplace_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_node_type_id">remove_node_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_singleton_node_types">remove_singleton_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_node_type_name">remove_node_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_edge_type_name">remove_inplace_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_edge_type_id">remove_edge_type_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_singleton_edge_types">remove_singleton_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_edge_type_name">remove_edge_type_name</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_node_types">remove_inplace_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_node_types">remove_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_edge_types">remove_inplace_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_edge_types">remove_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_inplace_edge_weights">remove_inplace_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.remove_edge_weights">remove_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.sort_by_increasing_outbound_node_degree">sort_by_increasing_outbound_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.sort_by_decreasing_outbound_node_degree">sort_by_decreasing_outbound_node_degree</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.sort_by_node_lexicographic_order">sort_by_node_lexicographic_order</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_bfs_topological_sorting_from_node_id">get_bfs_topological_sorting_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_reversed_bfs_topological_sorting_from_node_id">get_reversed_bfs_topological_sorting_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.sort_by_bfs_topological_sorting_from_node_id">sort_by_bfs_topological_sorting_from_node_id</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_sparse_edge_weighting_methods">get_sparse_edge_weighting_methods</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_weighting_methods">get_edge_weighting_methods</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.strongly_connected_components">strongly_connected_components</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.generate_new_edges_from_node_features">generate_new_edges_from_node_features</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_directed_inplace">to_directed_inplace</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_directed">to_directed</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_upper_triangular">to_upper_triangular</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_lower_triangular">to_lower_triangular</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_main_diagonal">to_main_diagonal</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_anti_diagonal">to_anti_diagonal</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_bidiagonal">to_bidiagonal</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_arrowhead">to_arrowhead</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_transposed">to_transposed</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_complementary">to_complementary</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_transitive_closure">get_transitive_closure</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_all_shortest_paths">get_all_shortest_paths</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_weighted_all_shortest_paths">get_weighted_all_shortest_paths</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.random_spanning_arborescence_kruskal">random_spanning_arborescence_kruskal</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.spanning_arborescence_kruskal">spanning_arborescence_kruskal</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.connected_components">connected_components</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.approximated_vertex_cover_set">approximated_vertex_cover_set</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.to_dot">to_dot</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.cooccurence_matrix">cooccurence_matrix</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.node2vec">node2vec</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_node_label_prediction_mini_batch">get_node_label_prediction_mini_batch</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_prediction_mini_batch">get_edge_prediction_mini_batch</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_unchecked_edge_prediction_metrics">get_unchecked_edge_prediction_metrics</a>
                        </li>
                        <li>
                                <a class="function" href="#Graph.get_edge_prediction_metrics">get_edge_prediction_metrics</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="module" href="#preprocessing">preprocessing</a>
            </li>
            <li>
                    <a class="module" href="#datasets">datasets</a>
            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../grape.html">grape</a><wbr>.ensmallen    </h1>

                        <div class="docstring"><p><a href="https://github.com/AnacletoLAB/grape">GRAPE</a> (Graph Processing and Embedding) is a fast graph processing and embedding library, designed to scale with big graphs and to run on both off-the-shelf laptop and desktop computers and High Performance Computing clusters of workstations.
The library is written in Rust and Python programming languages and is composed of two main modules: <a href="https://github.com/AnacletoLAB/ensmallen">Ensmallen</a> (ENabler of SMALL runtimE and memory Needs) and <a href="https://github.com/monarch-initiative/embiggen">Embiggen</a> (EMBeddInG GENerator), that run synergistically using parallel computation and efficient data structures.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[GRAPE](https://github.com/AnacletoLAB/grape) (Graph Processing and Embedding) is a fast graph processing and embedding library, designed to scale with big graphs and to run on both off-the-shelf laptop and desktop computers and High Performance Computing clusters of workstations.</span>
<span class="sd">The library is written in Rust and Python programming languages and is composed of two main modules: [Ensmallen](https://github.com/AnacletoLAB/ensmallen) (ENabler of SMALL runtimE and memory Needs) and [Embiggen](https://github.com/monarch-initiative/embiggen) (EMBeddInG GENerator), that run synergistically using parallel computation and efficient data structures.</span>
<span class="sd">&quot;&quot;&quot;</span> 
<span class="kn">from</span> <span class="nn">.ensmallen</span> <span class="kn">import</span> <span class="n">preprocessing</span>  <span class="c1"># pylint: disable=import-error</span>
<span class="kn">from</span> <span class="nn">.ensmallen</span> <span class="kn">import</span> <span class="n">Graph</span>  <span class="c1"># pylint: disable=import-error</span>
<span class="kn">from</span> <span class="nn">.ensmallen</span> <span class="kn">import</span> <span class="n">edge_list_utils</span>  <span class="c1"># pylint: disable=import-error</span>

<span class="c1"># The import of dataset should ALWAYS be under the imports from the compiled bindings</span>
<span class="c1"># Because otherwise it generate a Circular import and crash</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">datasets</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;edge_list_utils&quot;</span><span class="p">,</span> <span class="s2">&quot;Graph&quot;</span><span class="p">,</span> <span class="s2">&quot;preprocessing&quot;</span><span class="p">,</span> <span class="s2">&quot;datasets&quot;</span><span class="p">]</span>
</pre></div>

        </details>

            </section>
                <section id="edge_list_utils">
                                <div class="attr module"><a class="headerlink" href="#edge_list_utils">#&nbsp;&nbsp</a>
<span class="name">grape.ensmallen.ensmallen.edge_list_utils</span></div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>



<span class="k">def</span> <span class="nf">add_numeric_id_to_csv</span><span class="p">(</span><span class="n">original_csv_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_csv_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_csv_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_csv_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_csv_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_csv_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_csv_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_csv_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">lines_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new CSV with the lines number added to it.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_csv_path: str</span>
<span class="sd">        The path from where to load the original CSV.</span>
<span class="sd">    original_csv_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original CSV.</span>
<span class="sd">    original_csv_header: Optional[bool]</span>
<span class="sd">        Whether the original CSV has an header.</span>
<span class="sd">    target_csv_path: str</span>
<span class="sd">        The path from where to load the target CSV. This cannot be the same as the original CSV.</span>
<span class="sd">    target_csv_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target CSV. If None, the one provided from the original CSV will be used.</span>
<span class="sd">    target_csv_header: Optional[bool]</span>
<span class="sd">        Whether the target CSV has an header. If None, the one provided from the original CSV will be used.</span>
<span class="sd">    target_csv_ids_column: Optional[str]</span>
<span class="sd">        The column name to use for the ids in the target list.</span>
<span class="sd">    target_csv_ids_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the ids in the target list.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original CSV.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original CSV.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original CSV.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are problems with opening the original or target file.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the original and target paths are identical.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">are_there_selfloops_in_edge_list</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return whether there are selfloops in the edge list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use for the lines to skip.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The number of rows to read at most. Note that this parameter is ignored when reading in parallel.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        Number of edges in the edge list.</span>
<span class="sd">    load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">        Whether to execute the task in parallel or sequential. Generally, parallel is preferable.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">build_optimal_lists_files</span><span class="p">(</span><span class="n">original_node_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_minimum_node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_load_node_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_type_list_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_type_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_list_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_skip_node_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_load_node_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_type_list_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">original_edge_list_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;TODO: write the docstrin&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">convert_directed_edge_list_to_undirected</span><span class="p">(</span><span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new undirected edge list from a given directed one by duplicating the undirected edges.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_edge_path: str</span>
<span class="sd">        The path from where to load the original edge list.</span>
<span class="sd">    original_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original edge list.</span>
<span class="sd">    original_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the original edge list has an header.</span>
<span class="sd">    original_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the original edges list.</span>
<span class="sd">    original_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the original edges list.</span>
<span class="sd">    original_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the original edges list.</span>
<span class="sd">    original_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the original edges list.</span>
<span class="sd">    original_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the original edges list.</span>
<span class="sd">    original_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the original edges list.</span>
<span class="sd">    target_edge_path: str</span>
<span class="sd">        The path from where to load the target edge list. This must be different from the original edge list path.</span>
<span class="sd">    target_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target edge list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the target edge list has an header. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original edge list.</span>
<span class="sd">    default_edge_type: Optional[str]</span>
<span class="sd">        The default edge type to use within the original edge list.</span>
<span class="sd">    default_weight: Optional[float]</span>
<span class="sd">        The default weight to use within the original edge list.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original edge list.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        The expected number of edges. It will be used for the loading bar.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.</span>
<span class="sd">    skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the weights if they are not available.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are problems with opening the original or target file.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the original and target paths are identical.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">convert_edge_list_to_numeric</span><span class="p">(</span><span class="n">original_node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_load_node_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_type_list_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Create a new edge list starting from given one with node IDs densified.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_edge_path: str</span>
<span class="sd">        The path from where to load the original edge list.</span>
<span class="sd">    original_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original edge list.</span>
<span class="sd">    original_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the original edge list has an header.</span>
<span class="sd">    original_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the original edges list.</span>
<span class="sd">    original_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the original edges list.</span>
<span class="sd">    original_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the original edges list.</span>
<span class="sd">    original_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the original edges list.</span>
<span class="sd">    original_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the original edges list.</span>
<span class="sd">    original_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the original edges list.</span>
<span class="sd">    target_edge_path: str</span>
<span class="sd">        The path from where to load the target edge list. This must be different from the original edge list path.</span>
<span class="sd">    target_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target edge list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the target edge list has an header. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_node_path: Optional[str]</span>
<span class="sd">        The optional name for the node list to be written out.</span>
<span class="sd">    target_node_list_separator: Optional[str]</span>
<span class="sd">        The separator to use for the node list.</span>
<span class="sd">    target_node_list_header: Optional[bool]</span>
<span class="sd">        Whether to add the header to the node list.</span>
<span class="sd">    target_nodes_column: Optional[str]</span>
<span class="sd">        The column name for the node names.</span>
<span class="sd">    target_nodes_column_number: Optional[int]</span>
<span class="sd">        The column number for the node names.</span>
<span class="sd">    target_node_ids_column: Optional[str]</span>
<span class="sd">        The column name for the node IDs.</span>
<span class="sd">    target_node_ids_column_number: Optional[int]</span>
<span class="sd">        The column number for the node IDs.</span>
<span class="sd">    target_edge_type_list_path: Optional[str]</span>
<span class="sd">        The optional path where to store the parsed edge types.</span>
<span class="sd">    target_edge_type_list_edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number where to store the edge type names.</span>
<span class="sd">    target_edge_type_list_edge_types_column: Optional[str]</span>
<span class="sd">        The column name where to store the edge type names.</span>
<span class="sd">    target_edge_types_ids_column_number: Optional[int]</span>
<span class="sd">        The column number where to the store the edge type IDs.</span>
<span class="sd">    target_edge_types_ids_column: Optional[str]</span>
<span class="sd">        The column name where to store the edge type IDs.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original edge list.</span>
<span class="sd">    default_edge_type: Optional[str]</span>
<span class="sd">        The default edge type to use within the original edge list.</span>
<span class="sd">    default_weight: Optional[float]</span>
<span class="sd">        The default weight to use within the original edge list.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original edge list.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        The expected number of edges. It will be used for the loading bar.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.</span>
<span class="sd">    skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the weights if they are not available.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are problems with opening the original or target file.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the original and target paths are identical.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">densify_sparse_numeric_edge_list</span><span class="p">(</span><span class="n">maximum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_type_list_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_type_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Create a new edge list starting from given numeric one with node IDs densified and returns the number of unique nodes.</span>
<span class="sd">    </span>
<span class="sd">    This method is meant as a solution to parse very large sparse numeric graphs,</span>
<span class="sd">    like for instance ClueWeb.</span>
<span class="sd">    </span>
<span class="sd">    Safety</span>
<span class="sd">    ------</span>
<span class="sd">    This method will panic if the node IDs are not numeric.</span>
<span class="sd">     TODO: In the future we may handle this case as a normal error.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maximum_node_id: Optional[int]</span>
<span class="sd">        The maximum node ID present in this graph. If available, optimal memory allocation will be used.</span>
<span class="sd">    original_edge_path: str</span>
<span class="sd">        The path from where to load the original edge list.</span>
<span class="sd">    original_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original edge list.</span>
<span class="sd">    original_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the original edge list has an header.</span>
<span class="sd">    original_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the original edges list.</span>
<span class="sd">    original_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the original edges list.</span>
<span class="sd">    original_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the original edges list.</span>
<span class="sd">    original_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the original edges list.</span>
<span class="sd">    original_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the original edges list.</span>
<span class="sd">    original_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the original edges list.</span>
<span class="sd">    target_edge_path: str</span>
<span class="sd">        The path from where to load the target edge list.</span>
<span class="sd">    target_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target edge list.</span>
<span class="sd">    target_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the target edge list has an header.</span>
<span class="sd">    target_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the target edges list.</span>
<span class="sd">    target_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the target edges list.</span>
<span class="sd">    target_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the target edges list.</span>
<span class="sd">    target_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the target edges list.</span>
<span class="sd">    target_edge_list_edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the target edges list.</span>
<span class="sd">    target_edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the target edges list.</span>
<span class="sd">    target_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the target edges list.</span>
<span class="sd">    target_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the target edges list.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original edge list.</span>
<span class="sd">    default_edge_type: Optional[str]</span>
<span class="sd">        The default edge type to use within the original edge list.</span>
<span class="sd">    default_weight: Optional[float]</span>
<span class="sd">        The default weight to use within the original edge list.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original edge list.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        The expected number of edges. It will be used for the loading bar.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.</span>
<span class="sd">    skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the weights if they are not available.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">convert_node_list_node_types_to_numeric</span><span class="p">(</span><span class="n">original_node_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_minimum_node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_load_node_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_node_type_list_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_node_type_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_type_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_node_list_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_skip_node_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_node_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">convert_undirected_edge_list_to_directed</span><span class="p">(</span><span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new directed edge list from a given undirected one by duplicating the undirected edges.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_edge_path: str</span>
<span class="sd">        The path from where to load the original edge list.</span>
<span class="sd">    original_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original edge list.</span>
<span class="sd">    original_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the original edge list has an header.</span>
<span class="sd">    original_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the original edges list.</span>
<span class="sd">    original_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the original edges list.</span>
<span class="sd">    original_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the original edges list.</span>
<span class="sd">    original_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the original edges list.</span>
<span class="sd">    original_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the original edges list.</span>
<span class="sd">    original_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the original edges list.</span>
<span class="sd">    target_edge_path: str</span>
<span class="sd">        The path from where to load the target edge list. This must be different from the original edge list path.</span>
<span class="sd">    target_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target edge list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the target edge list has an header. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    target_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the target edges list. If None, the one provided from the original edge list will be used.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original edge list.</span>
<span class="sd">    default_edge_type: Optional[str]</span>
<span class="sd">        The default edge type to use within the original edge list.</span>
<span class="sd">    default_weight: Optional[float]</span>
<span class="sd">        The default weight to use within the original edge list.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original edge list.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        The expected number of edges. It will be used for the loading bar.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.</span>
<span class="sd">    skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the weights if they are not available.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">filter_duplicates_from_edge_list</span><span class="p">(</span><span class="n">original_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">original_edge_list_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">original_edge_list_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_edge_list_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">target_edge_list_sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_edge_type_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target_edge_list_weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_edge_list_weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Create a new edge list from a given one filtering duplicates.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_edge_path: str</span>
<span class="sd">        The path from where to load the original edge list.</span>
<span class="sd">    original_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the original edge list.</span>
<span class="sd">    original_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the original edge list has an header.</span>
<span class="sd">    original_edge_list_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the original edges list.</span>
<span class="sd">    original_edge_list_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the original edges list.</span>
<span class="sd">    original_edge_list_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the original edges list.</span>
<span class="sd">    original_edge_list_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the original edges list.</span>
<span class="sd">    original_edge_list_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the original edges list.</span>
<span class="sd">    target_edge_path: str</span>
<span class="sd">        The path from where to load the target edge list.</span>
<span class="sd">    target_edge_list_separator: Optional[str]</span>
<span class="sd">        Separator to use for the target edge list.</span>
<span class="sd">    target_edge_list_header: Optional[bool]</span>
<span class="sd">        Whether the target edge list has an header.</span>
<span class="sd">    target_edge_list_sources_column: Optional[str]</span>
<span class="sd">        The column name to use to load the sources in the target edges list.</span>
<span class="sd">    target_edge_list_sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the sources in the target edges list.</span>
<span class="sd">    target_edge_list_destinations_column: Optional[str]</span>
<span class="sd">        The column name to use to load the destinations in the target edges list.</span>
<span class="sd">    target_edge_list_destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use to load the destinations in the target edges list.</span>
<span class="sd">    target_edge_list_edge_type_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types in the target edges list.</span>
<span class="sd">    target_edge_list_edge_type_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types in the target edges list.</span>
<span class="sd">    target_edge_list_weights_column: Optional[str]</span>
<span class="sd">        The column name to use for the weights in the target edges list.</span>
<span class="sd">    target_edge_list_weights_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the weights in the target edges list.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use within the original edge list.</span>
<span class="sd">    default_edge_type: Optional[str]</span>
<span class="sd">        The default edge type to use within the original edge list.</span>
<span class="sd">    default_weight: Optional[float]</span>
<span class="sd">        The default weight to use within the original edge list.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The amount of rows to load from the original edge list.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        The amount of rows to skip from the original edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        The expected number of edges. It will be used for the loading bar.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.</span>
<span class="sd">    skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the weights if they are not available.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">get_minmax_node_from_numeric_edge_list</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return minimum and maximum node number from given numeric edge list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use for the lines to skip.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The number of rows to read at most. Note that this parameter is ignored when reading in parallel.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        Number of edges in the edge list.</span>
<span class="sd">    load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">        Whether to execute the task in parallel or sequential. Generally, parallel is preferable.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are problems with the edge list file.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the elements in the edge list are not numeric.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the edge list is empty.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">get_rows_number</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return number of rows in given CSV path.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_path: str</span>
<span class="sd">        The path from where to load the original CSV.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are problems with opening the file.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">get_selfloops_number_from_edge_list</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return number of selfloops in the given edge list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use for the lines to skip.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The number of rows to read at most. Note that this parameter is ignored when reading in parallel.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        Number of edges in the edge list.</span>
<span class="sd">    load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">        Whether to execute the task in parallel or sequential. Generally, parallel is preferable.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">is_numeric_edge_list</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return number of selfloops in the given edge list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    comment_symbol: Optional[str]</span>
<span class="sd">        The comment symbol to use for the lines to skip.</span>
<span class="sd">    max_rows_number: Optional[int]</span>
<span class="sd">        The number of rows to read at most. Note that this parameter is ignored when reading in parallel.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    edges_number: Optional[int]</span>
<span class="sd">        Number of edges in the edge list.</span>
<span class="sd">    load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">        Whether to execute the task in parallel or sequential. Generally, parallel is preferable.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show the loading bar while processing the file.</span>
<span class="sd">    name: Optional[str]</span>
<span class="sd">        The name of the graph to display in the loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">sort_numeric_edge_list</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Sort given numeric edge list in place using the sort command.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    target_path: str</span>
<span class="sd">        The where to store the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types.</span>
<span class="sd">    edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">sort_numeric_edge_list_inplace</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Sort given numeric edge list in place using the sort command.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str</span>
<span class="sd">        The path from where to load the edge list.</span>
<span class="sd">    separator: Optional[str]</span>
<span class="sd">        The separator for the rows in the edge list.</span>
<span class="sd">    header: Optional[bool]</span>
<span class="sd">        Whether the edge list has an header.</span>
<span class="sd">    sources_column: Optional[str]</span>
<span class="sd">        The column name to use for the source nodes.</span>
<span class="sd">    sources_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the source nodes.</span>
<span class="sd">    destinations_column: Optional[str]</span>
<span class="sd">        The column name to use for the destination nodes.</span>
<span class="sd">    destinations_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the destination nodes.</span>
<span class="sd">    edge_types_column: Optional[str]</span>
<span class="sd">        The column name to use for the edge types.</span>
<span class="sd">    edge_types_column_number: Optional[int]</span>
<span class="sd">        The column number to use for the edge types.</span>
<span class="sd">    rows_to_skip: Optional[int]</span>
<span class="sd">        Number of rows to skip in the edge list.</span>
<span class="sd">    skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">        Whether to automatically skip the edge types if they are not available.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>

        </details>

    

                </section>
                <section id="Graph">
                                <div class="attr class">
        <a class="headerlink" href="#Graph">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Graph</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This is the main struct in Ensmallen, it allows to load and manipulate Graphs efficently.</span>
<span class="sd">  You are not supposed to directly instantiate this struct but instead you should use the</span>
<span class="sd">  static method `from_csv`, which allows to load the graph from an edge-list.</span>
<span class="sd">  </span>
<span class="sd">  To get information about a loaded graph, you can call the `textual_report` method which</span>
<span class="sd">  generates an human-readable HTML report.</span>
<span class="sd">  </span>
<span class="sd">  By default we use EliasFano to store the Adjacency Matrix, this allows to save memory but</span>
<span class="sd">  is slower than a CSR. For this reason you can use the `enable` method to enable optimizzations</span>
<span class="sd">  which speeds up the operations at the cost of more memory usage. You can check the memory usage</span>
<span class="sd">  in bytes using `get_total_memory_used` and you can get a detailed memory report of each data-structure</span>
<span class="sd">  inside Graph using `memory_stats`.</span>
<span class="sd">  </span>
<span class="sd">  You can pre-compute the memory needed (in bits) to store the adjacency matrix of a Graph with $|E|$ edges and $|V|$ nodes: </span>
<span class="sd">  $$2 |E| + |E| \\left\\lceil \\log_2 \\frac{|V|^2}{|E|} \\right\\rceil$$ </span>
<span class="sd">  </span>
<span class="sd">  Most Graph properties are automatically cached to speed up.&quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">dump_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to disk the edges (and optionally the metadata) of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path where to save the edges and their metadata.</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar while writing to file.</span>
<span class="sd">        separator: str = &quot;\t&quot;</span>
<span class="sd">            What separator to use while writing out to file.</span>
<span class="sd">        header: bool = True</span>
<span class="sd">            Wether to write out the header of the file.</span>
<span class="sd">        sources_column_number: int = 0</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        sources_column: str = &quot;subject&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        destinations_column_number: int = 1</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        destinations_column: str = &quot;object&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        edge_types_column_number: int = 2</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        edges_type_column: str = &quot;label&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        weights_column_number: int = 3</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        weights_column: str = &quot;weight&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        numeric_node_ids: bool = False</span>
<span class="sd">            whether to save the internal numeric Ids instead of the string names.</span>
<span class="sd">        directed: bool = False</span>
<span class="sd">            whether to save graph as directed or undirected.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: update the set of exceptions&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a 64-bit hash of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_random_walk_normalized_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_symmetric_normalized_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_symmetric_normalized_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">dump_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to disk the nodes (and optionally the metadata) of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path where to save the nodes and their metadata.</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar while writing to file.</span>
<span class="sd">        separator: str = &quot;\t&quot;</span>
<span class="sd">            What separator to use while writing out to file.</span>
<span class="sd">        header: bool = True</span>
<span class="sd">            Wether to write out the header of the file.</span>
<span class="sd">        nodes_column_number: int = 0</span>
<span class="sd">            The column number where to write the nodes.</span>
<span class="sd">        nodes_column: str = &quot;id&quot;</span>
<span class="sd">            The name of the column of the nodes.</span>
<span class="sd">        node_types_column_number: int = 1</span>
<span class="sd">            The column number where to write the node types.</span>
<span class="sd">        nodes_type_column: str = &quot;category&quot;</span>
<span class="sd">            The name of the column of the node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: update the set of exceptions&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            the number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">complete</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled edges connected to the given node Ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        node_ids: Vec&lt;NodeT&gt;</span>
<span class="sd">            List of nodes whose edges are to return.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        complete: Optional[bool] = True</span>
<span class="sd">            Whether to return the edges in both directions (when dealing with an undirected graph).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_sparse_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_sparse_undirected_laplacian_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes and edges using laplacian assuming undirected graph with selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        TODO: Update</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_prediction_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_prediction_subgraphs_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">source_root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">bool</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        source_root_node: int</span>
<span class="sd">            The source root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        destination_root_node: int</span>
<span class="sd">            The destination root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">spanning_arborescence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns set of edges forming the spanning tree of given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given graph is not undirected.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Numpy array of tuples of NodeIds forming the spanning tree.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        This is the implementaiton of the algorithm presented in the paper</span>
<span class="sd">        A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors</span>
<span class="sd">        by David A. Bader and Guojing Cong.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">random_walks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return random walks done on the graph using Rust.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        quantity: int</span>
<span class="sd">            Number of nodes to sample.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: Update raises</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of list of walks containing the numeric IDs of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">complete_walks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return complete random walks done on the graph using Rust.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: Update raises</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of list of walks containing the numeric IDs of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of unweighted degree centrality for all nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of weighted degree centrality for all nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_stress_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of stress centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_betweenness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of betweenness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int]</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float]</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int]</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float]</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">encode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge value corresponding to given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">decode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns source and destination nodes corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge: int</span>
<span class="sd">            The edge value to decode.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_max_encodable_edge_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return maximum encodable edge number&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_dense_binary_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns binary dense adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_dense_weighted_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns binary weighted adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight value to use for absent edges. By default, `0.0`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_predecessors_parallel_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_distances_parallel_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_distances_sequential_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node is a selfloop.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there is no path between the two given nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node names between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_eccentricity_and_most_distant_node_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_eccentricity_and_most_distant_node_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]]</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: bool</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]]</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        dst_node_name: Optional[str]</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maybe_dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">maybe_dst_node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_name: Optional[str]</span>
<span class="sd">            Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_names: Optional[List[str]]</span>
<span class="sd">            Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_bipartite_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_bipartite_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_star_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_star_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_clique_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool]</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]]</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]]</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_clique_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool]</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]]</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]]</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_all_edge_metrics_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all the implemented edge metrics for the two given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Specifically, the returned values are:</span>
<span class="sd">        * Adamic Adar</span>
<span class="sd">        * Jaccard coefficient</span>
<span class="sd">        * Resource allocation index</span>
<span class="sd">        * Preferential attachment</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">filter_from_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_id_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">node_type_id_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids_to_keep: Optional[List[int]]</span>
<span class="sd">            List of node IDs to keep during filtering.</span>
<span class="sd">        node_ids_to_filter: Optional[List[int]]</span>
<span class="sd">            List of node IDs to remove during filtering.</span>
<span class="sd">        node_type_ids_to_keep: Optional[List[Optional[List[int]]]]</span>
<span class="sd">            List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_ids_to_filter: Optional[List[Optional[List[int]]]]</span>
<span class="sd">            List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_id_to_keep: Optional[List[Optional[int]]]</span>
<span class="sd">            List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_id_to_filter: Optional[List[Optional[int]]]</span>
<span class="sd">            List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_ids_to_keep: Optional[List[int]]</span>
<span class="sd">            List of edge IDs to keep during filtering.</span>
<span class="sd">        edge_ids_to_filter: Optional[List[int]]</span>
<span class="sd">            List of edge IDs to remove during filtering.</span>
<span class="sd">        edge_node_ids_to_keep: Optional[List[Tuple[int, int]]]</span>
<span class="sd">            List of tuple of node IDs to keep during filtering.</span>
<span class="sd">        edge_node_ids_to_filter: Optional[List[Tuple[int, int]]]</span>
<span class="sd">            List of tuple of node IDs to remove during filtering.</span>
<span class="sd">        edge_type_ids_to_keep: Optional[List[Optional[int]]]</span>
<span class="sd">            List of edge type IDs to keep during filtering.</span>
<span class="sd">        edge_type_ids_to_filter: Optional[List[Optional[int]]]</span>
<span class="sd">            List of edge type IDs to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float]</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float]</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool]</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">filter_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_name_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">node_type_name_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names_to_keep: Optional[List[str]]</span>
<span class="sd">            List of node names to keep during filtering.</span>
<span class="sd">        node_names_to_filter: Optional[List[str]]</span>
<span class="sd">            List of node names to remove during filtering.</span>
<span class="sd">        node_type_names_to_keep: Optional[List[Optional[List[str]]]]</span>
<span class="sd">            List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_names_to_filter: Optional[List[Optional[List[str]]]]</span>
<span class="sd">            List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_name_to_keep: Optional[List[Optional[str]]]</span>
<span class="sd">            List of node type name to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_name_to_filter: Optional[List[Optional[str]]]</span>
<span class="sd">            List of node type name to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_node_names_to_keep: Optional[List[Tuple[str, str]]]</span>
<span class="sd">            List of tuple of node names to keep during filtering.</span>
<span class="sd">        edge_node_names_to_filter: Optional[List[Tuple[str, str]]]</span>
<span class="sd">            List of tuple of node names to remove during filtering.</span>
<span class="sd">        edge_type_names_to_keep: Optional[List[Optional[str]]]</span>
<span class="sd">            List of edge type names to keep during filtering.</span>
<span class="sd">        edge_type_names_to_filter: Optional[List[Optional[str]]]</span>
<span class="sd">            List of edge type names to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float]</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float]</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool]</span>
<span class="sd">            Whether to filter out singletons.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool]</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown node types and relative nodes.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL nodes labeled with unknown node</span>
<span class="sd">        type!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown edge types and relative edges.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL edges labeled with unknown edge</span>
<span class="sd">        type!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes with selfloops.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton with selfloop when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without disconnected nodes.</span>
<span class="sd">        </span>
<span class="sd">        A disconnected node is a node with no connection to any other node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">drop_parallel_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without parallel edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="n">node_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_types_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_node_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_node_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">load_node_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">edge_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_complete</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_may_contain_duplicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_sorted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singletons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singleton_with_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return graph renderized from given CSVs or TSVs-like files.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique node type names.</span>
<span class="sd">        node_type_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_number: Optional[int]</span>
<span class="sd">            The number of the unique node types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_node_type_ids: Optional[bool]</span>
<span class="sd">            Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_node_type_id: Optional[int]</span>
<span class="sd">            The minimum node type ID to be used when using numeric node type IDs.</span>
<span class="sd">        node_type_list_header: Optional[bool]</span>
<span class="sd">            Whether the node type file has an header.</span>
<span class="sd">        node_type_list_rows_to_skip: Optional[int]</span>
<span class="sd">            The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.</span>
<span class="sd">        node_type_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_type_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the node types file.</span>
<span class="sd">        node_type_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_node_type_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.</span>
<span class="sd">        node_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique node names.</span>
<span class="sd">        node_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_list_header: Optional[bool]</span>
<span class="sd">            Whether the nodes file has an header.</span>
<span class="sd">        node_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the node list file.</span>
<span class="sd">        node_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the nodes file.</span>
<span class="sd">        node_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        default_node_type: Optional[str]</span>
<span class="sd">            The node type to be used when the node type for a given node in the node file is None.</span>
<span class="sd">        nodes_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node names.</span>
<span class="sd">        nodes_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node names.</span>
<span class="sd">        node_types_separator: Optional[str]</span>
<span class="sd">            The node types separator.</span>
<span class="sd">        node_list_node_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node types.</span>
<span class="sd">        node_list_node_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node types.</span>
<span class="sd">        node_ids_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node IDs.</span>
<span class="sd">        node_ids_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node IDs</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            The minimum node ID to be used, when loading the node IDs as numerical.</span>
<span class="sd">        numeric_node_ids: Optional[bool]</span>
<span class="sd">            Whether to load the numeric node IDs as numeric.</span>
<span class="sd">        node_list_numeric_node_type_ids: Optional[bool]</span>
<span class="sd">            Whether to load the node types IDs in the node file to be numeric.</span>
<span class="sd">        skip_node_types_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the node types without raising an error if these are unavailable.</span>
<span class="sd">        load_node_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.</span>
<span class="sd">        edge_type_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique edge type names.</span>
<span class="sd">        edge_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_number: Optional[int]</span>
<span class="sd">            The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_edge_type_ids: Optional[bool]</span>
<span class="sd">            Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_edge_type_id: Optional[int]</span>
<span class="sd">            The minimum edge type ID to be used when using numeric edge type IDs.</span>
<span class="sd">        edge_type_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_type_list_header: Optional[bool]</span>
<span class="sd">            Whether the edge type file has an header.</span>
<span class="sd">        edge_type_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the edge type list file.</span>
<span class="sd">        edge_type_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_type_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the edge types file.</span>
<span class="sd">        edge_type_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_edge_type_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.</span>
<span class="sd">        edge_path: Optional[str]</span>
<span class="sd">            The path to the file with the edge list.</span>
<span class="sd">        edge_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_list_header: Optional[bool]</span>
<span class="sd">            Whether the edges file has an header.</span>
<span class="sd">        edge_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the edge list file.</span>
<span class="sd">        sources_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        sources_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        destinations_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        destinations_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge types.</span>
<span class="sd">        edge_list_edge_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge types.</span>
<span class="sd">        default_edge_type: Optional[str]</span>
<span class="sd">            The edge type to be used when the edge type for a given edge in the edge file is None.</span>
<span class="sd">        weights_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        weights_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        default_weight: Optional[float]</span>
<span class="sd">            The edge weight to be used when the edge weight for a given edge in the edge file is None.</span>
<span class="sd">        edge_ids_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_ids_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_list_numeric_edge_type_ids: Optional[bool]</span>
<span class="sd">            Whether to load the edge type IDs as numeric from the edge list.</span>
<span class="sd">        edge_list_numeric_node_ids: Optional[bool]</span>
<span class="sd">            Whether to load the edge node IDs as numeric from the edge list.</span>
<span class="sd">        skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the weights without raising an error if these are unavailable.</span>
<span class="sd">        skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the edge types without raising an error if these are unavailable.</span>
<span class="sd">        edge_list_is_complete: Optional[bool]</span>
<span class="sd">            Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.</span>
<span class="sd">        edge_list_may_contain_duplicates: Optional[bool]</span>
<span class="sd">            Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.</span>
<span class="sd">        edge_list_is_sorted: Optional[bool]</span>
<span class="sd">            Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.</span>
<span class="sd">        edge_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the edges file.</span>
<span class="sd">        edge_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        edges_number: Optional[int]</span>
<span class="sd">            The expected number of edges. Note that this must be the EXACT number of edges in the graph.</span>
<span class="sd">        load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.</span>
<span class="sd">        may_have_singletons: Optional[bool]</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        may_have_singleton_with_selfloops: Optional[bool]</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to load the graph as directed or undirected.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            The name of the graph to be loaded.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_connected_components_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_connected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of connected nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_nodes_with_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes with selfloops within the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes within the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of disconnected nodes within the graph.</span>
<span class="sd">        A Disconnected node is a node which is nor a singleton nor a singleton</span>
<span class="sd">        with selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node names of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node names of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns density of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_trap_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the traps rate of the graph.</span>
<span class="sd">        </span>
<span class="sd">        THIS IS EXPERIMENTAL AND MUST BE PROVEN!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted mean node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted mean node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted median node degree of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted median node degree of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method fails with a panic if the graph does not have any node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degrees_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns mode node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_selfloop_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of self-loops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return name of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_trap_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of traps (nodes without any outgoing edges that are not singletons)</span>
<span class="sd">        This also includes nodes with only a self-loops, therefore singletons with</span>
<span class="sd">        only a self-loops are not considered traps because you could make a walk on them.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed source nodes of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_source_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) destination nodes of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed destination nodes of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_destination_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique destination nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node URLs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ontologies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node predicted ontology.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes Ids&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types of the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique edge type IDs of the graph edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the weights of the graph edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted indegree (total weighted inbound edge weights) for each node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the node types of the graph nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_one_hot_encoded_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_one_hot_encoded_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the node types names.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node type IDs of the graph nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node types names.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of the unique edges in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the nodes mapping&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge Ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge Ids&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unknown_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes with unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_known_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of node with known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unknown_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_known_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_minimum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_maximum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_maximum_multilabel_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of maximum multilabel count.</span>
<span class="sd">        </span>
<span class="sd">        This value is the maximum number of multilabel counts</span>
<span class="sd">        that appear in any given node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unknown_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_names_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_names_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_names_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_names_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_known_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of edge with known edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unknown_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_known_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_minimum_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_singleton_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_connected_component_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a vector with the components each node belongs to.</span>
<span class="sd">        </span>
<span class="sd">        E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like</span>
<span class="sd">        `[0, 1, 0, 0, 1, 1]`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of directed edges in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edge types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of node types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted degree of every node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the indegree for each node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted degree of every node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_not_singletons_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return set of nodes that are not singletons&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_dense_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return mapping from instance not trap nodes to dense nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_parallel_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges that have multigraph syblings&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_cumulative_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with node cumulative_node_degrees, that is the comulative node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_reciprocal_sqrt_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector wit&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_unique_source_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of the source nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_default_graph_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if graph has name that is not the default one.</span>
<span class="sd">        </span>
<span class="sd">        TODO: use a default for the default graph name&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_trap_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has trap nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph is directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_weights_representing_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether graph has weights that can represent probabilities&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether a graph has one or more weighted singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A weighted singleton node is a node whose weighted node degree is 0.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_constant_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has constant weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_negative_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has negative weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has self-loops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if nodes which are nor singletons nor</span>
<span class="sd">        singletons with selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph is connected.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar while computing the connected components, if necessary.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_multilabel_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has multilabel node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_homogeneous_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the nodes have an homogenous node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_homogeneous_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the edges have an homogenous edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton node type, that is a node type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node-related graph oddities&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton edge type, that is a edge type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known edge type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if there are multiple edges between two node&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">contains_identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph contains the indentity matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by increasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_total_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return total edge weights, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_mininum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_maximum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weighted node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weighted node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of self-loops, including also those in eventual multi-edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unique_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique self-loops, excluding those in eventual multi-edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether given graph has any edge overlapping with current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if given graph edges are all contained within current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">sample_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negatives_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">seed_graph</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Graph</span><span class="p">],</span> <span class="n">only_from_same_component</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns Graph with given amount of negative edges as positive edges.</span>
<span class="sd">        </span>
<span class="sd">        The graph generated may be used as a testing negatives partition to be</span>
<span class="sd">        fed into the argument &quot;graph_to_avoid&quot; of the link_prediction or the</span>
<span class="sd">        skipgrams algorithm</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        negatives_number: int</span>
<span class="sd">            Number of negatives edges to include.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            random_state to use to reproduce negative edge set.</span>
<span class="sd">        seed_graph: Optional[Graph]</span>
<span class="sd">            Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.</span>
<span class="sd">        only_from_same_component: Optional[bool]</span>
<span class="sd">            Whether to sample negative edges only from nodes that are from the same component.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">connected_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns holdout for training ML algorithms on the graph structure.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. The first one, which</span>
<span class="sd">        is the training graph, is garanteed to have the same number of</span>
<span class="sd">        graph components as the initial graph. The second graph is the graph</span>
<span class="sd">        meant for testing or validation of the algorithm, and has no garantee</span>
<span class="sd">        to be connected. It will have at most (1-train_size) edges,</span>
<span class="sd">        as the bound of connectivity which is required for the training graph</span>
<span class="sd">        may lead to more edges being left into the training partition.</span>
<span class="sd">        </span>
<span class="sd">        In the option where a list of edge types has been provided, these</span>
<span class="sd">        edge types will be those put into the validation set.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            Rate target to reserve for training.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            Edge types to be selected for in the validation set.</span>
<span class="sd">        include_all_edge_types: Optional[bool]</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the required training size is not a real value between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph does not allow for the creation of a spanning tree for the requested training size.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_number_overlaps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns random holdout for training ML algorithms on the graph edges.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. In neither holdouts the</span>
<span class="sd">        graph connectivity is necessarily preserved. To maintain that, use</span>
<span class="sd">        the method `connected_holdout`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        include_all_edge_types: Optional[bool]</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The edges to include in validation set.</span>
<span class="sd">        min_number_overlaps: Optional[int]</span>
<span class="sd">            The minimum number of overlaps to include the edge into the validation set.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the minimum number of overlaps have been specified but the graph is not a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one or more of the given edge type names is not present in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_holdout_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_holdout_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns subgraph with given number of nodes.</span>
<span class="sd">        </span>
<span class="sd">        **This method creates a subset of the graph starting from a random node</span>
<span class="sd">        sampled using given random_state and includes all neighbouring nodes until</span>
<span class="sd">        the required number of nodes is reached**. All the edges connecting any</span>
<span class="sd">        of the selected nodes are then inserted into this graph.</span>
<span class="sd">        </span>
<span class="sd">        This is meant to execute distributed node embeddings.</span>
<span class="sd">        It may also sample singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes: int</span>
<span class="sd">            Number of nodes to extract.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            Random random_state to use.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested number of nodes is one or less.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has less than the requested number of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label fold for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label kfold for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_prediction_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns train and test graph following kfold validation scheme.</span>
<span class="sd">        </span>
<span class="sd">        The edges are splitted into k chunks. The k_index-th chunk is used to build</span>
<span class="sd">        the validation graph, all the other edges create the training graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state (seed) to use for the holdout,</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested k folds is one or zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given k fold index is greater than the number of k folds.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types have been specified but it&#39;s an empty list.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of k folds is higher than the number of edges in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted laplacian transformation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_laplacian_coo_matrix_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges in the laplacian COO matrix representation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_random_walk_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted random walk normalized laplacian transformation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_symmetric_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized laplacian transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_symmetric_normalized_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_undirected_louvain_community_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursion_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">first_phase_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">patience</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recursion_minimum_improvement: Optional[float]</span>
<span class="sd">            The minimum improvement to warrant another resursion round. By default, zero.</span>
<span class="sd">        first_phase_minimum_improvement: Optional[float]</span>
<span class="sd">            The minimum improvement to warrant another first phase iteration. By default, `0.00001` (not zero because of numerical instability).</span>
<span class="sd">        patience: Optional[int]</span>
<span class="sd">            How many iterations of the first phase to wait for before stopping. By default, `5`.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random state to use to reproduce this modularity computation. By default, 42.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `recursion_minimum_improvement` has an invalid value, i.e. NaN or infinity.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `first_phase_minimum_improvement` has an invalid value, i.e. NaN or infinity.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_directed_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_community_memberships</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the directed modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_undirected_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_community_memberships</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the undirected modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_memory_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a string describing the memory usage of all the fields of all the</span>
<span class="sd">        structures used to store the current graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_total_memory_used</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the given graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_destinations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_cumulative_node_degrees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_reciprocal_sqrt_degrees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Enable extra perks that buys you time as you accept to spend more memory.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_sources: Optional[bool]</span>
<span class="sd">            Whether to cache sources into a vector for faster walks.</span>
<span class="sd">        vector_destinations: Optional[bool]</span>
<span class="sd">            Whether to cache destinations into a vector for faster walks.</span>
<span class="sd">        vector_cumulative_node_degrees: Optional[bool]</span>
<span class="sd">            Whether to cache cumulative_node_degrees into a vector for faster walks.</span>
<span class="sd">        vector_reciprocal_sqrt_degrees: Optional[bool]</span>
<span class="sd">            Whether to cache reciprocal_sqrt_degrees into a vector for faster laplacian kernel computation.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return random unique sorted numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_breadth_first_search_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return nodes sampled from the neighbourhood of given root nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        root_node: int</span>
<span class="sd">            The root node from .</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested nodes is higher than the number of nodes in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node does not exist in the curret graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_uniform_random_walk_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unique nodes sampled from uniform random walk.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: int</span>
<span class="sd">            Node from where to start the random walks.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            the random_state to use for extracting the nodes and edges.</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Length of the random walk.</span>
<span class="sd">        unique: Optional[bool]</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node does not exist in the current slack.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_sampling_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported node sampling methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_subsampled_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        unique: Optional[bool]</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs are compatible.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The other graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_same_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs share the same adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The other graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates all provided node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            node IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            Edge ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_edge_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_ids: List[int]</span>
<span class="sd">            Edge IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given edge ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_not_contain_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_not_contain_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int]</span>
<span class="sd">            Node type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[Optional[int]]</span>
<span class="sd">            Vector of node type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            edge type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">validate_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_ids: List[Optional[int]]</span>
<span class="sd">            Vector of edge type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_be_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_not_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_contain_identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not include the identity matrix.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_not_contain_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains zero weighted degree.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_have_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph has a maximal weighted</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_have_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have any node.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">must_be_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph is not connected.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not connected.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triangles ignoring the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the graph without taking into account weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the weighted graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns transitivity of the graph without taking into account weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_number_of_triangles_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of triangles in the graph without taking into account the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_clustering_coefficient_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns clustering coefficients for all nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_average_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph average clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_feature_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">include_central_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node features propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[Optional[List[float]]]</span>
<span class="sd">            The features to propagate. Use None to represent eventual unknown features.</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int]</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float]</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float]</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        include_central_node: Optional[bool]</span>
<span class="sd">            Whether to include the central node. By default true.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_label_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node label propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int]</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float]</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float]</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given edge ID is higher than</span>
<span class="sd">        the number of edges in the graph. Additionally, it will simply</span>
<span class="sd">        return None if there are no graph weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge whose edge weight is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given node IDs are higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the two given node IDs does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node id from given node name raising a panic if used unproperly.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type name whose edge type ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name</span>
<span class="sd">        raising panic if edge type ID does not exists in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            The edge type naIDme whose edge type name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges of the given edge type without checks.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The edge type to retrieve count of.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID without any checks for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            Edge Type of the edge.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs or edge type does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node type IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given edge ID does not exists in the</span>
<span class="sd">        current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the source of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the destination of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source and destination node IDs do</span>
<span class="sd">        not correspond to an edge in this graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs do not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_unique_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_id: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given source node ID does not exist in the current graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with unweighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has no nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with weighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph instance does not contain edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given node id is higher than the number of</span>
<span class="sd">        nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_reciprocal_sqrt_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the reciprocal squared root node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_reciprocal_sqrt_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the reciprocal squared root node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_reciprocal_sqrt_degrees_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with reciprocal squared root degree of the provided nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The vector of node IDs whose reciprocal squared root degree is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method makes the assumption that the provided node IDs exist in the graph, that is</span>
<span class="sd">         they are not higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_degree_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_top_k_central_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with top k central node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_type_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with vector of node types of given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID is greater than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have node types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node whose node type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        Even though the method will return an option when the node types are</span>
<span class="sd">         not available for the current graph, the behaviour is undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node whose node type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given edge ID is greater than</span>
<span class="sd">        the number of edges in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have edge types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            edge whose edge type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            edge whose edge type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will return an iterator of None values when the graph</span>
<span class="sd">         does not contain node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node types are not available for the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node types are to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the edge type of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose edge type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type name of given edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            Id of the edge type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose weight is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The node ID of the destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The node ID of the destination node.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The edge type ID of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: str</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst: str</span>
<span class="sd">            The node name of the destination node.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The edge type name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The node name of the destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose name is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str]</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_ids_from_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_names: List[Tuple[str, str]]</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_node_names_from_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_ids: List[Tuple[int, int]]</span>
<span class="sd">            The node names whose node names is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node IDs does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, the unknown edge type IDs</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            The edge type ID to count the edges of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID curresponding to given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The edge type name whose ID is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type name, the unknown edge types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The edge type name to count the edges of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_id_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID curresponding to given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type name whose ID is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int]</span>
<span class="sd">            The node type ID to count the nodes of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type name, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: Optional[str]</span>
<span class="sd">            The node type name to count the nodes of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_neighbour_node_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destination names for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node name whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            Edge Type of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            Destination node name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names and edge type name.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            Destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            Edge type name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_type_ids_from_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated edge types from string to internal edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_names: List[Optional[str]]</span>
<span class="sd">            Vector of edge types to be converted.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[str]]</span>
<span class="sd">            Vector of node types to be converted.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_multiple_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[List[str]]]</span>
<span class="sd">            Vector of node types to be converted.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node type names do not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source node ID is higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        There is no need for a unchecked version since we will have to map</span>
<span class="sd">        on the note_types anyway.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            Id of the node type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[int]</span>
<span class="sd">            Id of the node type.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will panic if the graph does not contain node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_connected_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is not a singleton nor a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_disconnected_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton or a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Nota that this method will raise a panic if caled with unproper</span>
<span class="sd">        parametrization.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            id of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            id of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            Name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge passing between given node ids exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node id.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node id.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_selfloop_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node ID has a selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Source node id.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge with the given type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The (optional) edge type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_unchecked_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        If the provided node_id is higher than the number of nodes in the graph,</span>
<span class="sd">        the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">is_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_node_name_and_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node name and node type name exist in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name.</span>
<span class="sd">        node_type_name: Optional[List[str]]</span>
<span class="sd">            The node types name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The destination node name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">has_edge_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge with type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The (optional) edge type name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_random_connected_graph</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_sampling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximum_node_sampling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_random_spanning_tree</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_circle_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new circle graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when circleing graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the circle. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the circle. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Circle&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_chain_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new chain graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_complete_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new complete graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when combining graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Complete&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_barbell_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">left_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">right_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">chain_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">left_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">right_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">chain_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new barbell graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        left_clique_nodes_number: Optional[int]</span>
<span class="sd">            Number of nodes in the left clique. By default 10.</span>
<span class="sd">        right_clique_nodes_number: Optional[int]</span>
<span class="sd">             Number of nodes in the right clique. By default equal to the left clique.</span>
<span class="sd">        chain_nodes_number: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        left_clique_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the left clique. By default None.</span>
<span class="sd">        right_clique_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the right clique. By default None.</span>
<span class="sd">        chain_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Barbell&#39;.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weights are provided only for a subset.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">are_nodes_remappable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether nodes are remappable to those of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            graph towards remap the nodes to.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remap_unchecked_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will cause a panic if the node IDs are either:</span>
<span class="sd">         * Not unique</span>
<span class="sd">         * Not available for each of the node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remap_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not available for all the values in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remap_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node names ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str]</span>
<span class="sd">            The node names to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not available for all the values in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remap_from_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return graph remapped towards nodes of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to remap towards.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">minimum_component_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">top_k_components</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;remove all the components that are not connected to interesting</span>
<span class="sd">        nodes and edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: Optional[List[str]]</span>
<span class="sd">            The name of the nodes of which components to keep.</span>
<span class="sd">        node_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The types of the nodes of which components to keep.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The types of the edges of which components to keep.</span>
<span class="sd">        minimum_component_size: Optional[int]</span>
<span class="sd">            Optional, Minimum size of the components to keep.</span>
<span class="sd">        top_k_components: Optional[int]</span>
<span class="sd">            Optional, number of components to keep sorted by number of nodes.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">edge_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace given node, node type and edge type names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The node names to replace.</span>
<span class="sd">        node_type_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The node type names to replace.</span>
<span class="sd">        edge_type_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The edge type names to replace.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names mapping would lead to nodes duplication.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns report relative to the graph metrics</span>
<span class="sd">        </span>
<span class="sd">        The report includes the following metrics by default:</span>
<span class="sd">        * Name of the graph</span>
<span class="sd">        * Whether the graph is directed or undirected</span>
<span class="sd">        * Number of singleton nodes</span>
<span class="sd">        * Number of nodes</span>
<span class="sd">        - If the graph has nodes, we also compute:</span>
<span class="sd">        * Minimum unweighted node degree</span>
<span class="sd">        * Maximum unweighted node degree</span>
<span class="sd">        * Unweighted node degree mean</span>
<span class="sd">        * Number of edges</span>
<span class="sd">        * Number of self-loops</span>
<span class="sd">        * Number of singleton with self-loops</span>
<span class="sd">        * Whether the graph is a multigraph</span>
<span class="sd">        * Number of parallel edges</span>
<span class="sd">        * Number of directed edges</span>
<span class="sd">        - If the graph has edges, we also compute:</span>
<span class="sd">        * Rate of self-loops</span>
<span class="sd">        * Whether the graph has weighted edges</span>
<span class="sd">        - If the graph has weights, we also compute:</span>
<span class="sd">        * Minimum weighted node degree</span>
<span class="sd">        * Maximum weighted node degree</span>
<span class="sd">        * Weighted node degree mean</span>
<span class="sd">        * The total edge weights</span>
<span class="sd">        * Whether the graph has node types</span>
<span class="sd">        - If the graph has node types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton node types</span>
<span class="sd">        * The number of node types</span>
<span class="sd">        * The number of nodes with unknown node types</span>
<span class="sd">        * The number of nodes with known node types</span>
<span class="sd">        * Whether the graph has edge types</span>
<span class="sd">        - If the graph has edge types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton edge types</span>
<span class="sd">        * The number of edge types</span>
<span class="sd">        * The number of edges with unknown edge types</span>
<span class="sd">        * The number of edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        On request, since it takes more time to compute it, the method also provides:&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">overlap_textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return rendered textual report about the graph overlaps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            graph to create overlap report with.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to shor the loading bars.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_report_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_report_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return html short textual report of the graph.</span>
<span class="sd">        </span>
<span class="sd">        TODO! Add reports on triangles</span>
<span class="sd">        TODO! Add reports on connected components</span>
<span class="sd">        TODO! Add reports on various node metrics</span>
<span class="sd">        TODO! Add reports on various edge metrics</span>
<span class="sd">        NOTE! Most of the above TODOs will require first to implement the</span>
<span class="sd">        support for the fast computation of the inbound edges in a directed</span>
<span class="sd">        graphs&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">add_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph with added in missing self-loops with given edge type and weight.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge type for the new selfloops is provided but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is provided but the graph does not have edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">set_inplace_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This happens INPLACE, that is edits the current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str</span>
<span class="sd">            The edge type to assing to all the edges.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">set_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str</span>
<span class="sd">            The edge type to assing to all the edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">set_inplace_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">set_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids_to_remove</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id_to_remove: int</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_ids_to_remove</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_inplace_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">sort_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by increasing outbound node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">sort_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by decreasing outbound node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">sort_by_node_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by lexicographic order&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_reversed_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting reversed map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">sort_by_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted using a BFS</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_sparse_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported sparse edge weighting methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported edge weighting methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">strongly_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of nodes of the various strongly connected components.</span>
<span class="sd">        </span>
<span class="sd">        This is an implementation of Tarjan algorithm.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">generate_new_edges_from_node_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">neighbours_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_degree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">distance_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with edges added extracted from given node_features.</span>
<span class="sd">        </span>
<span class="sd">        This operation might distrupt the graph topology.</span>
<span class="sd">        Proceed with caution!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[List[float]]</span>
<span class="sd">            node_features to use to identify the new neighbours.</span>
<span class="sd">        neighbours_number: Optional[int]</span>
<span class="sd">            Number of neighbours to add.</span>
<span class="sd">        max_degree: Optional[int]</span>
<span class="sd">            The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.</span>
<span class="sd">        distance_name: Optional[str]</span>
<span class="sd">            Name of distance to use. Can either be L2 or COSINE. By default COSINE.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bars.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node_features are not provided exactly for each node.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node_features do not have a consistent shape.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the provided number of neighbours is zero.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_directed_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert inplace the graph to directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new instance of the current graph as directed&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the upper triangular adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the lower triangular adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_main_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the main diagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_anti_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the anti-diagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_bidiagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the bidiagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_arrowhead</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the arrowhead adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_transposed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the transposed adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_complementary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the complementary graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph to the i-th transitivity closure iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with unweighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_weighted_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with weighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">random_spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">undesired_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns set of edges composing a spanning tree and connected components.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        The given random_state is NOT the root of the tree.</span>
<span class="sd">        </span>
<span class="sd">        This method, additionally, allows for undesired edge types to be</span>
<span class="sd">        used to build the spanning tree only in extremis when it is utterly</span>
<span class="sd">        necessary in order to complete the spanning arborescence.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        undesired_edge_types: Optional[Set[Optional[int]]]</span>
<span class="sd">            Which edge types id to try to avoid.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns consistent spanning arborescence using Kruskal.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Compute the connected components building in parallel a spanning tree using [bader&#39;s algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).</span>
<span class="sd">        </span>
<span class="sd">        **This works only for undirected graphs.**</span>
<span class="sd">        </span>
<span class="sd">        This method is **not thread save and not deterministic** but by design of the algorithm this</span>
<span class="sd">        shouldn&#39;t matter but if we will encounter non-detemristic bugs here is where we want to look.</span>
<span class="sd">        </span>
<span class="sd">        The returned quadruple contains:</span>
<span class="sd">        - Vector of the connected component for each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum connected component size.</span>
<span class="sd">        - Maximum connected component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given graph is directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the system configuration does not allow for the creation of the thread pool.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">approximated_vertex_cover_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns 2-approximated verted cover set using greedy algorithm.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">to_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Print the current graph in a format compatible with Graphviz dot&#39;s format&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">cooccurence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return cooccurence matrix-based triples of words, contexts and frequencies.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        window_size: int = 4</span>
<span class="sd">            Size of the window for local contexts.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        verbose: int = True</span>
<span class="sd">            whether to show or not the loading bar of the walks.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        Triple with integer vectors of words and contexts and max-min normalized frequencies.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">node2vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return training batches for Node2Vec models.</span>
<span class="sd">        </span>
<span class="sd">        The batch is composed of a tuple as the following:</span>
<span class="sd">        </span>
<span class="sd">        - (Contexts indices, central nodes indices): the tuple of nodes</span>
<span class="sd">        </span>
<span class="sd">        This does not provide any output value as the model uses NCE loss</span>
<span class="sd">        and basically the central nodes that are fed as inputs work as the</span>
<span class="sd">        outputs value.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        batch_size: int</span>
<span class="sd">            Number of walks to include within this batch.</span>
<span class="sd">            In some pathological cases, this might leed to an empty batch.</span>
<span class="sd">            These cases include graphs with particularly high number of traps.</span>
<span class="sd">            Consider using the method graph.report() to verify if this might</span>
<span class="sd">            apply to your use case.</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        window_size: int</span>
<span class="sd">            Size of the window for local contexts.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of iterations for each node.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        dense_node_mapping: Dict[int, int]</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        Tuple with vector of integer with contexts and words.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_node_label_prediction_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_central_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">max_neighbours</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return iterator over neighbours for the given node</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        `idx`: int - Seed for the batch.</span>
<span class="sd">        `batch_size`: Optional[int] = 1024 - The dimension of the batch.</span>
<span class="sd">        `include_central_node`: Optional[bool] - Whether to include the central node.</span>
<span class="sd">        `return_edge_weights`: Optional[bool] - Whether to return the edge weights.</span>
<span class="sd">        `max_neighbours`: Optional[int] - Maximal number of neighbours to sample.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        Tuple with input nodes, optionally edge weights and one-hot encoded node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_prediction_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">return_node_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_metrics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_sampling_attempts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">shuffle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Graph</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns n-ple with index to build numpy array, source node, source node type, destination node, destination node type, edge type and whether this edge is real or artificial.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        idx: int</span>
<span class="sd">            The index of the batch to generate, behaves like a random random_state,</span>
<span class="sd">        batch_size: Optional[int]</span>
<span class="sd">            The maximal size of the batch to generate,</span>
<span class="sd">        negative_samples: Optional[float]</span>
<span class="sd">            The component of netagetive samples to use.</span>
<span class="sd">        return_node_types: Optional[bool]</span>
<span class="sd">            Whether to return the source and destination nodes node types.</span>
<span class="sd">        return_edge_types: Optional[bool]</span>
<span class="sd">            Whether to return the edge types. The negative edges edge type will be samples at random.</span>
<span class="sd">        return_edge_metrics: Optional[bool]</span>
<span class="sd">            Whether to return the edge metrics.</span>
<span class="sd">        avoid_false_negatives: Optional[bool]</span>
<span class="sd">            Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.</span>
<span class="sd">        maximal_sampling_attempts: Optional[int]</span>
<span class="sd">            Number of attempts to execute to sample the negative edges.</span>
<span class="sd">        shuffle: Optional[bool]</span>
<span class="sd">            Whether to shuffle the samples within the batch.</span>
<span class="sd">        graph_to_avoid: Optional[Graph]</span>
<span class="sd">            The graph whose edges are to be avoided during the generation of false negatives,</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ---------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given amount of negative samples is not a positive finite real value.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If node types are requested but the graph does not contain any.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If node types are requested but the graph contains unknown node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types are requested but the graph does not contain any.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types are requested but the graph contains unknown edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_unchecked_edge_prediction_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destination_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all available edge prediction metrics for given edges.</span>
<span class="sd">        </span>
<span class="sd">        The metrics returned are, in order:</span>
<span class="sd">        - Adamic Adar index</span>
<span class="sd">        - Jaccard Coefficient</span>
<span class="sd">        - Resource Allocation index</span>
<span class="sd">        - Normalized preferential attachment score</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_ids: List[int]</span>
<span class="sd">            List of source node IDs.</span>
<span class="sd">        destination_node_ids: List[int]</span>
<span class="sd">            List of destination node IDs.</span>
<span class="sd">        normalize: Optional[bool] = True</span>
<span class="sd">            Whether to normalize the metrics.</span>
<span class="sd">        verbose: Optional[bool] = True</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array with metrics.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">get_edge_prediction_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all available edge prediction metrics for given edges.</span>
<span class="sd">        </span>
<span class="sd">        The metrics returned are, in order:</span>
<span class="sd">        - Adamic Adar index</span>
<span class="sd">        - Jaccard Coefficient</span>
<span class="sd">        - Resource Allocation index</span>
<span class="sd">        - Normalized preferential attachment score</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool] = True</span>
<span class="sd">            Whether to normalize the metrics.</span>
<span class="sd">        verbose: Optional[bool] = True</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array with metrics.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the main struct in Ensmallen, it allows to load and manipulate Graphs efficently.
You are not supposed to directly instantiate this struct but instead you should use the
static method <code><a href="#Graph.from_csv">from_csv</a></code>, which allows to load the graph from an edge-list.</p>

<p>To get information about a loaded graph, you can call the <code><a href="#Graph.textual_report">textual_report</a></code> method which
generates an human-readable HTML report.</p>

<p>By default we use EliasFano to store the Adjacency Matrix, this allows to save memory but
is slower than a CSR. For this reason you can use the <code><a href="#Graph.enable">enable</a></code> method to enable optimizzations
which speeds up the operations at the cost of more memory usage. You can check the memory usage
in bytes using <code><a href="#Graph.get_total_memory_used">get_total_memory_used</a></code> and you can get a detailed memory report of each data-structure
inside Graph using <code>memory_stats</code>.</p>

<p>You can pre-compute the memory needed (in bits) to store the adjacency matrix of a Graph with $|E|$ edges and $|V|$ nodes: 
$$2 |E| + |E| \left\lceil \log_2 \frac{|V|^2}{|E|} \right\rceil$$ </p>

<p>Most Graph properties are automatically cached to speed up.</p>
</div>


                            <div id="Graph.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Graph</span><span class="signature">()</span>
    </div>

        
    

                            </div>
                            <div id="Graph.dump_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.dump_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">dump_edges</span><span class="signature">(self, path: str, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">dump_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to disk the edges (and optionally the metadata) of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path where to save the edges and their metadata.</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar while writing to file.</span>
<span class="sd">        separator: str = &quot;\t&quot;</span>
<span class="sd">            What separator to use while writing out to file.</span>
<span class="sd">        header: bool = True</span>
<span class="sd">            Wether to write out the header of the file.</span>
<span class="sd">        sources_column_number: int = 0</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        sources_column: str = &quot;subject&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        destinations_column_number: int = 1</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        destinations_column: str = &quot;object&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        edge_types_column_number: int = 2</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        edges_type_column: str = &quot;label&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        weights_column_number: int = 3</span>
<span class="sd">            The column number where to write out the file.</span>
<span class="sd">        weights_column: str = &quot;weight&quot;</span>
<span class="sd">            The name of the column where to write out the file.</span>
<span class="sd">        numeric_node_ids: bool = False</span>
<span class="sd">            whether to save the internal numeric Ids instead of the string names.</span>
<span class="sd">        directed: bool = False</span>
<span class="sd">            whether to save graph as directed or undirected.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: update the set of exceptions&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Write to disk the edges (and optionally the metadata) of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>path</strong> (str):
Path where to save the edges and their metadata.</li>
<li><strong>verbose</strong> (bool = True):
Wether to show a loading bar while writing to file.</li>
<li><strong>separator</strong> (str = "      "):
What separator to use while writing out to file.</li>
<li><strong>header</strong> (bool = True):
Wether to write out the header of the file.</li>
<li><strong>sources_column_number</strong> (int = 0):
The column number where to write out the file.</li>
<li><strong>sources_column</strong> (str = "subject"):
The name of the column where to write out the file.</li>
<li><strong>destinations_column_number</strong> (int = 1):
The column number where to write out the file.</li>
<li><strong>destinations_column</strong> (str = "object"):
The name of the column where to write out the file.</li>
<li><strong>edge_types_column_number</strong> (int = 2):
The column number where to write out the file.</li>
<li><strong>edges_type_column</strong> (str = "label"):
The name of the column where to write out the file.</li>
<li><strong>weights_column_number</strong> (int = 3):
The column number where to write out the file.</li>
<li><strong>weights_column</strong> (str = "weight"):
The name of the column where to write out the file.</li>
<li><strong>numeric_node_ids</strong> (bool = False):
whether to save the internal numeric Ids instead of the string names.</li>
<li><strong>directed</strong> (bool = False):
whether to save graph as directed or undirected.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TODO</strong> (update the set of exceptions):</li>
</ul>
</div>


                            </div>
                            <div id="Graph.hash" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.hash">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">hash</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a 64-bit hash of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a 64-bit hash of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_laplacian_coo_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_laplacian_coo_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_laplacian_coo_matrix</span><span class="signature">(self) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tuple with edge node IDs and edge weights.</p>
</div>


                            </div>
                            <div id="Graph.get_random_walk_normalized_laplacian_coo_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_random_walk_normalized_laplacian_coo_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_random_walk_normalized_laplacian_coo_matrix</span><span class="signature">(self) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_random_walk_normalized_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tuple with edge node IDs and edge weights.</p>
</div>


                            </div>
                            <div id="Graph.get_symmetric_normalized_laplacian_coo_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_symmetric_normalized_laplacian_coo_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_symmetric_normalized_laplacian_coo_matrix</span><span class="signature">(self) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_laplacian_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tuple with edge node IDs and edge weights.</p>
</div>


                            </div>
                            <div id="Graph.get_symmetric_normalized_coo_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_symmetric_normalized_coo_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_symmetric_normalized_coo_matrix</span><span class="signature">(self) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_coo_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with edge node IDs and edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tuple with edge node IDs and edge weights.</p>
</div>


                            </div>
                            <div id="Graph.dump_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.dump_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">dump_nodes</span><span class="signature">(self, path: str, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">dump_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to disk the nodes (and optionally the metadata) of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path where to save the nodes and their metadata.</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar while writing to file.</span>
<span class="sd">        separator: str = &quot;\t&quot;</span>
<span class="sd">            What separator to use while writing out to file.</span>
<span class="sd">        header: bool = True</span>
<span class="sd">            Wether to write out the header of the file.</span>
<span class="sd">        nodes_column_number: int = 0</span>
<span class="sd">            The column number where to write the nodes.</span>
<span class="sd">        nodes_column: str = &quot;id&quot;</span>
<span class="sd">            The name of the column of the nodes.</span>
<span class="sd">        node_types_column_number: int = 1</span>
<span class="sd">            The column number where to write the node types.</span>
<span class="sd">        nodes_type_column: str = &quot;category&quot;</span>
<span class="sd">            The name of the column of the node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: update the set of exceptions&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Write to disk the nodes (and optionally the metadata) of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>path</strong> (str):
Path where to save the nodes and their metadata.</li>
<li><strong>verbose</strong> (bool = True):
Wether to show a loading bar while writing to file.</li>
<li><strong>separator</strong> (str = "      "):
What separator to use while writing out to file.</li>
<li><strong>header</strong> (bool = True):
Wether to write out the header of the file.</li>
<li><strong>nodes_column_number</strong> (int = 0):
The column number where to write the nodes.</li>
<li><strong>nodes_column</strong> (str = "id"):
The name of the column of the nodes.</li>
<li><strong>node_types_column_number</strong> (int = 1):
The column number where to write the node types.</li>
<li><strong>nodes_type_column</strong> (str = "category"):
The name of the column of the node types.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TODO</strong> (update the set of exceptions):</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_subgraphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_subgraphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_subgraphs</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    root_node: Union[int, NoneType],
    node_sampling_method: str,
    edge_weighting_methods: List[str],
    add_selfloops_where_missing: Union[bool, NoneType],
    unique: Union[bool, NoneType]
) -&gt; Tuple[numpy.ndarray, List[numpy.ndarray]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            the number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes according to the given method and parameters.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
the number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>root_node</strong> (Optional[int]):
The (optional) root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
<li><strong>edge_weighting_methods</strong> (List[str]):
The edge weighting methods to use to compute the adjacency matrix.</li>
<li><strong>add_selfloops_where_missing</strong> (Optional[bool]):
Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</li>
<li><strong>unique</strong> (Optional[bool] = True):
Whether to reduce the sampled nodes to a unique set.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node sampling method is not supported.</li>
<li><strong>ValueError</strong>: If any of the given subgraph edge weighting method is not supported.</li>
<li><strong>ValueError</strong>: If the list of requested edge weighting methods is empty.</li>
<li><strong>ValueError</strong>: If the <code>add_selfloops_where_missing</code> parameter is provided, but the edge weighting method is not laplacian.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_ids_from_node_ids</span><span class="signature">(
    self,
    node_ids: List[int],
    add_selfloops_where_missing: Union[bool, NoneType],
    complete: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">complete</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled edges connected to the given node Ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        node_ids: Vec&lt;NodeT&gt;</span>
<span class="sd">            List of nodes whose edges are to return.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        complete: Optional[bool] = True</span>
<span class="sd">            Whether to return the edges in both directions (when dealing with an undirected graph).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled edges connected to the given node Ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids</strong> (Vec<NodeT>):
List of nodes whose edges are to return.</li>
<li><strong>add_selfloops_where_missing</strong> (Optional[bool]):
Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</li>
<li><strong>complete</strong> (Optional[bool] = True):
Whether to return the edges in both directions (when dealing with an undirected graph).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_sparse_subgraphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_sparse_subgraphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sparse_subgraphs</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    root_node: Union[int, NoneType],
    node_sampling_method: str,
    edge_weighting_methods: List[str],
    add_selfloops_where_missing: Union[bool, NoneType],
    unique: Union[bool, NoneType]
) -&gt; Tuple[numpy.ndarray, List[Tuple[numpy.ndarray, numpy.ndarray]]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sparse_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes according to the given method and parameters.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>root_node</strong> (Optional[int]):
The (optional) root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
<li><strong>edge_weighting_methods</strong> (List[str]):
The edge weighting methods to use to compute the adjacency matrix.</li>
<li><strong>add_selfloops_where_missing</strong> (Optional[bool]):
Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</li>
<li><strong>unique</strong> (Optional[bool] = True):
Whether to reduce the sampled nodes to a unique set.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node sampling method is not supported.</li>
<li><strong>ValueError</strong>: If any of the given subgraph edge weighting method is not supported.</li>
<li><strong>ValueError</strong>: If the list of requested edge weighting methods is empty.</li>
<li><strong>ValueError</strong>: If the <code>add_selfloops_where_missing</code> parameter is provided, but the edge weighting method is not laplacian.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_sparse_undirected_laplacian_subgraphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_sparse_undirected_laplacian_subgraphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sparse_undirected_laplacian_subgraphs</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    root_node: Union[int, NoneType],
    node_sampling_method: str
) -&gt; Tuple[numpy.ndarray, List[Tuple[numpy.ndarray, numpy.ndarray]]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sparse_undirected_laplacian_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes and edges using laplacian assuming undirected graph with selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        TODO: Update</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes and edges using laplacian assuming undirected graph with selfloops.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>root_node</strong> (Optional[int]):
The (optional) root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TODO</strong> (Update):</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_prediction_subgraphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_prediction_subgraphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_prediction_subgraphs</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    node_sampling_method: str,
    edge_weighting_methods: List[str],
    add_selfloops_where_missing: Union[bool, NoneType]
) -&gt; Tuple[numpy.ndarray, List[numpy.ndarray], numpy.ndarray, List[numpy.ndarray], numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_prediction_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        --------------------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes according to the given method and parameters.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
<li><strong>edge_weighting_methods</strong> (List[str]):
The edge weighting methods to use to compute the adjacency matrix.</li>
<li><strong>add_selfloops_where_missing</strong> (Optional[bool]):
Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node sampling method is not supported.</li>
<li><strong>ValueError</strong>: If any of the given subgraph edge weighting method is not supported.</li>
<li><strong>ValueError</strong>: If the list of requested edge weighting methods is empty.</li>
<li><strong>ValueError</strong>: If the <code>add_selfloops_where_missing</code> parameter is provided, but the edge weighting method is not laplacian.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_prediction_subgraphs_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_prediction_subgraphs_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_prediction_subgraphs_from_node_ids</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    source_root_node: int,
    destination_root_node: int,
    node_sampling_method: str,
    edge_weighting_methods: List[str],
    add_selfloops_where_missing: Union[bool, NoneType],
    unique: Union[bool, NoneType]
) -&gt; Tuple[numpy.ndarray, List[numpy.ndarray], numpy.ndarray, List[numpy.ndarray], bool]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_prediction_subgraphs_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">source_root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_weighting_methods</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_selfloops_where_missing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">bool</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        source_root_node: int</span>
<span class="sd">            The source root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        destination_root_node: int</span>
<span class="sd">            The destination root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        edge_weighting_methods: List[str]</span>
<span class="sd">            The edge weighting methods to use to compute the adjacency matrix.</span>
<span class="sd">        add_selfloops_where_missing: Optional[bool]</span>
<span class="sd">            Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</span>
<span class="sd">        unique: Optional[bool] = True</span>
<span class="sd">            Whether to reduce the sampled nodes to a unique set.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given subgraph edge weighting method is not supported.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the list of requested edge weighting methods is empty.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple with the sampled nodes and the computed kernels.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes according to the given method and parameters.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>source_root_node</strong> (int):
The source root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>destination_root_node</strong> (int):
The destination root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
<li><strong>edge_weighting_methods</strong> (List[str]):
The edge weighting methods to use to compute the adjacency matrix.</li>
<li><strong>add_selfloops_where_missing</strong> (Optional[bool]):
Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.</li>
<li><strong>unique</strong> (Optional[bool] = True):
Whether to reduce the sampled nodes to a unique set.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node sampling method is not supported.</li>
<li><strong>ValueError</strong>: If any of the given subgraph edge weighting method is not supported.</li>
<li><strong>ValueError</strong>: If the list of requested edge weighting methods is empty.</li>
<li><strong>ValueError</strong>: If the <code>add_selfloops_where_missing</code> parameter is provided, but the edge weighting method is not laplacian.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with the sampled nodes and the computed kernels.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.spanning_arborescence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.spanning_arborescence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">spanning_arborescence</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">spanning_arborescence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns set of edges forming the spanning tree of given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: bool = True</span>
<span class="sd">            Wether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given graph is not undirected.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Numpy array of tuples of NodeIds forming the spanning tree.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        This is the implementaiton of the algorithm presented in the paper</span>
<span class="sd">        A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors</span>
<span class="sd">        by David A. Bader and Guojing Cong.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns set of edges forming the spanning tree of given graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (bool = True):
Wether to show a loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given graph is not undirected.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Numpy array of tuples of NodeIds forming the spanning tree.</strong></li>
</ul>

<h6 id="references">References</h6>

<p>This is the implementaiton of the algorithm presented in the paper
A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors
by David A. Bader and Guojing Cong.</p>
</div>


                            </div>
                            <div id="Graph.random_walks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.random_walks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">random_walks</span><span class="signature">(self, walk_length: int, quantity: int, **kwargs) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">random_walks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return random walks done on the graph using Rust.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        quantity: int</span>
<span class="sd">            Number of nodes to sample.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: Update raises</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of list of walks containing the numeric IDs of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return random walks done on the graph using Rust.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>walk_length</strong> (int):
Maximal length of the random walk.
On graphs without traps, all walks have this length.</li>
<li><strong>quantity</strong> (int):
Number of nodes to sample.</li>
<li><strong>return_weight</strong> (float = 1.0):
Weight on the probability of returning to node coming from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>random_state</strong> (int = 42):
random_state to use to reproduce the walks.</li>
<li><strong>iterations</strong> (int = 1):
Number of cycles on the graphs to execute.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method available from graph
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>max_neighbours</strong> (int = None):
Maximum number of randomly sampled neighbours to consider.
If this parameter is used, the walks becomes probabilistic in nature
and becomes an approximation of an exact walk.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TODO</strong> (Update raises):</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>List of list of walks containing the numeric IDs of nodes.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.complete_walks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.complete_walks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">complete_walks</span><span class="signature">(self, walk_length: int, **kwargs) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">complete_walks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return complete random walks done on the graph using Rust.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TODO: Update raises</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of list of walks containing the numeric IDs of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return complete random walks done on the graph using Rust.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>walk_length</strong> (int):
Maximal length of the random walk.
On graphs without traps, all walks have this length.</li>
<li><strong>return_weight</strong> (float = 1.0):
Weight on the probability of returning to node coming from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>random_state</strong> (int = 42):
random_state to use to reproduce the walks.</li>
<li><strong>iterations</strong> (int = 1):
Number of cycles on the graphs to execute.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method available from graph
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>max_neighbours</strong> (int = None):
Maximum number of randomly sampled neighbours to consider.
If this parameter is used, the walks becomes probabilistic in nature
and becomes an approximation of an exact walk.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TODO</strong> (Update raises):</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>List of list of walks containing the numeric IDs of nodes.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_degree_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_degree_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_degree_centrality</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of unweighted degree centrality for all nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of unweighted degree centrality for all nodes</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_degree_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_degree_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_degree_centrality</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of weighted degree centrality for all nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of weighted degree centrality for all nodes</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_closeness_centrality_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_closeness_centrality_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_closeness_centrality_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return closeness centrality of the requested node.</p>

<p>If the given node ID does not exist in the current graph the method
will panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose closeness centrality is to be computed.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show an indicative progress bar.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_closeness_centrality_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_closeness_centrality_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_closeness_centrality_from_node_id</span><span class="signature">(self, node_id: int, use_edge_weights_as_probabilities: bool) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return closeness centrality of the requested node.</p>

<p>If the given node ID does not exist in the current graph the method
will panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose closeness centrality is to be computed.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (bool):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_closeness_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_closeness_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_closeness_centrality</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return closeness centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show an indicative progress bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_closeness_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_closeness_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_closeness_centrality</span><span class="signature">(
    self,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return closeness centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>use_edge_weights_as_probabilities</strong> (bool):
Whether to treat the edge weights as probabilities.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show an indicative progress bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
<li><strong>ValueError</strong>: If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_harmonic_centrality_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_harmonic_centrality_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_harmonic_centrality_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return harmonic centrality of the requested node.</p>

<p>If the given node ID does not exist in the current graph the method
will panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose harmonic centrality is to be computed.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_harmonic_centrality_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_harmonic_centrality_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_harmonic_centrality_from_node_id</span><span class="signature">(self, node_id: int, use_edge_weights_as_probabilities: bool) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return harmonic centrality of the requested node.</p>

<p>If the given node ID does not exist in the current graph the method
will panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose harmonic centrality is to be computed.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (bool):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_harmonic_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_harmonic_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_harmonic_centrality</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return harmonic centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show an indicative progress bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_harmonic_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_harmonic_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_harmonic_centrality</span><span class="signature">(
    self,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return harmonic centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show an indicative progress bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_stress_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_stress_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_stress_centrality</span><span class="signature">(
    self,
    normalize: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_stress_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of stress centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of stress centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>normalize</strong> (Optional[bool]):
Whether to normalize the values. By default, it is false.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar. By default, it is true.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_betweenness_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_betweenness_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_betweenness_centrality</span><span class="signature">(
    self,
    normalize: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_betweenness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of betweenness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of betweenness centrality for all nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>normalize</strong> (Optional[bool]):
Whether to normalize the values. By default, it is false.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar. By default, it is true.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_eigenvector_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_eigenvector_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_eigenvector_centrality</span><span class="signature">(
    self,
    maximum_iterations_number: Union[int, NoneType],
    tollerance: Union[float, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int]</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float]</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector with unweighted eigenvector centrality.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>maximum_iterations_number</strong> (Optional[int]):
The maximum number of iterations to consider.</li>
<li><strong>tollerance</strong> (Optional[float]):
The maximum error tollerance for convergence.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_eigenvector_centrality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_eigenvector_centrality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_eigenvector_centrality</span><span class="signature">(
    self,
    maximum_iterations_number: Union[int, NoneType],
    tollerance: Union[float, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int]</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float]</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector with unweighted eigenvector centrality.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>maximum_iterations_number</strong> (Optional[int]):
The maximum number of iterations to consider.</li>
<li><strong>tollerance</strong> (Optional[float]):
The maximum error tollerance for convergence.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.encode_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.encode_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">encode_edge</span><span class="signature">(self, src: int, dst: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">encode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge value corresponding to given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge value corresponding to given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The source node ID.</li>
<li><strong>dst</strong> (int):
The destination node ID.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.decode_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.decode_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">decode_edge</span><span class="signature">(self, edge: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">decode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns source and destination nodes corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge: int</span>
<span class="sd">            The edge value to decode.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns source and destination nodes corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge</strong> (int):
The edge value to decode.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_max_encodable_edge_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_max_encodable_edge_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_max_encodable_edge_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_max_encodable_edge_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return maximum encodable edge number&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return maximum encodable edge number</p>
</div>


                            </div>
                            <div id="Graph.get_dense_binary_adjacency_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_dense_binary_adjacency_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dense_binary_adjacency_matrix</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_dense_binary_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns binary dense adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns binary dense adjacency matrix.</p>

<p>Beware of using this method on big graphs!
It'll use all of your RAM!</p>
</div>


                            </div>
                            <div id="Graph.get_dense_weighted_adjacency_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_dense_weighted_adjacency_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dense_weighted_adjacency_matrix</span><span class="signature">(self, weight: Union[float, NoneType]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_dense_weighted_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns binary weighted adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight value to use for absent edges. By default, `0.0`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns binary weighted adjacency matrix.</p>

<p>Beware of using this method on big graphs!
It'll use all of your RAM!</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>weight</strong> (Optional[float]):
The weight value to use for absent edges. By default, <code>0.0</code>.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_breadth_first_search_predecessors_parallel_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_breadth_first_search_predecessors_parallel_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_breadth_first_search_predecessors_parallel_from_node_id</span><span class="signature">(
    self,
    src_node_id: int
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_predecessors_parallel_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns shortest path result for the BFS from given source node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Root of the tree of minimum paths.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node ID does not exist in the graph the method will panic.</p>

<p>TODO! Explore chains accelerations!</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_breadth_first_search_distances_parallel_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_breadth_first_search_distances_parallel_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_breadth_first_search_distances_parallel_from_node_id</span><span class="signature">(
    self,
    src_node_id: int
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_distances_parallel_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns shortest path result for the BFS from given source node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Root of the tree of minimum paths.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node ID does not exist in the graph the method will panic.</p>

<p>TODO! Explore chains accelerations!</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_breadth_first_search_distances_sequential_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_breadth_first_search_distances_sequential_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_breadth_first_search_distances_sequential_from_node_id</span><span class="signature">(
    self,
    src_node_id: int
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_distances_sequential_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns shortest path result for the BFS from given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node ID does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns shortest path result for the BFS from given source node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Root of the tree of minimum paths.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node ID does not exist in the graph the method will panic.</p>

<p>TODO! Explore chains accelerations!</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_breadth_first_search_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_breadth_first_search_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_breadth_first_search_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: Union[int, NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Root of the tree of minimum paths.</li>
<li><strong>maybe_dst_node_id</strong> (Optional[int]):
Optional target destination. If provided, Dijkstra will stop upon reaching this node.</li>
<li><strong>compute_predecessors</strong> (Optional[bool]):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the DFS for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>

<p>TODO! Explore chains accelerations!</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_shortest_path_node_ids_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    maximal_depth: Union[int, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node is a selfloop.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there is no path between the two given nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node IDs and distance from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node is a selfloop.</li>
<li><strong>ValueError</strong>: If there is no path between the two given nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_shortest_path_node_names_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_shortest_path_node_names_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_shortest_path_node_names_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    maximal_depth: Union[int, NoneType]
) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_shortest_path_node_ids_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    maximal_depth: Union[int, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node IDs do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_shortest_path_node_ids_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_shortest_path_node_ids_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_shortest_path_node_ids_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    maximal_depth: Union[int, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_shortest_path_node_names_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_shortest_path_node_names_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_shortest_path_node_names_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    maximal_depth: Union[int, NoneType]
) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_k_shortest_path_node_ids_from_node_ids</span><span class="signature">(self, src_node_id: int, dst_node_id: int, k: int) -&gt; List[List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the k minimum paths node IDs between given source node and destination node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>k</strong> (int):
Number of paths to find.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_k_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_k_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_k_shortest_path_node_ids_from_node_ids</span><span class="signature">(self, src_node_id: int, dst_node_id: int, k: int) -&gt; List[List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the k minimum paths node IDs between given source node and destination node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the BFS for.</li>
<li><strong>k</strong> (int):
Number of paths to find.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node IDs does not exist in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_k_shortest_path_node_ids_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_k_shortest_path_node_ids_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_k_shortest_path_node_ids_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    k: int
) -&gt; List[List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the k minimum paths node IDs between given source node and destination node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>k</strong> (int):
Number of paths to find.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names does not exist in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_k_shortest_path_node_names_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_k_shortest_path_node_names_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_k_shortest_path_node_names_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    k: int
) -&gt; List[List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node names between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the k minimum paths node names between given source node and destination node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>k</strong> (int):
Number of paths to find.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names does not exist in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_eccentricity_and_most_distant_node_id_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_eccentricity_and_most_distant_node_id_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_eccentricity_and_most_distant_node_id_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_eccentricity_and_most_distant_node_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted eccentricity of the given node.</p>

<p>This method will panic if the given node ID does not exists in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Node for which to compute the eccentricity.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_eccentricity_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_eccentricity_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_eccentricity_from_node_id</span><span class="signature">(
    self,
    node_id: int,
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weighted eccentricity of the given node.</p>

<p>This method will panic if the given node ID does not exists in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Node for which to compute the eccentricity.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_eccentricity_and_most_distant_node_id_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_eccentricity_and_most_distant_node_id_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_eccentricity_and_most_distant_node_id_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_eccentricity_and_most_distant_node_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted eccentricity of the given node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Node for which to compute the eccentricity.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node ID does not exist in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_eccentricity_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_eccentricity_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_eccentricity_from_node_id</span><span class="signature">(
    self,
    node_id: int,
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weighted eccentricity of the given node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Node for which to compute the eccentricity.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node ID does not exist in the graph.</li>
<li><strong>ValueError</strong>: If weights are requested to be treated as probabilities but are not between 0 and 1.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_eccentricity_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_eccentricity_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_eccentricity_from_node_name</span><span class="signature">(self, node_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted eccentricity of the given node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Node for which to compute the eccentricity.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node name does not exist in the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_eccentricity_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_eccentricity_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_eccentricity_from_node_name</span><span class="signature">(
    self,
    node_name: str,
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weighted eccentricity of the given node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Node for which to compute the eccentricity.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node name does not exist in the graph.</li>
<li><strong>ValueError</strong>: If weights are requested to be treated as probabilities but are not between 0 and 1.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_dijkstra_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_dijkstra_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_dijkstra_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    maybe_dst_node_id: Union[int, NoneType],
    maybe_dst_node_ids: Union[List[int], NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType],
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsDjkstra">grape.ensmallen.ensmallen.ShortestPathsDjkstra</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]]</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: bool</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Root of the tree of minimum paths.</li>
<li><strong>maybe_dst_node_id</strong> (Optional[int]):
Optional target destination. If provided, Dijkstra will stop upon reaching this node.</li>
<li><strong>maybe_dst_node_ids</strong> (Optional[List[int]]):
Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</li>
<li><strong>compute_predecessors</strong> (bool):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; Tuple[float, List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node IDs and distance from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_shortest_path_node_names_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; Tuple[float, List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_shortest_path_node_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_shortest_path_node_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_shortest_path_node_ids_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: int,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; Tuple[float, List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Source node ID.</li>
<li><strong>dst_node_id</strong> (int):
Destination node ID.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node IDs do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_shortest_path_node_ids_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_shortest_path_node_ids_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_shortest_path_node_ids_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; Tuple[float, List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_shortest_path_node_names_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_shortest_path_node_names_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_shortest_path_node_names_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: str,
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; Tuple[float, List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum path node names from given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Source node name.</li>
<li><strong>dst_node_name</strong> (str):
Destination node name.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute Dijkstra for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_breadth_first_search_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_breadth_first_search_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_breadth_first_search_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    dst_node_id: Union[int, NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal number of iterations to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Node ID root of the tree of minimum paths.</li>
<li><strong>compute_predecessors</strong> (Optional[bool]):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal number of iterations to execute the DFS for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given source node ID does not exist in the current graph.</li>
<li><strong>ValueError</strong>: If the given optional destination node ID does not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_dijkstra_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_dijkstra_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dijkstra_from_node_ids</span><span class="signature">(
    self,
    src_node_id: int,
    maybe_dst_node_id: Union[int, NoneType],
    maybe_dst_node_ids: Union[List[int], NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType],
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsDjkstra">grape.ensmallen.ensmallen.ShortestPathsDjkstra</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int]</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]]</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_id</strong> (int):
Node ID root of the tree of minimum paths.</li>
<li><strong>maybe_dst_node_id</strong> (Optional[int]):
Optional target destination. If provided, Dijkstra will stop upon reaching this node.</li>
<li><strong>maybe_dst_node_ids</strong> (Optional[List[int]]):
Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</li>
<li><strong>compute_predecessors</strong> (Optional[bool]):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the DFS for.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the weights are to be used and the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the given source node ID does not exist in the current graph.</li>
<li><strong>ValueError</strong>: If the given optional destination node ID does not exist in the current graph.</li>
<li><strong>ValueError</strong>: If weights are requested to be treated as probabilities but are not between 0 and 1.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_diameter_naive" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_diameter_naive">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_diameter_naive</span><span class="signature">(
    self,
    ignore_infinity: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns diameter of the graph using naive method.</p>

<p>Note that there exists the non-naive method for undirected graphs
and it is possible to implement a faster method for directed graphs
but we still need to get to it, as it will require an updated
succinct data structure.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ignore_infinity</strong> (Optional[bool]):
Whether to ignore infinite distances, which are present when in the graph exist multiple components.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_diameter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_diameter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_diameter</span><span class="signature">(
    self,
    ignore_infinity: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns diameter of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ignore_infinity</strong> (Optional[bool]):
Whether to ignore infinite distances, which are present when in the graph exist multiple components.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_diameter_naive" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_diameter_naive">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_diameter_naive</span><span class="signature">(
    self,
    ignore_infinity: Union[bool, NoneType],
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool]</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns diameter of the graph using naive method.</p>

<p>Note that there exists the non-naive method for undirected graphs
and it is possible to implement a faster method for directed graphs
but we still need to get to it, as it will require an updated
succinct data structure.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ignore_infinity</strong> (Optional[bool]):
Whether to ignore infinite distances, which are present when in the graph exist multiple components.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain nodes.</li>
<li><strong>ValueError</strong>: If the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
<li><strong>ValueError</strong>: If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_breadth_first_search_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_breadth_first_search_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_breadth_first_search_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    dst_node_name: Union[str, NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsResultBFS">grape.ensmallen.ensmallen.ShortestPathsResultBFS</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsResultBFS</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        dst_node_name: Optional[str]</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Node name root of the tree of minimum paths.</li>
<li><strong>dst_node_name</strong> (Optional[str]):
Destination node name.</li>
<li><strong>compute_predecessors</strong> (Optional[bool]):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the DFS for.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the weights are to be used and the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the given source node name does not exist in the current graph.</li>
<li><strong>ValueError</strong>: If the given optional destination node name does not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_dijkstra_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_dijkstra_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dijkstra_from_node_names</span><span class="signature">(
    self,
    src_node_name: str,
    maybe_dst_node_name: Union[str, NoneType],
    maybe_dst_node_names: Union[List[str], NoneType],
    compute_predecessors: Union[bool, NoneType],
    maximal_depth: Union[int, NoneType],
    use_edge_weights_as_probabilities: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.ShortestPathsDjkstra">grape.ensmallen.ensmallen.ShortestPathsDjkstra</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maybe_dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">maybe_dst_node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ShortestPathsDjkstra</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_name: Optional[str]</span>
<span class="sd">            Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_names: Optional[List[str]]</span>
<span class="sd">            Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool]</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int]</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_node_name</strong> (str):
Node name root of the tree of minimum paths.</li>
<li><strong>maybe_dst_node_name</strong> (Optional[str]):
Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.</li>
<li><strong>maybe_dst_node_names</strong> (Optional[List[str]]):
Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.</li>
<li><strong>compute_predecessors</strong> (Optional[bool]):
Whether to compute the vector of predecessors.</li>
<li><strong>maximal_depth</strong> (Optional[int]):
The maximal depth to execute the DFS for.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the weights are to be used and the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the given source node name does not exist in the current graph.</li>
<li><strong>ValueError</strong>: If the given optional destination node name does not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_bipartite_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_bipartite_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_bipartite_edges</span><span class="signature">(
    self,
    removed_existing_edges: Union[bool, NoneType],
    first_nodes_set: Union[Set[str], NoneType],
    second_nodes_set: Union[Set[str], NoneType],
    first_node_types_set: Union[Set[str], NoneType],
    second_node_types_set: Union[Set[str], NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_bipartite_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>first_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the first set of nodes of the graph.</li>
<li><strong>second_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the second set of nodes of the graph.</li>
<li><strong>first_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the first set of nodes of the graph.</li>
<li><strong>second_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the second set of nodes of the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_bipartite_edge_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_bipartite_edge_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_bipartite_edge_names</span><span class="signature">(
    self,
    removed_existing_edges: Union[bool, NoneType],
    first_nodes_set: Union[Set[str], NoneType],
    second_nodes_set: Union[Set[str], NoneType],
    first_node_types_set: Union[Set[str], NoneType],
    second_node_types_set: Union[Set[str], NoneType]
) -&gt; List[List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_bipartite_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>first_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the first set of nodes of the graph.</li>
<li><strong>second_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the second set of nodes of the graph.</li>
<li><strong>first_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the first set of nodes of the graph.</li>
<li><strong>second_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the second set of nodes of the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_star_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_star_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_star_edges</span><span class="signature">(
    self,
    central_node: str,
    removed_existing_edges: Union[bool, NoneType],
    star_points_nodes_set: Union[Set[str], NoneType],
    star_points_node_types_set: Union[Set[str], NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_star_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node IDs that form the edges of the required star.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>central_node</strong> (str):
Name of the node to use as center of the star.</li>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>star_points_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the set of star points.</li>
<li><strong>star_points_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the set of star points.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_star_edge_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_star_edge_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_star_edge_names</span><span class="signature">(
    self,
    central_node: str,
    removed_existing_edges: Union[bool, NoneType],
    star_points_nodes_set: Union[Set[str], NoneType],
    star_points_node_types_set: Union[Set[str], NoneType]
) -&gt; List[List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_star_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]]</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node names that form the edges of the required star.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>central_node</strong> (str):
Name of the node to use as center of the star.</li>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>star_points_nodes_set</strong> (Optional[Set[str]]):
Optional set of nodes to use to create the set of star points.</li>
<li><strong>star_points_node_types_set</strong> (Optional[Set[str]]):
Optional set of node types to create the set of star points.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_clique_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_clique_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_clique_edges</span><span class="signature">(
    self,
    directed: Union[bool, NoneType],
    allow_selfloops: Union[bool, NoneType],
    removed_existing_edges: Union[bool, NoneType],
    allow_node_type_set: Union[Set[str], NoneType],
    allow_node_set: Union[Set[str], NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_clique_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool]</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]]</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]]</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node IDs that form the edges of the required clique.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (Optional[bool]):
Whether to return the edges as directed or undirected. By default, equal to the graph.</li>
<li><strong>allow_selfloops</strong> (Optional[bool]):
Whether to allow self-loops in the clique. By default, equal to the graph.</li>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>allow_node_type_set</strong> (Optional[Set[str]]):
Node types to include in the clique.</li>
<li><strong>allow_node_set</strong> (Optional[Set[str]]):
Nodes to include i the clique.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_clique_edge_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_clique_edge_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_clique_edge_names</span><span class="signature">(
    self,
    directed: Union[bool, NoneType],
    allow_selfloops: Union[bool, NoneType],
    removed_existing_edges: Union[bool, NoneType],
    allow_node_type_set: Union[Set[str], NoneType],
    allow_node_set: Union[Set[str], NoneType]
) -&gt; List[List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_clique_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool]</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]]</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]]</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of tuple of Node names that form the edges of the required clique.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (Optional[bool]):
Whether to return the edges as directed or undirected. By default, equal to the graph.</li>
<li><strong>allow_selfloops</strong> (Optional[bool]):
Whether to allow self-loops in the clique. By default, equal to the graph.</li>
<li><strong>removed_existing_edges</strong> (Optional[bool]):
Whether to filter out the existing edges. By default, true.</li>
<li><strong>allow_node_type_set</strong> (Optional[Set[str]]):
Node types to include in the clique.</li>
<li><strong>allow_node_set</strong> (Optional[Set[str]]):
Nodes to include i the clique.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_minimum_preferential_attachment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_minimum_preferential_attachment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_minimum_preferential_attachment</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the minumum unweighted preferential attachment score.</p>

<h6 id="safety">Safety</h6>

<p>If the graph does not contain nodes, the return value will be undefined.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_maximum_preferential_attachment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_maximum_preferential_attachment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_maximum_preferential_attachment</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the maximum unweighted preferential attachment score.</p>

<h6 id="safety">Safety</h6>

<p>If the graph does not contain nodes, the return value will be undefined.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_minimum_preferential_attachment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_minimum_preferential_attachment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_minimum_preferential_attachment</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the minumum weighted preferential attachment score.</p>

<h6 id="safety">Safety</h6>

<p>If the graph does not contain nodes, the return value will be undefined.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_maximum_preferential_attachment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_maximum_preferential_attachment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_maximum_preferential_attachment</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the maximum weighted preferential attachment score.</p>

<h6 id="safety">Safety</h6>

<p>If the graph does not contain nodes, the return value will be undefined.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_preferential_attachment_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_preferential_attachment_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_preferential_attachment_from_node_ids</span><span class="signature">(
    self,
    source_node_id: int,
    destination_node_id: int,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted preferential attachment from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize within 0 to 1.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_preferential_attachment_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_preferential_attachment_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_preferential_attachment_from_node_ids</span><span class="signature">(
    self,
    source_node_id: int,
    destination_node_id: int,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted preferential attachment from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize by the square of maximum degree.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_preferential_attachment_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_preferential_attachment_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_preferential_attachment_from_node_names</span><span class="signature">(
    self,
    first_node_name: str,
    second_node_name: str,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted preferential attachment from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize by the square of maximum degree.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_preferential_attachment_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_preferential_attachment_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_preferential_attachment_from_node_ids</span><span class="signature">(
    self,
    source_node_id: int,
    destination_node_id: int,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted preferential attachment from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize within 0 to 1.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_preferential_attachment_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_preferential_attachment_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_preferential_attachment_from_node_ids</span><span class="signature">(
    self,
    source_node_id: int,
    destination_node_id: int,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted preferential attachment from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize by the square of maximum degree.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_preferential_attachment_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_preferential_attachment_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_preferential_attachment_from_node_names</span><span class="signature">(
    self,
    first_node_name: str,
    second_node_name: str,
    normalize: bool
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted preferential attachment from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize by the square of maximum degree.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_jaccard_coefficient_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_jaccard_coefficient_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_jaccard_coefficient_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Jaccard index for the two given nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_jaccard_coefficient_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_jaccard_coefficient_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_jaccard_coefficient_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Jaccard index for the two given nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_jaccard_coefficient_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_jaccard_coefficient_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_jaccard_coefficient_from_node_names</span><span class="signature">(self, first_node_name: str, second_node_name: str) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Jaccard index for the two given nodes from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_adamic_adar_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_adamic_adar_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_adamic_adar_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_adamic_adar_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_adamic_adar_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_adamic_adar_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_adamic_adar_index_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_adamic_adar_index_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_adamic_adar_index_from_node_names</span><span class="signature">(self, first_node_name: str, second_node_name: str) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_resource_allocation_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_resource_allocation_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_resource_allocation_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_resource_allocation_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the provided one and two node IDs are higher than the
 number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_resource_allocation_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_resource_allocation_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_resource_allocation_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_resource_allocation_index_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_resource_allocation_index_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_resource_allocation_index_from_node_names</span><span class="signature">(self, first_node_name: str, second_node_name: str) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_resource_allocation_index_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_resource_allocation_index_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_resource_allocation_index_from_node_ids</span><span class="signature">(self, source_node_id: int, destination_node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the node IDs are higher than the number of nodes in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_resource_allocation_index_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_resource_allocation_index_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_resource_allocation_index_from_node_names</span><span class="signature">(self, first_node_name: str, second_node_name: str) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>first_node_name</strong> (str):
Node name of the first node.</li>
<li><strong>second_node_name</strong> (str):
Node name of the second node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If either of the given node names do not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_all_edge_metrics_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_all_edge_metrics_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_all_edge_metrics_from_node_ids</span><span class="signature">(
    self,
    source_node_id: int,
    destination_node_id: int,
    normalize: bool
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_all_edge_metrics_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all the implemented edge metrics for the two given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Specifically, the returned values are:</span>
<span class="sd">        * Adamic Adar</span>
<span class="sd">        * Jaccard coefficient</span>
<span class="sd">        * Resource allocation index</span>
<span class="sd">        * Preferential attachment</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns all the implemented edge metrics for the two given node IDs.</p>

<p>Specifically, the returned values are:</p>

<ul>
<li>Adamic Adar</li>
<li>Jaccard coefficient</li>
<li>Resource allocation index</li>
<li>Preferential attachment</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_id</strong> (int):
Node ID of the first node.</li>
<li><strong>destination_node_id</strong> (int):
Node ID of the second node.</li>
<li><strong>normalize</strong> (bool):
Whether to normalize within 0 to 1.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node IDs do not exist in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.filter_from_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.filter_from_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">filter_from_ids</span><span class="signature">(
    self,
    node_ids_to_keep: Union[List[int], NoneType],
    node_ids_to_filter: Union[List[int], NoneType],
    node_type_ids_to_keep: Union[List[Union[List[int], NoneType]], NoneType],
    node_type_ids_to_filter: Union[List[Union[List[int], NoneType]], NoneType],
    node_type_id_to_keep: Union[List[Union[int, NoneType]], NoneType],
    node_type_id_to_filter: Union[List[Union[int, NoneType]], NoneType],
    edge_ids_to_keep: Union[List[int], NoneType],
    edge_ids_to_filter: Union[List[int], NoneType],
    edge_node_ids_to_keep: Union[List[Tuple[int, int]], NoneType],
    edge_node_ids_to_filter: Union[List[Tuple[int, int]], NoneType],
    edge_type_ids_to_keep: Union[List[Union[int, NoneType]], NoneType],
    edge_type_ids_to_filter: Union[List[Union[int, NoneType]], NoneType],
    min_edge_weight: Union[float, NoneType],
    max_edge_weight: Union[float, NoneType],
    filter_singleton_nodes: Union[bool, NoneType],
    filter_singleton_nodes_with_selfloop: Union[bool, NoneType],
    filter_selfloops: Union[bool, NoneType],
    filter_parallel_edges: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">filter_from_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_id_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">node_type_id_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids_to_keep: Optional[List[int]]</span>
<span class="sd">            List of node IDs to keep during filtering.</span>
<span class="sd">        node_ids_to_filter: Optional[List[int]]</span>
<span class="sd">            List of node IDs to remove during filtering.</span>
<span class="sd">        node_type_ids_to_keep: Optional[List[Optional[List[int]]]]</span>
<span class="sd">            List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_ids_to_filter: Optional[List[Optional[List[int]]]]</span>
<span class="sd">            List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_id_to_keep: Optional[List[Optional[int]]]</span>
<span class="sd">            List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_id_to_filter: Optional[List[Optional[int]]]</span>
<span class="sd">            List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_ids_to_keep: Optional[List[int]]</span>
<span class="sd">            List of edge IDs to keep during filtering.</span>
<span class="sd">        edge_ids_to_filter: Optional[List[int]]</span>
<span class="sd">            List of edge IDs to remove during filtering.</span>
<span class="sd">        edge_node_ids_to_keep: Optional[List[Tuple[int, int]]]</span>
<span class="sd">            List of tuple of node IDs to keep during filtering.</span>
<span class="sd">        edge_node_ids_to_filter: Optional[List[Tuple[int, int]]]</span>
<span class="sd">            List of tuple of node IDs to remove during filtering.</span>
<span class="sd">        edge_type_ids_to_keep: Optional[List[Optional[int]]]</span>
<span class="sd">            List of edge type IDs to keep during filtering.</span>
<span class="sd">        edge_type_ids_to_filter: Optional[List[Optional[int]]]</span>
<span class="sd">            List of edge type IDs to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float]</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float]</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool]</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a <strong>NEW</strong> Graph that does not have the required attributes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids_to_keep</strong> (Optional[List[int]]):
List of node IDs to keep during filtering.</li>
<li><strong>node_ids_to_filter</strong> (Optional[List[int]]):
List of node IDs to remove during filtering.</li>
<li><strong>node_type_ids_to_keep</strong> (Optional[List[Optional[List[int]]]]):
List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.</li>
<li><strong>node_type_ids_to_filter</strong> (Optional[List[Optional[List[int]]]]):
List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.</li>
<li><strong>node_type_id_to_keep</strong> (Optional[List[Optional[int]]]):
List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.</li>
<li><strong>node_type_id_to_filter</strong> (Optional[List[Optional[int]]]):
List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.</li>
<li><strong>edge_ids_to_keep</strong> (Optional[List[int]]):
List of edge IDs to keep during filtering.</li>
<li><strong>edge_ids_to_filter</strong> (Optional[List[int]]):
List of edge IDs to remove during filtering.</li>
<li><strong>edge_node_ids_to_keep</strong> (Optional[List[Tuple[int, int]]]):
List of tuple of node IDs to keep during filtering.</li>
<li><strong>edge_node_ids_to_filter</strong> (Optional[List[Tuple[int, int]]]):
List of tuple of node IDs to remove during filtering.</li>
<li><strong>edge_type_ids_to_keep</strong> (Optional[List[Optional[int]]]):
List of edge type IDs to keep during filtering.</li>
<li><strong>edge_type_ids_to_filter</strong> (Optional[List[Optional[int]]]):
List of edge type IDs to remove during filtering.</li>
<li><strong>min_edge_weight</strong> (Optional[float]):
Minimum edge weight. Values lower than this are removed.</li>
<li><strong>max_edge_weight</strong> (Optional[float]):
Maximum edge weight. Values higher than this are removed.</li>
<li><strong>filter_singleton_nodes</strong> (Optional[bool]):
Whether to filter out singleton nodes.</li>
<li><strong>filter_singleton_nodes_with_selfloop</strong> (Optional[bool]):
Whether to filter out singleton nodes with selfloops.</li>
<li><strong>filter_selfloops</strong> (Optional[bool]):
Whether to filter out selfloops.</li>
<li><strong>filter_parallel_edges</strong> (Optional[bool]):
Whether to filter out parallel edges.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show loading bar while building the graphs.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.filter_from_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.filter_from_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">filter_from_names</span><span class="signature">(
    self,
    node_names_to_keep: Union[List[str], NoneType],
    node_names_to_filter: Union[List[str], NoneType],
    node_type_names_to_keep: Union[List[Union[List[str], NoneType]], NoneType],
    node_type_names_to_filter: Union[List[Union[List[str], NoneType]], NoneType],
    node_type_name_to_keep: Union[List[Union[str, NoneType]], NoneType],
    node_type_name_to_filter: Union[List[Union[str, NoneType]], NoneType],
    edge_node_names_to_keep: Union[List[Tuple[str, str]], NoneType],
    edge_node_names_to_filter: Union[List[Tuple[str, str]], NoneType],
    edge_type_names_to_keep: Union[List[Union[str, NoneType]], NoneType],
    edge_type_names_to_filter: Union[List[Union[str, NoneType]], NoneType],
    min_edge_weight: Union[float, NoneType],
    max_edge_weight: Union[float, NoneType],
    filter_singleton_nodes: Union[bool, NoneType],
    filter_singleton_nodes_with_selfloop: Union[bool, NoneType],
    filter_selfloops: Union[bool, NoneType],
    filter_parallel_edges: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">filter_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_name_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">node_type_name_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names_to_keep: Optional[List[str]]</span>
<span class="sd">            List of node names to keep during filtering.</span>
<span class="sd">        node_names_to_filter: Optional[List[str]]</span>
<span class="sd">            List of node names to remove during filtering.</span>
<span class="sd">        node_type_names_to_keep: Optional[List[Optional[List[str]]]]</span>
<span class="sd">            List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_names_to_filter: Optional[List[Optional[List[str]]]]</span>
<span class="sd">            List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_name_to_keep: Optional[List[Optional[str]]]</span>
<span class="sd">            List of node type name to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_name_to_filter: Optional[List[Optional[str]]]</span>
<span class="sd">            List of node type name to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_node_names_to_keep: Optional[List[Tuple[str, str]]]</span>
<span class="sd">            List of tuple of node names to keep during filtering.</span>
<span class="sd">        edge_node_names_to_filter: Optional[List[Tuple[str, str]]]</span>
<span class="sd">            List of tuple of node names to remove during filtering.</span>
<span class="sd">        edge_type_names_to_keep: Optional[List[Optional[str]]]</span>
<span class="sd">            List of edge type names to keep during filtering.</span>
<span class="sd">        edge_type_names_to_filter: Optional[List[Optional[str]]]</span>
<span class="sd">            List of edge type names to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float]</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float]</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool]</span>
<span class="sd">            Whether to filter out singletons.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool]</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool]</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool]</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a <strong>NEW</strong> Graph that does not have the required attributes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_names_to_keep</strong> (Optional[List[str]]):
List of node names to keep during filtering.</li>
<li><strong>node_names_to_filter</strong> (Optional[List[str]]):
List of node names to remove during filtering.</li>
<li><strong>node_type_names_to_keep</strong> (Optional[List[Optional[List[str]]]]):
List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.</li>
<li><strong>node_type_names_to_filter</strong> (Optional[List[Optional[List[str]]]]):
List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.</li>
<li><strong>node_type_name_to_keep</strong> (Optional[List[Optional[str]]]):
List of node type name to keep during filtering. Any of node types must match with one of the node types given.</li>
<li><strong>node_type_name_to_filter</strong> (Optional[List[Optional[str]]]):
List of node type name to remove during filtering. Any of node types must match with one of the node types given.</li>
<li><strong>edge_node_names_to_keep</strong> (Optional[List[Tuple[str, str]]]):
List of tuple of node names to keep during filtering.</li>
<li><strong>edge_node_names_to_filter</strong> (Optional[List[Tuple[str, str]]]):
List of tuple of node names to remove during filtering.</li>
<li><strong>edge_type_names_to_keep</strong> (Optional[List[Optional[str]]]):
List of edge type names to keep during filtering.</li>
<li><strong>edge_type_names_to_filter</strong> (Optional[List[Optional[str]]]):
List of edge type names to remove during filtering.</li>
<li><strong>min_edge_weight</strong> (Optional[float]):
Minimum edge weight. Values lower than this are removed.</li>
<li><strong>max_edge_weight</strong> (Optional[float]):
Maximum edge weight. Values higher than this are removed.</li>
<li><strong>filter_singleton_nodes</strong> (Optional[bool]):
Whether to filter out singletons.</li>
<li><strong>filter_singleton_nodes_with_selfloop</strong> (Optional[bool]):
Whether to filter out singleton nodes with selfloops.</li>
<li><strong>filter_selfloops</strong> (Optional[bool]):
Whether to filter out selfloops.</li>
<li><strong>filter_parallel_edges</strong> (Optional[bool]):
Whether to filter out parallel edges.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show loading bar while building the graphs.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.drop_unknown_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_unknown_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_unknown_node_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown node types and relative nodes.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL nodes labeled with unknown node</span>
<span class="sd">        type!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without unknown node types and relative nodes.</p>

<p>Note that this method will remove ALL nodes labeled with unknown node
type!</p>
</div>


                            </div>
                            <div id="Graph.drop_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_unknown_edge_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown edge types and relative edges.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL edges labeled with unknown edge</span>
<span class="sd">        type!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without unknown edge types and relative edges.</p>

<p>Note that this method will remove ALL edges labeled with unknown edge
type!</p>
</div>


                            </div>
                            <div id="Graph.drop_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_singleton_nodes</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without singleton nodes.</p>

<p>A node is singleton when does not have neither incoming or outgoing edges.</p>
</div>


                            </div>
                            <div id="Graph.drop_singleton_nodes_with_selfloops" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_singleton_nodes_with_selfloops">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_singleton_nodes_with_selfloops</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes with selfloops.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton with selfloop when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without singleton nodes with selfloops.</p>

<p>A node is singleton with selfloop when does not have neither incoming or outgoing edges.</p>
</div>


                            </div>
                            <div id="Graph.drop_disconnected_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_disconnected_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_disconnected_nodes</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without disconnected nodes.</span>
<span class="sd">        </span>
<span class="sd">        A disconnected node is a node with no connection to any other node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without disconnected nodes.</p>

<p>A disconnected node is a node with no connection to any other node.</p>
</div>


                            </div>
                            <div id="Graph.drop_selfloops" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_selfloops">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_selfloops</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without selfloops.</p>
</div>


                            </div>
                            <div id="Graph.drop_parallel_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.drop_parallel_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drop_parallel_edges</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drop_parallel_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without parallel edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph without parallel edges</p>
</div>


                            </div>
                            <div id="Graph.from_csv" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.from_csv">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">from_csv</span><span class="signature">(
    node_type_path: Union[str, NoneType],
    node_type_list_separator: Union[str, NoneType],
    node_types_column_number: Union[int, NoneType],
    node_types_column: Union[str, NoneType],
    node_types_ids_column_number: Union[int, NoneType],
    node_types_ids_column: Union[str, NoneType],
    node_types_number: Union[int, NoneType],
    numeric_node_type_ids: Union[bool, NoneType],
    minimum_node_type_id: Union[int, NoneType],
    node_type_list_header: Union[bool, NoneType],
    node_type_list_rows_to_skip: Union[int, NoneType],
    node_type_list_is_correct: Union[bool, NoneType],
    node_type_list_max_rows_number: Union[int, NoneType],
    node_type_list_comment_symbol: Union[str, NoneType],
    load_node_type_list_in_parallel: Union[bool, NoneType],
    node_path: Union[str, NoneType],
    node_list_separator: Union[str, NoneType],
    node_list_header: Union[bool, NoneType],
    node_list_rows_to_skip: Union[int, NoneType],
    node_list_is_correct: Union[bool, NoneType],
    node_list_max_rows_number: Union[int, NoneType],
    node_list_comment_symbol: Union[str, NoneType],
    default_node_type: Union[str, NoneType],
    nodes_column_number: Union[int, NoneType],
    nodes_column: Union[str, NoneType],
    node_types_separator: Union[str, NoneType],
    node_list_node_types_column_number: Union[int, NoneType],
    node_list_node_types_column: Union[str, NoneType],
    node_ids_column: Union[str, NoneType],
    node_ids_column_number: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    minimum_node_id: Union[int, NoneType],
    numeric_node_ids: Union[bool, NoneType],
    node_list_numeric_node_type_ids: Union[bool, NoneType],
    skip_node_types_if_unavailable: Union[bool, NoneType],
    load_node_list_in_parallel: Union[bool, NoneType],
    edge_type_path: Union[str, NoneType],
    edge_types_column_number: Union[int, NoneType],
    edge_types_column: Union[str, NoneType],
    edge_types_ids_column_number: Union[int, NoneType],
    edge_types_ids_column: Union[str, NoneType],
    edge_types_number: Union[int, NoneType],
    numeric_edge_type_ids: Union[bool, NoneType],
    minimum_edge_type_id: Union[int, NoneType],
    edge_type_list_separator: Union[str, NoneType],
    edge_type_list_header: Union[bool, NoneType],
    edge_type_list_rows_to_skip: Union[int, NoneType],
    edge_type_list_is_correct: Union[bool, NoneType],
    edge_type_list_max_rows_number: Union[int, NoneType],
    edge_type_list_comment_symbol: Union[str, NoneType],
    load_edge_type_list_in_parallel: Union[bool, NoneType],
    edge_path: Union[str, NoneType],
    edge_list_separator: Union[str, NoneType],
    edge_list_header: Union[bool, NoneType],
    edge_list_rows_to_skip: Union[int, NoneType],
    sources_column_number: Union[int, NoneType],
    sources_column: Union[str, NoneType],
    destinations_column_number: Union[int, NoneType],
    destinations_column: Union[str, NoneType],
    edge_list_edge_types_column_number: Union[int, NoneType],
    edge_list_edge_types_column: Union[str, NoneType],
    default_edge_type: Union[str, NoneType],
    weights_column_number: Union[int, NoneType],
    weights_column: Union[str, NoneType],
    default_weight: Union[float, NoneType],
    edge_ids_column: Union[str, NoneType],
    edge_ids_column_number: Union[int, NoneType],
    edge_list_numeric_edge_type_ids: Union[bool, NoneType],
    edge_list_numeric_node_ids: Union[bool, NoneType],
    skip_weights_if_unavailable: Union[bool, NoneType],
    skip_edge_types_if_unavailable: Union[bool, NoneType],
    edge_list_is_complete: Union[bool, NoneType],
    edge_list_may_contain_duplicates: Union[bool, NoneType],
    edge_list_is_sorted: Union[bool, NoneType],
    edge_list_is_correct: Union[bool, NoneType],
    edge_list_max_rows_number: Union[int, NoneType],
    edge_list_comment_symbol: Union[str, NoneType],
    edges_number: Union[int, NoneType],
    load_edge_list_in_parallel: Union[bool, NoneType],
    verbose: Union[bool, NoneType],
    may_have_singletons: Union[bool, NoneType],
    may_have_singleton_with_selfloops: Union[bool, NoneType],
    directed: bool,
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="n">node_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_types_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_node_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_node_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">load_node_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">edge_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_complete</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_may_contain_duplicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_sorted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singletons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singleton_with_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return graph renderized from given CSVs or TSVs-like files.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique node type names.</span>
<span class="sd">        node_type_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_number: Optional[int]</span>
<span class="sd">            The number of the unique node types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_node_type_ids: Optional[bool]</span>
<span class="sd">            Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_node_type_id: Optional[int]</span>
<span class="sd">            The minimum node type ID to be used when using numeric node type IDs.</span>
<span class="sd">        node_type_list_header: Optional[bool]</span>
<span class="sd">            Whether the node type file has an header.</span>
<span class="sd">        node_type_list_rows_to_skip: Optional[int]</span>
<span class="sd">            The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.</span>
<span class="sd">        node_type_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_type_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the node types file.</span>
<span class="sd">        node_type_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_node_type_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.</span>
<span class="sd">        node_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique node names.</span>
<span class="sd">        node_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_list_header: Optional[bool]</span>
<span class="sd">            Whether the nodes file has an header.</span>
<span class="sd">        node_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the node list file.</span>
<span class="sd">        node_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the nodes file.</span>
<span class="sd">        node_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        default_node_type: Optional[str]</span>
<span class="sd">            The node type to be used when the node type for a given node in the node file is None.</span>
<span class="sd">        nodes_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node names.</span>
<span class="sd">        nodes_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node names.</span>
<span class="sd">        node_types_separator: Optional[str]</span>
<span class="sd">            The node types separator.</span>
<span class="sd">        node_list_node_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node types.</span>
<span class="sd">        node_list_node_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node types.</span>
<span class="sd">        node_ids_column: Optional[str]</span>
<span class="sd">            The name of the column of the node file from where to load the node IDs.</span>
<span class="sd">        node_ids_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the node file from where to load the node IDs</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            The minimum node ID to be used, when loading the node IDs as numerical.</span>
<span class="sd">        numeric_node_ids: Optional[bool]</span>
<span class="sd">            Whether to load the numeric node IDs as numeric.</span>
<span class="sd">        node_list_numeric_node_type_ids: Optional[bool]</span>
<span class="sd">            Whether to load the node types IDs in the node file to be numeric.</span>
<span class="sd">        skip_node_types_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the node types without raising an error if these are unavailable.</span>
<span class="sd">        load_node_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.</span>
<span class="sd">        edge_type_path: Optional[str]</span>
<span class="sd">            The path to the file with the unique edge type names.</span>
<span class="sd">        edge_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_number: Optional[int]</span>
<span class="sd">            The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_edge_type_ids: Optional[bool]</span>
<span class="sd">            Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_edge_type_id: Optional[int]</span>
<span class="sd">            The minimum edge type ID to be used when using numeric edge type IDs.</span>
<span class="sd">        edge_type_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_type_list_header: Optional[bool]</span>
<span class="sd">            Whether the edge type file has an header.</span>
<span class="sd">        edge_type_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the edge type list file.</span>
<span class="sd">        edge_type_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_type_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the edge types file.</span>
<span class="sd">        edge_type_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_edge_type_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.</span>
<span class="sd">        edge_path: Optional[str]</span>
<span class="sd">            The path to the file with the edge list.</span>
<span class="sd">        edge_list_separator: Optional[str]</span>
<span class="sd">            The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_list_header: Optional[bool]</span>
<span class="sd">            Whether the edges file has an header.</span>
<span class="sd">        edge_list_rows_to_skip: Optional[int]</span>
<span class="sd">            Number of rows to skip in the edge list file.</span>
<span class="sd">        sources_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        sources_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        destinations_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        destinations_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        edge_list_edge_types_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge types.</span>
<span class="sd">        edge_list_edge_types_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge types.</span>
<span class="sd">        default_edge_type: Optional[str]</span>
<span class="sd">            The edge type to be used when the edge type for a given edge in the edge file is None.</span>
<span class="sd">        weights_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        weights_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        default_weight: Optional[float]</span>
<span class="sd">            The edge weight to be used when the edge weight for a given edge in the edge file is None.</span>
<span class="sd">        edge_ids_column: Optional[str]</span>
<span class="sd">            The name of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_ids_column_number: Optional[int]</span>
<span class="sd">            The number of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_list_numeric_edge_type_ids: Optional[bool]</span>
<span class="sd">            Whether to load the edge type IDs as numeric from the edge list.</span>
<span class="sd">        edge_list_numeric_node_ids: Optional[bool]</span>
<span class="sd">            Whether to load the edge node IDs as numeric from the edge list.</span>
<span class="sd">        skip_weights_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the weights without raising an error if these are unavailable.</span>
<span class="sd">        skip_edge_types_if_unavailable: Optional[bool]</span>
<span class="sd">            Whether to skip the edge types without raising an error if these are unavailable.</span>
<span class="sd">        edge_list_is_complete: Optional[bool]</span>
<span class="sd">            Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.</span>
<span class="sd">        edge_list_may_contain_duplicates: Optional[bool]</span>
<span class="sd">            Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.</span>
<span class="sd">        edge_list_is_sorted: Optional[bool]</span>
<span class="sd">            Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.</span>
<span class="sd">        edge_list_is_correct: Optional[bool]</span>
<span class="sd">            Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_list_max_rows_number: Optional[int]</span>
<span class="sd">            The maximum number of lines to be loaded from the edges file.</span>
<span class="sd">        edge_list_comment_symbol: Optional[str]</span>
<span class="sd">            The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        edges_number: Optional[int]</span>
<span class="sd">            The expected number of edges. Note that this must be the EXACT number of edges in the graph.</span>
<span class="sd">        load_edge_list_in_parallel: Optional[bool]</span>
<span class="sd">            Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.</span>
<span class="sd">        may_have_singletons: Optional[bool]</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        may_have_singleton_with_selfloops: Optional[bool]</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to load the graph as directed or undirected.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            The name of the graph to be loaded.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return graph renderized from given CSVs or TSVs-like files.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_path</strong> (Optional[str]):
The path to the file with the unique node type names.</li>
<li><strong>node_type_list_separator</strong> (Optional[str]):
The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</li>
<li><strong>node_types_column_number</strong> (Optional[int]):
The number of the column of the node types file from where to load the node types.</li>
<li><strong>node_types_column</strong> (Optional[str]):
The name of the column of the node types file from where to load the node types.</li>
<li><strong>node_types_number</strong> (Optional[int]):
The number of the unique node types. This will be used in order to allocate the correct size for the data structure.</li>
<li><strong>numeric_node_type_ids</strong> (Optional[bool]):
Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</li>
<li><strong>minimum_node_type_id</strong> (Optional[int]):
The minimum node type ID to be used when using numeric node type IDs.</li>
<li><strong>node_type_list_header</strong> (Optional[bool]):
Whether the node type file has an header.</li>
<li><strong>node_type_list_rows_to_skip</strong> (Optional[int]):
The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.</li>
<li><strong>node_type_list_is_correct</strong> (Optional[bool]):
Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</li>
<li><strong>node_type_list_max_rows_number</strong> (Optional[int]):
The maximum number of lines to be loaded from the node types file.</li>
<li><strong>node_type_list_comment_symbol</strong> (Optional[str]):
The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.</li>
<li><strong>load_node_type_list_in_parallel</strong> (Optional[bool]):
Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.</li>
<li><strong>node_path</strong> (Optional[str]):
The path to the file with the unique node names.</li>
<li><strong>node_list_separator</strong> (Optional[str]):
The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</li>
<li><strong>node_list_header</strong> (Optional[bool]):
Whether the nodes file has an header.</li>
<li><strong>node_list_rows_to_skip</strong> (Optional[int]):
Number of rows to skip in the node list file.</li>
<li><strong>node_list_is_correct</strong> (Optional[bool]):
Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</li>
<li><strong>node_list_max_rows_number</strong> (Optional[int]):
The maximum number of lines to be loaded from the nodes file.</li>
<li><strong>node_list_comment_symbol</strong> (Optional[str]):
The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.</li>
<li><strong>default_node_type</strong> (Optional[str]):
The node type to be used when the node type for a given node in the node file is None.</li>
<li><strong>nodes_column_number</strong> (Optional[int]):
The number of the column of the node file from where to load the node names.</li>
<li><strong>nodes_column</strong> (Optional[str]):
The name of the column of the node file from where to load the node names.</li>
<li><strong>node_types_separator</strong> (Optional[str]):
The node types separator.</li>
<li><strong>node_list_node_types_column_number</strong> (Optional[int]):
The number of the column of the node file from where to load the node types.</li>
<li><strong>node_list_node_types_column</strong> (Optional[str]):
The name of the column of the node file from where to load the node types.</li>
<li><strong>node_ids_column</strong> (Optional[str]):
The name of the column of the node file from where to load the node IDs.</li>
<li><strong>node_ids_column_number</strong> (Optional[int]):
The number of the column of the node file from where to load the node IDs</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.</li>
<li><strong>minimum_node_id</strong> (Optional[int]):
The minimum node ID to be used, when loading the node IDs as numerical.</li>
<li><strong>numeric_node_ids</strong> (Optional[bool]):
Whether to load the numeric node IDs as numeric.</li>
<li><strong>node_list_numeric_node_type_ids</strong> (Optional[bool]):
Whether to load the node types IDs in the node file to be numeric.</li>
<li><strong>skip_node_types_if_unavailable</strong> (Optional[bool]):
Whether to skip the node types without raising an error if these are unavailable.</li>
<li><strong>load_node_list_in_parallel</strong> (Optional[bool]):
Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.</li>
<li><strong>edge_type_path</strong> (Optional[str]):
The path to the file with the unique edge type names.</li>
<li><strong>edge_types_column_number</strong> (Optional[int]):
The number of the column of the edge types file from where to load the edge types.</li>
<li><strong>edge_types_column</strong> (Optional[str]):
The name of the column of the edge types file from where to load the edge types.</li>
<li><strong>edge_types_number</strong> (Optional[int]):
The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.</li>
<li><strong>numeric_edge_type_ids</strong> (Optional[bool]):
Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</li>
<li><strong>minimum_edge_type_id</strong> (Optional[int]):
The minimum edge type ID to be used when using numeric edge type IDs.</li>
<li><strong>edge_type_list_separator</strong> (Optional[str]):
The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between ';', ',', tab or space.</li>
<li><strong>edge_type_list_header</strong> (Optional[bool]):
Whether the edge type file has an header.</li>
<li><strong>edge_type_list_rows_to_skip</strong> (Optional[int]):
Number of rows to skip in the edge type list file.</li>
<li><strong>edge_type_list_is_correct</strong> (Optional[bool]):
Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</li>
<li><strong>edge_type_list_max_rows_number</strong> (Optional[int]):
The maximum number of lines to be loaded from the edge types file.</li>
<li><strong>edge_type_list_comment_symbol</strong> (Optional[str]):
The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.</li>
<li><strong>load_edge_type_list_in_parallel</strong> (Optional[bool]):
Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.</li>
<li><strong>edge_path</strong> (Optional[str]):
The path to the file with the edge list.</li>
<li><strong>edge_list_separator</strong> (Optional[str]):
The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between ';', ',', tab or space.</li>
<li><strong>edge_list_header</strong> (Optional[bool]):
Whether the edges file has an header.</li>
<li><strong>edge_list_rows_to_skip</strong> (Optional[int]):
Number of rows to skip in the edge list file.</li>
<li><strong>sources_column_number</strong> (Optional[int]):
The number of the column of the edges file from where to load the source nodes.</li>
<li><strong>sources_column</strong> (Optional[str]):
The name of the column of the edges file from where to load the source nodes.</li>
<li><strong>destinations_column_number</strong> (Optional[int]):
The number of the column of the edges file from where to load the destinaton nodes.</li>
<li><strong>destinations_column</strong> (Optional[str]):
The name of the column of the edges file from where to load the destinaton nodes.</li>
<li><strong>edge_list_edge_types_column_number</strong> (Optional[int]):
The number of the column of the edges file from where to load the edge types.</li>
<li><strong>edge_list_edge_types_column</strong> (Optional[str]):
The name of the column of the edges file from where to load the edge types.</li>
<li><strong>default_edge_type</strong> (Optional[str]):
The edge type to be used when the edge type for a given edge in the edge file is None.</li>
<li><strong>weights_column_number</strong> (Optional[int]):
The number of the column of the edges file from where to load the edge weights.</li>
<li><strong>weights_column</strong> (Optional[str]):
The name of the column of the edges file from where to load the edge weights.</li>
<li><strong>default_weight</strong> (Optional[float]):
The edge weight to be used when the edge weight for a given edge in the edge file is None.</li>
<li><strong>edge_ids_column</strong> (Optional[str]):
The name of the column of the edges file from where to load the edge IDs.</li>
<li><strong>edge_ids_column_number</strong> (Optional[int]):
The number of the column of the edges file from where to load the edge IDs.</li>
<li><strong>edge_list_numeric_edge_type_ids</strong> (Optional[bool]):
Whether to load the edge type IDs as numeric from the edge list.</li>
<li><strong>edge_list_numeric_node_ids</strong> (Optional[bool]):
Whether to load the edge node IDs as numeric from the edge list.</li>
<li><strong>skip_weights_if_unavailable</strong> (Optional[bool]):
Whether to skip the weights without raising an error if these are unavailable.</li>
<li><strong>skip_edge_types_if_unavailable</strong> (Optional[bool]):
Whether to skip the edge types without raising an error if these are unavailable.</li>
<li><strong>edge_list_is_complete</strong> (Optional[bool]):
Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.</li>
<li><strong>edge_list_may_contain_duplicates</strong> (Optional[bool]):
Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.</li>
<li><strong>edge_list_is_sorted</strong> (Optional[bool]):
Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.</li>
<li><strong>edge_list_is_correct</strong> (Optional[bool]):
Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</li>
<li><strong>edge_list_max_rows_number</strong> (Optional[int]):
The maximum number of lines to be loaded from the edges file.</li>
<li><strong>edge_list_comment_symbol</strong> (Optional[str]):
The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.</li>
<li><strong>edges_number</strong> (Optional[int]):
The expected number of edges. Note that this must be the EXACT number of edges in the graph.</li>
<li><strong>load_edge_list_in_parallel</strong> (Optional[bool]):
Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.</li>
<li><strong>may_have_singletons</strong> (Optional[bool]):
Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</li>
<li><strong>may_have_singleton_with_selfloops</strong> (Optional[bool]):
Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</li>
<li><strong>directed</strong> (bool):
Whether to load the graph as directed or undirected.</li>
<li><strong>name</strong> (Optional[str]):
The name of the graph to be loaded.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_connected_components_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_connected_components_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_connected_components_number</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; Tuple[int, int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_connected_components_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar or not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_number_of_connected_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_connected_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_connected_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_connected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of connected nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of connected nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_nodes_with_selfloops_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_nodes_with_selfloops_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_nodes_with_selfloops_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_nodes_with_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes with selfloops within the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of singleton nodes with selfloops within the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_number_of_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_singleton_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes within the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of singleton nodes within the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_number_of_disconnected_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_disconnected_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_disconnected_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of disconnected nodes within the graph.</span>
<span class="sd">        A Disconnected node is a node which is nor a singleton nor a singleton</span>
<span class="sd">        with selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of disconnected nodes within the graph.
A Disconnected node is a node which is nor a singleton nor a singleton
with selfloops.</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton node IDs of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_node_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node names of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton node names of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_with_selfloops_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_with_selfloops_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_with_selfloops_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton_with_selfloops node IDs of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_with_selfloops_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_with_selfloops_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_with_selfloops_node_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node names of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton_with_selfloops node names of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_density" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_density">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_density</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns density of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns density of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_trap_nodes_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_trap_nodes_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_trap_nodes_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_trap_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the traps rate of the graph.</span>
<span class="sd">        </span>
<span class="sd">        THIS IS EXPERIMENTAL AND MUST BE PROVEN!&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the traps rate of the graph.</p>

<p>THIS IS EXPERIMENTAL AND MUST BE PROVEN!</p>
</div>


                            </div>
                            <div id="Graph.get_node_degrees_mean" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degrees_mean">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degrees_mean</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted mean node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted mean node degree of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_node_degrees_mean" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_node_degrees_mean">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_node_degrees_mean</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted mean node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weighted mean node degree of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_undirected_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_undirected_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_undirected_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of undirected edges of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_undirected_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_undirected_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_undirected_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of undirected edges of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of edges of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique edges of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of unique edges of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_node_degrees_median" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degrees_median">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degrees_median</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted median node degree of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted median node degree of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_node_degrees_median" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_node_degrees_median">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_node_degrees_median</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted median node degree of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weighted median node degree of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_maximum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_maximum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_maximum_node_degree</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns maximum node degree of the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain any node (is an empty graph).</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_most_central_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_most_central_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_most_central_node_id</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method fails with a panic if the graph does not have any node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns maximum node degree of the graph.</p>

<h6 id="safety">Safety</h6>

<p>This method fails with a panic if the graph does not have any node.</p>
</div>


                            </div>
                            <div id="Graph.get_most_central_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_most_central_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_most_central_node_id</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns maximum node degree of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_minimum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_minimum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_minimum_node_degree</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum node degree of the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain any node (is an empty graph).</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_degrees_mode" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degrees_mode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degrees_mode</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degrees_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns mode node degree of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns mode node degree of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_selfloop_nodes_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_selfloop_nodes_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_selfloop_nodes_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_selfloop_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of self-loops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns rate of self-loops.</p>
</div>


                            </div>
                            <div id="Graph.get_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_name</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return name of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return name of the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_number_of_trap_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_trap_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_trap_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_trap_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of traps (nodes without any outgoing edges that are not singletons)</span>
<span class="sd">        This also includes nodes with only a self-loops, therefore singletons with</span>
<span class="sd">        only a self-loops are not considered traps because you could make a walk on them.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the number of traps (nodes without any outgoing edges that are not singletons)
This also includes nodes with only a self-loops, therefore singletons with
only a self-loops are not considered traps because you could make a walk on them.</p>
</div>


                            </div>
                            <div id="Graph.get_source_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_source_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_source_node_ids</span><span class="signature">(self, directed: bool) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the non-unique source nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_source_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_source_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_source_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed source nodes of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector on the (non unique) directed source nodes of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_source_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_source_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_source_names</span><span class="signature">(self, directed: bool) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_source_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the non-unique source nodes names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_destination_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_destination_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_destination_node_ids</span><span class="signature">(self, directed: bool) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) destination nodes of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector on the (non unique) destination nodes of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_destination_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_destination_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_destination_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed destination nodes of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector on the (non unique) directed destination nodes of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_destination_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_destination_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_destination_names</span><span class="signature">(self, directed: bool) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_destination_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique destination nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of the non-unique destination nodes names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted nodes names</p>
</div>


                            </div>
                            <div id="Graph.get_node_urls" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_urls">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_urls</span><span class="signature">(self) -&gt; List[Union[str, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node URLs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the node URLs.</p>
</div>


                            </div>
                            <div id="Graph.get_node_ontologies" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ontologies">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ontologies</span><span class="signature">(self) -&gt; List[Union[str, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ontologies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node predicted ontology.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the node predicted ontology.</p>
</div>


                            </div>
                            <div id="Graph.get_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes Ids&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted nodes Ids</p>
</div>


                            </div>
                            <div id="Graph.get_edge_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_ids</span><span class="signature">(self) -&gt; List[Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types of the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the edge types of the edges</p>
</div>


                            </div>
                            <div id="Graph.get_unique_edge_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_edge_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_edge_type_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique edge type IDs of the graph edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the unique edge type IDs of the graph edges.</p>
</div>


                            </div>
                            <div id="Graph.get_edge_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_names</span><span class="signature">(self) -&gt; List[Union[str, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the edge types names</p>
</div>


                            </div>
                            <div id="Graph.get_unique_edge_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_edge_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_edge_type_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the edge types names</p>
</div>


                            </div>
                            <div id="Graph.get_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weights</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the weights of the graph edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the weights of the graph edges.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_node_indegrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_node_indegrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_node_indegrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted indegree (total weighted inbound edge weights) for each node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the weighted indegree (total weighted inbound edge weights) for each node.</p>
</div>


                            </div>
                            <div id="Graph.get_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_ids</span><span class="signature">(self) -&gt; List[Union[List[int], NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the node types of the graph nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the node types of the graph nodes.</p>
</div>


                            </div>
                            <div id="Graph.get_known_node_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_known_node_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_known_node_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean mask of known node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unknown_node_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unknown_node_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unknown_node_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean mask of unknown node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_one_hot_encoded_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_one_hot_encoded_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_one_hot_encoded_node_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns one-hot encoded node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_one_hot_encoded_known_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_one_hot_encoded_known_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_one_hot_encoded_known_node_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns one-hot encoded known node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_one_hot_encoded_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_one_hot_encoded_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_one_hot_encoded_edge_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns one-hot encoded edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_one_hot_encoded_known_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_one_hot_encoded_known_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_one_hot_encoded_known_edge_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns one-hot encoded known edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_names</span><span class="signature">(self) -&gt; List[Union[List[str], NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the node types names.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the node types names.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_node_type_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node type IDs of the graph nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the unique node type IDs of the graph nodes.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_node_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_node_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_node_type_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node types names.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the unique node types names.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_directed_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_directed_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_directed_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of the unique edges in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of the unique edges in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_nodes_mapping" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_nodes_mapping">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_nodes_mapping</span><span class="signature">(self) -&gt; Dict[str, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the nodes mapping&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the nodes mapping</p>
</div>


                            </div>
                            <div id="Graph.get_edge_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_ids</span><span class="signature">(self, directed: bool) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge Ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted edge Ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_edge_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_edge_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_edge_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge Ids&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted directed edge Ids</p>
</div>


                            </div>
                            <div id="Graph.get_edge_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_names</span><span class="signature">(self, directed: bool) -&gt; List[Tuple[str, str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted edge names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to filter out the undirected edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_edge_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_edge_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_edge_node_names</span><span class="signature">(self) -&gt; List[Tuple[str, str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge names&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with the sorted directed edge names</p>
</div>


                            </div>
                            <div id="Graph.get_unknown_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unknown_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unknown_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unknown_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes with unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of nodes with unknown node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_known_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_known_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_known_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_known_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of node with known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of node with known node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unknown_node_types_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unknown_node_types_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unknown_node_types_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unknown_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns rate of unknown node types over total nodes number.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_known_node_types_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_known_node_types_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_known_node_types_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_known_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns rate of known node types over total nodes number.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_minimum_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_minimum_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_minimum_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_minimum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum number of node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_maximum_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_maximum_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_maximum_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_maximum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns maximum number of node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_maximum_multilabel_count" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_maximum_multilabel_count">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_maximum_multilabel_count</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_maximum_multilabel_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of maximum multilabel count.</span>
<span class="sd">        </span>
<span class="sd">        This value is the maximum number of multilabel counts</span>
<span class="sd">        that appear in any given node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of maximum multilabel count.</p>

<p>This value is the maximum number of multilabel counts
that appear in any given node in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_singleton_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of singleton node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_singleton_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_node_type_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton node types IDs.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_singleton_node_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_node_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_node_type_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton node types names.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unknown_edge_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unknown_edge_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unknown_edge_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unknown_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of unknown edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_ids_with_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_ids_with_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_ids_with_unknown_edge_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge IDs of the edges with unknown edge types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_ids_with_known_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_ids_with_known_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_ids_with_known_edge_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge IDs of the edges with known edge types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_ids_with_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_ids_with_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_ids_with_unknown_edge_types</span><span class="signature">(self, directed: bool) -&gt; List[Tuple[int, int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge node IDs of the edges with unknown edge types</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to iterated the edges as a directed or undirected edge list.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_ids_with_known_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_ids_with_known_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_ids_with_known_edge_types</span><span class="signature">(self, directed: bool) -&gt; List[Tuple[int, int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge node IDs of the edges with known edge types</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to iterated the edges as a directed or undirected edge list.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_names_with_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_names_with_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_names_with_unknown_edge_types</span><span class="signature">(self, directed: bool) -&gt; List[Tuple[str, str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_names_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge node names of the edges with unknown edge types</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to iterated the edges as a directed or undirected edge list.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_names_with_known_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_names_with_known_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_names_with_known_edge_types</span><span class="signature">(self, directed: bool) -&gt; List[Tuple[str, str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_names_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge node names of the edges with known edge types</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>directed</strong> (bool):
Whether to iterated the edges as a directed or undirected edge list.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_ids_with_unknown_edge_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_ids_with_unknown_edge_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_ids_with_unknown_edge_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a boolean vector that for each node contains whether it has an
unknown node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_ids_with_known_edge_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_ids_with_known_edge_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_ids_with_known_edge_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a boolean vector that for each node contains whether it has an
unknown edge type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_with_unknown_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_with_unknown_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_with_unknown_node_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node IDs of the nodes with unknown node types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_with_known_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_with_known_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_with_known_node_types</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node IDs of the nodes with known node types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_names_with_unknown_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_names_with_unknown_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_names_with_unknown_node_types</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_names_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node names of the nodes with unknown node types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_names_with_known_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_names_with_known_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_names_with_known_node_types</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_names_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node names of the nodes with known node types</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_with_unknown_node_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_with_unknown_node_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_with_unknown_node_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a boolean vector that for each node contains whether it has an
unknown node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_with_known_node_types_mask" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_with_known_node_types_mask">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_with_known_node_types_mask</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a boolean vector that for each node contains whether it has an
known node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_known_edge_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_known_edge_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_known_edge_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_known_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of edge with known edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of edge with known edge type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unknown_edge_types_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unknown_edge_types_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unknown_edge_types_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unknown_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns rate of unknown edge types over total edges number.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_known_edge_types_rate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_known_edge_types_rate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_known_edge_types_rate</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_known_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns rate of known edge types over total edges number.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_minimum_edge_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_minimum_edge_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_minimum_edge_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_minimum_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns minimum number of edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_singleton_edge_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_edge_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_edge_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of singleton edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_singleton_edge_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_edge_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_edge_type_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton edge types IDs.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_singleton_edge_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_singleton_edge_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_singleton_edge_type_names</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_singleton_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of singleton edge types names.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_number_of_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of nodes in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_node_connected_component_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_connected_component_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_connected_component_ids</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_connected_component_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a vector with the components each node belongs to.</span>
<span class="sd">        </span>
<span class="sd">        E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like</span>
<span class="sd">        `[0, 1, 0, 0, 1, 1]`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return a vector with the components each node belongs to.</p>

<p>E.g. If we have two components <code>[0, 2, 3]</code> and <code>[1, 4, 5]</code> the result will look like
<code>[0, 1, 0, 0, 1, 1]</code></p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of directed edges in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of directed edges in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_edge_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edge types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of edge types in the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_types_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_types_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_types_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of node types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of node types in the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_degrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted degree of every node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the unweighted degree of every node in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_node_indegrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_indegrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_indegrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the indegree for each node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the indegree for each node.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_node_degrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_node_degrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_node_degrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted degree of every node in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted degree of every node in the graph</p>
</div>


                            </div>
                            <div id="Graph.get_not_singletons_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_not_singletons_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_not_singletons_node_ids</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_not_singletons_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return set of nodes that are not singletons&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return set of nodes that are not singletons</p>
</div>


                            </div>
                            <div id="Graph.get_dense_nodes_mapping" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_dense_nodes_mapping">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dense_nodes_mapping</span><span class="signature">(self) -&gt; Dict[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_dense_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return mapping from instance not trap nodes to dense nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return mapping from instance not trap nodes to dense nodes</p>
</div>


                            </div>
                            <div id="Graph.get_parallel_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_parallel_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_parallel_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_parallel_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges that have multigraph syblings&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of edges that have multigraph syblings</p>
</div>


                            </div>
                            <div id="Graph.get_cumulative_node_degrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_cumulative_node_degrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_cumulative_node_degrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_cumulative_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with node cumulative_node_degrees, that is the comulative node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with node cumulative_node_degrees, that is the comulative node degree</p>
</div>


                            </div>
                            <div id="Graph.get_reciprocal_sqrt_degrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_reciprocal_sqrt_degrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_reciprocal_sqrt_degrees</span><span class="signature">(self) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_reciprocal_sqrt_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector wit&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector wit</p>
</div>


                            </div>
                            <div id="Graph.get_number_of_unique_source_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_unique_source_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_unique_source_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_unique_source_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of the source nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of the source nodes.</p>
</div>


                            </div>
                            <div id="Graph.get_edge_type_id_counts_hashmap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_id_counts_hashmap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_id_counts_hashmap</span><span class="signature">(self) -&gt; Dict[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge type IDs counts hashmap.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_type_names_counts_hashmap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_names_counts_hashmap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_names_counts_hashmap</span><span class="signature">(self) -&gt; Dict[str, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge type names counts hashmap.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_id_counts_hashmap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_id_counts_hashmap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_id_counts_hashmap</span><span class="signature">(self) -&gt; Dict[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node type IDs counts hashmap.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_names_counts_hashmap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_names_counts_hashmap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_names_counts_hashmap</span><span class="signature">(self) -&gt; Dict[str, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node type names counts hashmap.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_default_graph_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_default_graph_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_default_graph_name</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_default_graph_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if graph has name that is not the default one.</span>
<span class="sd">        </span>
<span class="sd">        TODO: use a default for the default graph name&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return if graph has name that is not the default one.</p>

<p>TODO: use a default for the default graph name</p>
</div>


                            </div>
                            <div id="Graph.has_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_nodes</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return if the graph has any nodes.</p>
</div>


                            </div>
                            <div id="Graph.has_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edges</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return if the graph has any edges.</p>
</div>


                            </div>
                            <div id="Graph.has_trap_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_trap_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_trap_nodes</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_trap_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has trap nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether the graph has trap nodes.</p>
</div>


                            </div>
                            <div id="Graph.is_directed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_directed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_directed</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph is directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph is directed.</p>
</div>


                            </div>
                            <div id="Graph.has_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_weights</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing whether graph has weights.</p>
</div>


                            </div>
                            <div id="Graph.has_edge_weights_representing_probabilities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_weights_representing_probabilities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_weights_representing_probabilities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_weights_representing_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether graph has weights that can represent probabilities&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether graph has weights that can represent probabilities</p>
</div>


                            </div>
                            <div id="Graph.has_weighted_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_weighted_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_weighted_singleton_nodes</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether a graph has one or more weighted singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A weighted singleton node is a node whose weighted node degree is 0.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether a graph has one or more weighted singleton nodes.</p>

<p>A weighted singleton node is a node whose weighted node degree is 0.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_constant_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_constant_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_constant_edge_weights</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_constant_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has constant weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has constant weights.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_negative_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_negative_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_negative_edge_weights</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_negative_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has negative weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing whether graph has negative weights.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing whether graph has edge types.</p>
</div>


                            </div>
                            <div id="Graph.has_selfloops" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_selfloops">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_selfloops</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has self-loops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph has self-loops.</p>
</div>


                            </div>
                            <div id="Graph.has_disconnected_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_disconnected_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_disconnected_nodes</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if nodes which are nor singletons nor</span>
<span class="sd">        singletons with selfloops.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if nodes which are nor singletons nor
singletons with selfloops.</p>
</div>


                            </div>
                            <div id="Graph.has_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_singleton_nodes</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph has singletons.</p>
</div>


                            </div>
                            <div id="Graph.has_singleton_nodes_with_selfloops" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_singleton_nodes_with_selfloops">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_singleton_nodes_with_selfloops</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph has singletons</p>
</div>


                            </div>
                            <div id="Graph.is_connected" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_connected">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_connected</span><span class="signature">(self, verbose: Union[bool, NoneType]) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph is connected.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar while computing the connected components, if necessary.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph is connected.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar while computing the connected components, if necessary.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph has node types</p>
</div>


                            </div>
                            <div id="Graph.has_multilabel_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_multilabel_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_multilabel_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_multilabel_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has multilabel node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if graph has multilabel node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_unknown_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_unknown_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_unknown_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there are unknown node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_known_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_known_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_known_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there are known node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_unknown_edge_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there are unknown edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_known_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_known_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_known_edge_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there are known edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_homogeneous_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_homogeneous_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_homogeneous_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_homogeneous_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the nodes have an homogenous node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the nodes have an homogenous node type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_homogeneous_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_homogeneous_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_homogeneous_edge_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_homogeneous_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the edges have an homogenous edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the edges have an homogenous edge type.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_singleton_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_singleton_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_singleton_node_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton node type, that is a node type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there is at least singleton node type, that is a node type that only appears once.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_oddities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_oddities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_oddities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node-related graph oddities&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether the graph has any known node-related graph oddities</p>
</div>


                            </div>
                            <div id="Graph.has_node_types_oddities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_types_oddities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_types_oddities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether the graph has any known node type-related graph oddities.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_singleton_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_singleton_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_singleton_edge_types</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton edge type, that is a edge type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether there is at least singleton edge type, that is a edge type that only appears once.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_types_oddities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_types_oddities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_types_oddities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known edge type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether the graph has any known edge type-related graph oddities.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_multigraph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_multigraph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_multigraph</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return if there are multiple edges between two node&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return if there are multiple edges between two node</p>
</div>


                            </div>
                            <div id="Graph.has_nodes_sorted_by_decreasing_outbound_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_nodes_sorted_by_decreasing_outbound_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the node IDs are sorted by decreasing outbound node degree.</p>
</div>


                            </div>
                            <div id="Graph.has_nodes_sorted_by_lexicographic_order" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_nodes_sorted_by_lexicographic_order">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_nodes_sorted_by_lexicographic_order</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the node IDs are sorted by decreasing outbound node degree.</p>
</div>


                            </div>
                            <div id="Graph.contains_identity_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.contains_identity_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">contains_identity_matrix</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">contains_identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph contains the indentity matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph contains the indentity matrix.</p>
</div>


                            </div>
                            <div id="Graph.has_nodes_sorted_by_increasing_outbound_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_nodes_sorted_by_increasing_outbound_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_nodes_sorted_by_increasing_outbound_node_degree</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by increasing outbound node degree.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the node IDs are sorted by increasing outbound node degree.</p>
</div>


                            </div>
                            <div id="Graph.get_total_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_total_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_total_edge_weights</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_total_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return total edge weights, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return total edge weights, if graph has weights.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_mininum_edge_weight" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_mininum_edge_weight">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_mininum_edge_weight</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_mininum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the minimum weight, if graph has weights.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_maximum_edge_weight" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_maximum_edge_weight">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_maximum_edge_weight</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_maximum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the maximum weight, if graph has weights.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_maximum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_maximum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_maximum_node_degree</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the maximum node degree.</p>

<h6 id="safety">Safety</h6>

<p>The method will return an undefined value (0) when the graph
does not contain nodes. In those cases the value is not properly
defined.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_minimum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_minimum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_minimum_node_degree</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the minimum node degree.</p>

<h6 id="safety">Safety</h6>

<p>The method will return an undefined value (0) when the graph
does not contain nodes. In those cases the value is not properly
defined.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_maximum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_maximum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_maximum_node_degree</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weighted node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the maximum weighted node degree</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_minimum_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_minimum_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_minimum_node_degree</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weighted node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the minimum weighted node degree</p>
</div>


                            </div>
                            <div id="Graph.get_number_of_weighted_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_weighted_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_weighted_singleton_nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero</p>
</div>


                            </div>
                            <div id="Graph.get_selfloops_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_selfloops_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_selfloops_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of self-loops, including also those in eventual multi-edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of self-loops, including also those in eventual multi-edges.</p>
</div>


                            </div>
                            <div id="Graph.get_unique_selfloops_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unique_selfloops_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unique_selfloops_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unique_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique self-loops, excluding those in eventual multi-edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of unique self-loops, excluding those in eventual multi-edges.</p>
</div>


                            </div>
                            <div id="Graph.overlaps" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.overlaps">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">overlaps</span><span class="signature">(self, other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether given graph has any edge overlapping with current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether given graph has any edge overlapping with current graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
The graph to check against.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If a graph is directed and the other is undirected.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge weights and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has node types and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge types and the other does not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">contains</span><span class="signature">(self, other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if given graph edges are all contained within current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return true if given graph edges are all contained within current graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
The graph to check against.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If a graph is directed and the other is undirected.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge weights and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has node types and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge types and the other does not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.sample_negatives" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.sample_negatives">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sample_negatives</span><span class="signature">(
    self,
    negatives_number: int,
    random_state: Union[int, NoneType],
    seed_graph: Union[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, NoneType],
    only_from_same_component: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sample_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negatives_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">seed_graph</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Graph</span><span class="p">],</span> <span class="n">only_from_same_component</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns Graph with given amount of negative edges as positive edges.</span>
<span class="sd">        </span>
<span class="sd">        The graph generated may be used as a testing negatives partition to be</span>
<span class="sd">        fed into the argument &quot;graph_to_avoid&quot; of the link_prediction or the</span>
<span class="sd">        skipgrams algorithm</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        negatives_number: int</span>
<span class="sd">            Number of negatives edges to include.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            random_state to use to reproduce negative edge set.</span>
<span class="sd">        seed_graph: Optional[Graph]</span>
<span class="sd">            Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.</span>
<span class="sd">        only_from_same_component: Optional[bool]</span>
<span class="sd">            Whether to sample negative edges only from nodes that are from the same component.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns Graph with given amount of negative edges as positive edges.</p>

<p>The graph generated may be used as a testing negatives partition to be
fed into the argument "graph_to_avoid" of the link_prediction or the
skipgrams algorithm</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>negatives_number</strong> (int):
Number of negatives edges to include.</li>
<li><strong>random_state</strong> (Optional[int]):
random_state to use to reproduce negative edge set.</li>
<li><strong>seed_graph</strong> (Optional[Graph]):
Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.</li>
<li><strong>only_from_same_component</strong> (Optional[bool]):
Whether to sample negative edges only from nodes that are from the same component.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.connected_holdout" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.connected_holdout">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">connected_holdout</span><span class="signature">(
    self,
    train_size: float,
    random_state: Union[int, NoneType],
    edge_types: Union[List[Union[str, NoneType]], NoneType],
    include_all_edge_types: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">connected_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns holdout for training ML algorithms on the graph structure.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. The first one, which</span>
<span class="sd">        is the training graph, is garanteed to have the same number of</span>
<span class="sd">        graph components as the initial graph. The second graph is the graph</span>
<span class="sd">        meant for testing or validation of the algorithm, and has no garantee</span>
<span class="sd">        to be connected. It will have at most (1-train_size) edges,</span>
<span class="sd">        as the bound of connectivity which is required for the training graph</span>
<span class="sd">        may lead to more edges being left into the training partition.</span>
<span class="sd">        </span>
<span class="sd">        In the option where a list of edge types has been provided, these</span>
<span class="sd">        edge types will be those put into the validation set.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            Rate target to reserve for training.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            Edge types to be selected for in the validation set.</span>
<span class="sd">        include_all_edge_types: Optional[bool]</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the required training size is not a real value between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph does not allow for the creation of a spanning tree for the requested training size.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns holdout for training ML algorithms on the graph structure.</p>

<p>The holdouts returned are a tuple of graphs. The first one, which
is the training graph, is garanteed to have the same number of
graph components as the initial graph. The second graph is the graph
meant for testing or validation of the algorithm, and has no garantee
to be connected. It will have at most (1-train_size) edges,
as the bound of connectivity which is required for the training graph
may lead to more edges being left into the training partition.</p>

<p>In the option where a list of edge types has been provided, these
edge types will be those put into the validation set.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
Rate target to reserve for training.</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
<li><strong>edge_types</strong> (Optional[List[Optional[str]]]):
Edge types to be selected for in the validation set.</li>
<li><strong>include_all_edge_types</strong> (Optional[bool]):
Whether to include all the edges between two nodes.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the edge types have been specified but the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the required training size is not a real value between 0 and 1.</li>
<li><strong>ValueError</strong>: If the current graph does not allow for the creation of a spanning tree for the requested training size.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.random_holdout" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.random_holdout">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">random_holdout</span><span class="signature">(
    self,
    train_size: float,
    random_state: Union[int, NoneType],
    include_all_edge_types: Union[bool, NoneType],
    edge_types: Union[List[Union[str, NoneType]], NoneType],
    min_number_overlaps: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_number_overlaps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns random holdout for training ML algorithms on the graph edges.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. In neither holdouts the</span>
<span class="sd">        graph connectivity is necessarily preserved. To maintain that, use</span>
<span class="sd">        the method `connected_holdout`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        include_all_edge_types: Optional[bool]</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The edges to include in validation set.</span>
<span class="sd">        min_number_overlaps: Optional[int]</span>
<span class="sd">            The minimum number of overlaps to include the edge into the validation set.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the minimum number of overlaps have been specified but the graph is not a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one or more of the given edge type names is not present in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns random holdout for training ML algorithms on the graph edges.</p>

<p>The holdouts returned are a tuple of graphs. In neither holdouts the
graph connectivity is necessarily preserved. To maintain that, use
the method <code><a href="#Graph.connected_holdout">connected_holdout</a></code>.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
<li><strong>include_all_edge_types</strong> (Optional[bool]):
Whether to include all the edges between two nodes.</li>
<li><strong>edge_types</strong> (Optional[List[Optional[str]]]):
The edges to include in validation set.</li>
<li><strong>min_number_overlaps</strong> (Optional[int]):
The minimum number of overlaps to include the edge into the validation set.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the edge types have been specified but the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the minimum number of overlaps have been specified but the graph is not a multigraph.</li>
<li><strong>ValueError</strong>: If one or more of the given edge type names is not present in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_holdout_indices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_holdout_indices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_holdout_indices</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[List[int], List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_holdout_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node-label holdout indices for training ML algorithms on the graph node labels.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use node-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a single node type.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a multilabel node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_holdout_labels" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_holdout_labels">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_holdout_labels</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[List[Union[List[int], NoneType]], List[Union[List[int], NoneType]]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_holdout_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node-label holdout indices for training ML algorithms on the graph node labels.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use node-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a single node type.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a multilabel node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_holdout_graphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_holdout_graphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_holdout_graphs</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node-label holdout for training ML algorithms on the graph node labels.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use node-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a single node type.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a multilabel node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_label_holdout_graphs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_label_holdout_graphs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_label_holdout_graphs</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge-label holdout for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>

<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <code>train_size</code> argument.</p>

<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use edge-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If stratification is required but the graph has singleton edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_random_subgraph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_random_subgraph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_random_subgraph</span><span class="signature">(
    self,
    number_of_nodes: int,
    random_state: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns subgraph with given number of nodes.</span>
<span class="sd">        </span>
<span class="sd">        **This method creates a subset of the graph starting from a random node</span>
<span class="sd">        sampled using given random_state and includes all neighbouring nodes until</span>
<span class="sd">        the required number of nodes is reached**. All the edges connecting any</span>
<span class="sd">        of the selected nodes are then inserted into this graph.</span>
<span class="sd">        </span>
<span class="sd">        This is meant to execute distributed node embeddings.</span>
<span class="sd">        It may also sample singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes: int</span>
<span class="sd">            Number of nodes to extract.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            Random random_state to use.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested number of nodes is one or less.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has less than the requested number of nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns subgraph with given number of nodes.</p>

<p><strong>This method creates a subset of the graph starting from a random node
sampled using given random_state and includes all neighbouring nodes until
the required number of nodes is reached</strong>. All the edges connecting any
of the selected nodes are then inserted into this graph.</p>

<p>This is meant to execute distributed node embeddings.
It may also sample singleton nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes</strong> (int):
Number of nodes to extract.</li>
<li><strong>random_state</strong> (Optional[int]):
Random random_state to use.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the requested number of nodes is one or less.</li>
<li><strong>ValueError</strong>: If the graph has less than the requested number of nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_random_holdout" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_random_holdout">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_random_holdout</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node-label holdout for training ML algorithms on the graph node labels.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use node-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a single node type.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a multilabel node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_kfold" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_kfold">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_kfold</span><span class="signature">(
    self,
    k: int,
    k_index: int,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label fold for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node-label fold for training ML algorithms on the graph node labels.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
The number of folds.</li>
<li><strong>k_index</strong> (int):
Which fold to use for the validation.</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use node-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a single node type.</li>
<li><strong>ValueError</strong>: If stratification is requested but the graph has a multilabel node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_label_random_holdout" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_label_random_holdout">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_label_random_holdout</span><span class="signature">(
    self,
    train_size: float,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge-label holdout for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>

<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <code>train_size</code> argument.</p>

<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_size</strong> (float):
rate target to reserve for training,</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use edge-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If stratification is required but the graph has singleton edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_label_kfold" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_label_kfold">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_label_kfold</span><span class="signature">(
    self,
    k: int,
    k_index: int,
    use_stratification: Union[bool, NoneType],
    random_state: Union[int, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label kfold for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool]</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge-label kfold for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>

<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <code>train_size</code> argument.</p>

<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
The number of folds.</li>
<li><strong>k_index</strong> (int):
Which fold to use for the validation.</li>
<li><strong>use_stratification</strong> (Optional[bool]):
Whether to use edge-label stratification,</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If stratification is required but the graph has singleton edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_prediction_kfold" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_prediction_kfold">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_prediction_kfold</span><span class="signature">(
    self,
    k: int,
    k_index: int,
    edge_types: Union[List[Union[str, NoneType]], NoneType],
    random_state: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; Tuple[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_prediction_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns train and test graph following kfold validation scheme.</span>
<span class="sd">        </span>
<span class="sd">        The edges are splitted into k chunks. The k_index-th chunk is used to build</span>
<span class="sd">        the validation graph, all the other edges create the training graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state (seed) to use for the holdout,</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested k folds is one or zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given k fold index is greater than the number of k folds.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types have been specified but it&#39;s an empty list.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of k folds is higher than the number of edges in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns train and test graph following kfold validation scheme.</p>

<p>The edges are splitted into k chunks. The k_index-th chunk is used to build
the validation graph, all the other edges create the training graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
The number of folds.</li>
<li><strong>k_index</strong> (int):
Which fold to use for the validation.</li>
<li><strong>edge_types</strong> (Optional[List[Optional[str]]]):
Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).</li>
<li><strong>random_state</strong> (Optional[int]):
The random_state (seed) to use for the holdout,</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the number of requested k folds is one or zero.</li>
<li><strong>ValueError</strong>: If the given k fold index is greater than the number of k folds.</li>
<li><strong>ValueError</strong>: If edge types have been specified but it's an empty list.</li>
<li><strong>ValueError</strong>: If the number of k folds is higher than the number of edges in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_laplacian_transformed_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_laplacian_transformed_graph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_laplacian_transformed_graph</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted laplacian transformation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted laplacian transformation of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_laplacian_coo_matrix_edges_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_laplacian_coo_matrix_edges_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_laplacian_coo_matrix_edges_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_laplacian_coo_matrix_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges in the laplacian COO matrix representation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of edges in the laplacian COO matrix representation of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_random_walk_normalized_laplacian_transformed_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_random_walk_normalized_laplacian_transformed_graph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_random_walk_normalized_laplacian_transformed_graph</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_random_walk_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted random walk normalized laplacian transformation of the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted random walk normalized laplacian transformation of the graph</p>
</div>


                            </div>
                            <div id="Graph.get_symmetric_normalized_laplacian_transformed_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_symmetric_normalized_laplacian_transformed_graph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_symmetric_normalized_laplacian_transformed_graph</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized laplacian transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted symmetric normalized laplacian transformation of the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: The graph must be undirected, as we do not currently support this transformation for directed graphs.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_symmetric_normalized_transformed_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_symmetric_normalized_transformed_graph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_symmetric_normalized_transformed_graph</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unweighted symmetric normalized transformation of the graph.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: The graph must be undirected, as we do not currently support this transformation for directed graphs.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_undirected_louvain_community_detection" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_undirected_louvain_community_detection">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_undirected_louvain_community_detection</span><span class="signature">(
    self,
    recursion_minimum_improvement: Union[float, NoneType],
    first_phase_minimum_improvement: Union[float, NoneType],
    patience: Union[int, NoneType],
    random_state: Union[int, NoneType]
) -&gt; List[List[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_undirected_louvain_community_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursion_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">first_phase_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">patience</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recursion_minimum_improvement: Optional[float]</span>
<span class="sd">            The minimum improvement to warrant another resursion round. By default, zero.</span>
<span class="sd">        first_phase_minimum_improvement: Optional[float]</span>
<span class="sd">            The minimum improvement to warrant another first phase iteration. By default, `0.00001` (not zero because of numerical instability).</span>
<span class="sd">        patience: Optional[int]</span>
<span class="sd">            How many iterations of the first phase to wait for before stopping. By default, `5`.</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random state to use to reproduce this modularity computation. By default, 42.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `recursion_minimum_improvement` has an invalid value, i.e. NaN or infinity.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `first_phase_minimum_improvement` has an invalid value, i.e. NaN or infinity.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>recursion_minimum_improvement</strong> (Optional[float]):
The minimum improvement to warrant another resursion round. By default, zero.</li>
<li><strong>first_phase_minimum_improvement</strong> (Optional[float]):
The minimum improvement to warrant another first phase iteration. By default, <code>0.00001</code> (not zero because of numerical instability).</li>
<li><strong>patience</strong> (Optional[int]):
How many iterations of the first phase to wait for before stopping. By default, <code>5</code>.</li>
<li><strong>random_state</strong> (Optional[int]):
The random state to use to reproduce this modularity computation. By default, 42.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is not directed.</li>
<li><strong>ValueError</strong>: If the <code>recursion_minimum_improvement</code> has an invalid value, i.e. NaN or infinity.</li>
<li><strong>ValueError</strong>: If the <code>first_phase_minimum_improvement</code> has an invalid value, i.e. NaN or infinity.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_directed_modularity_from_node_community_memberships" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_directed_modularity_from_node_community_memberships">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_directed_modularity_from_node_community_memberships</span><span class="signature">(self, node_community_memberships: List[int]) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_directed_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_community_memberships</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the directed modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the directed modularity of the graph from the given memberships.</p>

<h6 id="parameters">Parameters</h6>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the number of provided memberships does not match the number of nodes of the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_undirected_modularity_from_node_community_memberships" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_undirected_modularity_from_node_community_memberships">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_undirected_modularity_from_node_community_memberships</span><span class="signature">(self, node_community_memberships: List[int]) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_undirected_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_community_memberships</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the undirected modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the undirected modularity of the graph from the given memberships.</p>

<h6 id="parameters">Parameters</h6>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the number of provided memberships does not match the number of nodes of the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_memory_stats" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_memory_stats">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_memory_stats</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_memory_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a string describing the memory usage of all the fields of all the</span>
<span class="sd">        structures used to store the current graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a string describing the memory usage of all the fields of all the
structures used to store the current graph</p>
</div>


                            </div>
                            <div id="Graph.get_total_memory_used" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_total_memory_used">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_total_memory_used</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_total_memory_used</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the given graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the given graph</p>
</div>


                            </div>
                            <div id="Graph.get_nodes_total_memory_requirement" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_nodes_total_memory_requirement">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_nodes_total_memory_requirement</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the nodes</p>
</div>


                            </div>
                            <div id="Graph.get_nodes_total_memory_requirement_human_readable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_nodes_total_memory_requirement_human_readable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_nodes_total_memory_requirement_human_readable</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the nodes&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns human readable amount of how many bytes are currently used to store the nodes</p>
</div>


                            </div>
                            <div id="Graph.get_edges_total_memory_requirement" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edges_total_memory_requirement">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edges_total_memory_requirement</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the edges</p>
</div>


                            </div>
                            <div id="Graph.get_edges_total_memory_requirement_human_readable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edges_total_memory_requirement_human_readable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edges_total_memory_requirement_human_readable</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edges&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns human readable amount of how many bytes are currently used to store the edges</p>
</div>


                            </div>
                            <div id="Graph.get_edge_weights_total_memory_requirements" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weights_total_memory_requirements">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weights_total_memory_requirements</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the edge weights</p>
</div>


                            </div>
                            <div id="Graph.get_edge_weights_total_memory_requirements_human_readable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weights_total_memory_requirements_human_readable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weights_total_memory_requirements_human_readable</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns human readable amount of how many bytes are currently used to store the edge weights</p>
</div>


                            </div>
                            <div id="Graph.get_node_types_total_memory_requirements" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_types_total_memory_requirements">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_types_total_memory_requirements</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the node types</p>
</div>


                            </div>
                            <div id="Graph.get_node_types_total_memory_requirements_human_readable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_types_total_memory_requirements_human_readable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_types_total_memory_requirements_human_readable</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the node types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns human readable amount of how many bytes are currently used to store the node types</p>
</div>


                            </div>
                            <div id="Graph.get_edge_types_total_memory_requirements" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_types_total_memory_requirements">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_types_total_memory_requirements</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many bytes are currently used to store the edge types</p>
</div>


                            </div>
                            <div id="Graph.get_edge_types_total_memory_requirements_human_readable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_types_total_memory_requirements_human_readable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_types_total_memory_requirements_human_readable</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge types&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns human readable amount of how many bytes are currently used to store the edge types</p>
</div>


                            </div>
                            <div id="Graph.enable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.enable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">enable</span><span class="signature">(
    self,
    vector_sources: Union[bool, NoneType],
    vector_destinations: Union[bool, NoneType],
    vector_cumulative_node_degrees: Union[bool, NoneType],
    vector_reciprocal_sqrt_degrees: Union[bool, NoneType]
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_destinations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_cumulative_node_degrees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_reciprocal_sqrt_degrees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Enable extra perks that buys you time as you accept to spend more memory.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_sources: Optional[bool]</span>
<span class="sd">            Whether to cache sources into a vector for faster walks.</span>
<span class="sd">        vector_destinations: Optional[bool]</span>
<span class="sd">            Whether to cache destinations into a vector for faster walks.</span>
<span class="sd">        vector_cumulative_node_degrees: Optional[bool]</span>
<span class="sd">            Whether to cache cumulative_node_degrees into a vector for faster walks.</span>
<span class="sd">        vector_reciprocal_sqrt_degrees: Optional[bool]</span>
<span class="sd">            Whether to cache reciprocal_sqrt_degrees into a vector for faster laplacian kernel computation.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Enable extra perks that buys you time as you accept to spend more memory.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vector_sources</strong> (Optional[bool]):
Whether to cache sources into a vector for faster walks.</li>
<li><strong>vector_destinations</strong> (Optional[bool]):
Whether to cache destinations into a vector for faster walks.</li>
<li><strong>vector_cumulative_node_degrees</strong> (Optional[bool]):
Whether to cache cumulative_node_degrees into a vector for faster walks.</li>
<li><strong>vector_reciprocal_sqrt_degrees</strong> (Optional[bool]):
Whether to cache reciprocal_sqrt_degrees into a vector for faster laplacian kernel computation.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_random_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_random_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_random_nodes</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return random unique sorted numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return random unique sorted numbers.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to use to reproduce the sampling.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_breadth_first_search_random_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_breadth_first_search_random_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_breadth_first_search_random_nodes</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    root_node: int
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_breadth_first_search_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return nodes sampled from the neighbourhood of given root nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        root_node: int</span>
<span class="sd">            The root node from .</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested nodes is higher than the number of nodes in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node does not exist in the curret graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return nodes sampled from the neighbourhood of given root nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>root_node</strong> (int):
The root node from .</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the number of requested nodes is higher than the number of nodes in the graph.</li>
<li><strong>ValueError</strong>: If the given root node does not exist in the curret graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_uniform_random_walk_random_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_uniform_random_walk_random_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_uniform_random_walk_random_nodes</span><span class="signature">(
    self,
    node: int,
    random_state: int,
    walk_length: int,
    unique: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_uniform_random_walk_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns unique nodes sampled from uniform random walk.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: int</span>
<span class="sd">            Node from where to start the random walks.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            the random_state to use for extracting the nodes and edges.</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Length of the random walk.</span>
<span class="sd">        unique: Optional[bool]</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node does not exist in the current slack.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns unique nodes sampled from uniform random walk.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node</strong> (int):
Node from where to start the random walks.</li>
<li><strong>random_state</strong> (int):
the random_state to use for extracting the nodes and edges.</li>
<li><strong>walk_length</strong> (int):
Length of the random walk.</li>
<li><strong>unique</strong> (Optional[bool]):
Whether to make the sampled nodes unique.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node does not exist in the current slack.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_sampling_methods" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_sampling_methods">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_sampling_methods</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_sampling_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported node sampling methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return list of the supported node sampling methods</p>
</div>


                            </div>
                            <div id="Graph.get_subsampled_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_subsampled_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_subsampled_nodes</span><span class="signature">(
    self,
    number_of_nodes_to_sample: int,
    random_state: int,
    root_node: Union[int, NoneType],
    node_sampling_method: str,
    unique: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_subsampled_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int]</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        unique: Optional[bool]</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return subsampled nodes according to the given method and parameters.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>number_of_nodes_to_sample</strong> (int):
The number of nodes to sample.</li>
<li><strong>random_state</strong> (int):
The random state to reproduce the sampling.</li>
<li><strong>root_node</strong> (Optional[int]):
The (optional) root node to use to sample. In not provided, a random one is sampled.</li>
<li><strong>node_sampling_method</strong> (str):
The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</li>
<li><strong>unique</strong> (Optional[bool]):
Whether to make the sampled nodes unique.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node sampling method is not supported.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_compatible" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_compatible">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_compatible</span><span class="signature">(self, other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs are compatible.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The other graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return true if the graphs are compatible.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
The other graph.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If a graph is directed and the other is undirected.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge weights and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has node types and the other does not.</li>
<li><strong>ValueError</strong>: If one of the two graphs has edge types and the other does not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_same_adjacency_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_same_adjacency_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_same_adjacency_matrix</span><span class="signature">(self, other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_same_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs share the same adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The other graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return true if the graphs share the same adjacency matrix.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
The other graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_node_id</span><span class="signature">(self, node_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
node ID to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_node_ids</span><span class="signature">(self, node_ids: List[int]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates all provided node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            node IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates all provided node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids</strong> (List[int]):
node IDs to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given node ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_edge_id</span><span class="signature">(self, edge_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            Edge ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
Edge ID to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given edge ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_edge_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_edge_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_edge_ids</span><span class="signature">(self, edge_ids: List[int]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_edge_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_ids: List[int]</span>
<span class="sd">            Edge IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given edge ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided edge IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_ids</strong> (List[int]):
Edge IDs to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If any of the given edge ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_not_contain_unknown_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_not_contain_unknown_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_not_contain_unknown_node_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_not_contain_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph contains unknown node types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain node types.</li>
<li><strong>ValueError</strong>: If the graph contains unknown node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_not_contain_unknown_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_not_contain_unknown_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_not_contain_unknown_edge_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_not_contain_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph contains unknown edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not contain edge types.</li>
<li><strong>ValueError</strong>: If the graph contains unknown edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_node_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_node_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_node_type_id</span><span class="signature">(self, node_type_id: Union[int, NoneType]) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int]</span>
<span class="sd">            Node type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided node type ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id</strong> (Optional[int]):
Node type ID to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_node_type_ids</span><span class="signature">(
    self,
    node_type_ids: List[Union[int, NoneType]]
) -&gt; List[Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[Optional[int]]</span>
<span class="sd">            Vector of node type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided node type IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_ids</strong> (List[Optional[int]]):
Vector of node type IDs to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no node types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_edge_type_id</span><span class="signature">(self, edge_type_id: Union[int, NoneType]) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            edge type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided edge type ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (Optional[int]):
edge type ID to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given edge type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.validate_edge_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.validate_edge_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">validate_edge_type_ids</span><span class="signature">(
    self,
    edge_type_ids: List[Union[int, NoneType]]
) -&gt; List[Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">validate_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_ids: List[Optional[int]]</span>
<span class="sd">            Vector of edge type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Validates provided edge type IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_ids</strong> (List[Optional[int]]):
Vector of edge type IDs to validate.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If there are no edge types in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_be_undirected" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_be_undirected">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_be_undirected</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_be_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph does not have edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is directed.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_be_multigraph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_be_multigraph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_be_multigraph</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph does not have edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is not a multigraph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_not_be_multigraph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_not_be_multigraph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_not_be_multigraph</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_not_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph does not have edge types.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is a multigraph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_contain_identity_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_contain_identity_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_contain_identity_matrix</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_contain_identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not include the identity matrix.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph does not include the identity matrix.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is a multigraph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_not_contain_weighted_singleton_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_not_contain_weighted_singleton_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_not_contain_weighted_singleton_nodes</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_not_contain_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains zero weighted degree.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph contains zero weighted degree.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_have_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_have_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_have_edges</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_have_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph has a maximal weighted</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph has a maximal weighted</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_have_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_have_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_have_nodes</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_have_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have any node.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph does not have any node.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.must_be_connected" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.must_be_connected">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">must_be_connected</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">must_be_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph is not connected.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not connected.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Raises an error if the graph is not connected.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is not connected.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_number_of_triangles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_triangles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_triangles</span><span class="signature">(
    self,
    normalize: Union[bool, NoneType],
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triangles ignoring the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns total number of triangles ignoring the weights.</p>

<p>The method dispatches the fastest method according to the current
graph instance. Specifically:</p>

<ul>
<li>For directed graphs it will use the naive algorithm.</li>
<li>For undirected graphs it will use Bader's version.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>normalize</strong> (Optional[bool]):
Whether to normalize the number of triangles.</li>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_triads_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_triads_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_triads_number</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the graph without taking into account weights&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns total number of triads in the graph without taking into account weights</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_triads_number" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_triads_number">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_triads_number</span><span class="signature">(self) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the weighted graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns total number of triads in the weighted graph</p>
</div>


                            </div>
                            <div id="Graph.get_transitivity" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_transitivity">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_transitivity</span><span class="signature">(
    self,
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns transitivity of the graph without taking into account weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns transitivity of the graph without taking into account weights.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_number_of_triangles_per_node" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_number_of_triangles_per_node">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_number_of_triangles_per_node</span><span class="signature">(
    self,
    normalize: Union[bool, NoneType],
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_number_of_triangles_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of triangles in the graph without taking into account the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool]</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns number of triangles in the graph without taking into account the weights.</p>

<p>The method dispatches the fastest method according to the current
graph instance. Specifically:</p>

<ul>
<li>For directed graphs it will use the naive algorithm.</li>
<li>For undirected graphs it will use Bader's version.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>normalize</strong> (Optional[bool]):
Whether to normalize the number of triangles.</li>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_clustering_coefficient_per_node" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_clustering_coefficient_per_node">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_clustering_coefficient_per_node</span><span class="signature">(
    self,
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_clustering_coefficient_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns clustering coefficients for all nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns clustering coefficients for all nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_clustering_coefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_clustering_coefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_clustering_coefficient</span><span class="signature">(
    self,
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the graph clustering coefficient.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_average_clustering_coefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_average_clustering_coefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_average_clustering_coefficient</span><span class="signature">(
    self,
    low_centrality: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_average_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph average clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int]</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the graph average clustering coefficient.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>low_centrality</strong> (Optional[int]):
The threshold over which to switch to parallel matryoshka. By default 50.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_okapi_bm25_node_feature_propagation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_okapi_bm25_node_feature_propagation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_okapi_bm25_node_feature_propagation</span><span class="signature">(
    self,
    features: List[List[float]],
    iterations: Union[int, NoneType],
    maximal_distance: Union[int, NoneType],
    k1: Union[float, NoneType],
    b: Union[float, NoneType],
    include_central_node: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_feature_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">include_central_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node features propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[Optional[List[float]]]</span>
<span class="sd">            The features to propagate. Use None to represent eventual unknown features.</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int]</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float]</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float]</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        include_central_node: Optional[bool]</span>
<span class="sd">            Whether to include the central node. By default true.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns okapi node features propagation within given maximal distance.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>features</strong> (List[Optional[List[float]]]):
The features to propagate. Use None to represent eventual unknown features.</li>
<li><strong>iterations</strong> (Optional[int]):
The number of iterations to execute. By default one.</li>
<li><strong>maximal_distance</strong> (Optional[int]):
The distance to consider for the cooccurrences. The default value is 3.</li>
<li><strong>k1</strong> (Optional[float]):
The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</li>
<li><strong>b</strong> (Optional[float]):
The b parameter from okapi. Tipicaly 0.75.</li>
<li><strong>include_central_node</strong> (Optional[bool]):
Whether to include the central node. By default true.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_okapi_bm25_node_label_propagation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_okapi_bm25_node_label_propagation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_okapi_bm25_node_label_propagation</span><span class="signature">(
    self,
    iterations: Union[int, NoneType],
    maximal_distance: Union[int, NoneType],
    k1: Union[float, NoneType],
    b: Union[float, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_label_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node label propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int]</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float]</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float]</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns okapi node label propagation within given maximal distance.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>iterations</strong> (Optional[int]):
The number of iterations to execute. By default one.</li>
<li><strong>maximal_distance</strong> (Optional[int]):
The distance to consider for the cooccurrences. The default value is 3.</li>
<li><strong>k1</strong> (Optional[float]):
The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</li>
<li><strong>b</strong> (Optional[float]):
The b parameter from okapi. Tipicaly 0.75.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show loading bar.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_weight_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_weight_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_weight_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Union[float, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given edge ID is higher than</span>
<span class="sd">        the number of edges in the graph. Additionally, it will simply</span>
<span class="sd">        return None if there are no graph weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge whose edge weight is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns option with the weight of the given edge id.</p>

<p>This method will raise a panic if the given edge ID is higher than
the number of edges in the graph. Additionally, it will simply
return None if there are no graph weights.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge whose edge weight is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_weight_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_weight_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_weight_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given node IDs are higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the two given node IDs does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns option with the weight of the given node ids.</p>

<p>This method will raise a panic if the given node IDs are higher than
the number of nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The source node ID.</li>
<li><strong>dst</strong> (int):
The destination node ID.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If either of the two given node IDs does not exists in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_id_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_id_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_id_from_node_name</span><span class="signature">(self, node_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns node id from given node name raising a panic if used unproperly.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node id from given node name raising a panic if used unproperly.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name whose node ID is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node name does not exists in the considered graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_type_id_from_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_type_id_from_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_type_id_from_edge_type_name</span><span class="signature">(self, edge_type_name: str) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type name whose edge type ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge type ID corresponding to the given edge type name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (str):
The edge type name whose edge type ID is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge type name does not exists in the considered graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_type_name_from_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_type_name_from_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_type_name_from_edge_type_id</span><span class="signature">(self, edge_type_id: Union[int, NoneType]) -&gt; Union[str, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name</span>
<span class="sd">        raising panic if edge type ID does not exists in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            The edge type naIDme whose edge type name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge type ID corresponding to the given edge type name
raising panic if edge type ID does not exists in current graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (Optional[int]):
The edge type naIDme whose edge type name is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge type ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_count_from_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_count_from_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_count_from_edge_type_id</span><span class="signature">(self, edge_type: Union[int, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges of the given edge type without checks.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The edge type to retrieve count of.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of edges of the given edge type without checks.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type</strong> (Optional[int]):
The edge type to retrieve count of.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge type ID does not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_id_from_node_ids_and_edge_type_id</span><span class="signature">(self, src: int, dst: int, edge_type: Union[int, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID without any checks for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            Edge Type of the edge.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs or edge type does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge ID without any checks for given tuple of nodes and edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Source node of the edge.</li>
<li><strong>dst</strong> (int):
Destination node of the edge.</li>
<li><strong>edge_type</strong> (Optional[int]):
Edge Type of the edge.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node IDs or edge type does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_minmax_edge_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_minmax_edge_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_minmax_edge_ids_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node type IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return range of outbound edges IDs for all the edges bewteen the given
source and destination nodes.
This operation is meaningfull only in a multigraph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Source node.</li>
<li><strong>dst</strong> (int):
Destination node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node type IDs do not exist in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_ids_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_ids_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_ids_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given edge ID does not exists in the</span>
<span class="sd">        current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node IDs corresponding to given edge ID.</p>

<p>The method will panic if the given edge ID does not exists in the
current graph instance.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source and destination node IDs are to e retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_names_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_names_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_names_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[str, str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node names corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source and destination node IDs are to e retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_source_node_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_source_node_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_source_node_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the source of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the source of given edge id without making any boundary check.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source is to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will cause an out of bounds.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_destination_node_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_destination_node_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_destination_node_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the destination of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the destination of given edge id without making any boundary check.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose destination is to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will cause an out of bounds.</p>
</div>


                            </div>
                            <div id="Graph.get_source_node_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_source_node_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_source_node_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns source node ID corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source node ID is to be retrieved.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given edge ID does not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_destination_node_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_destination_node_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_destination_node_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns destination node ID corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose destination node ID is to be retrieved.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given edge ID does not exist in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_source_node_name_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_source_node_name_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_source_node_name_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns source node name corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source node name is to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_destination_node_name_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_destination_node_name_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_destination_node_name_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns destination node name corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose destination node name is to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_source_node_name_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_source_node_name_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_source_node_name_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns source node name corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source node name is to be retrieved.</li>
<li><strong>Raises</strong></li>
</ul>

<hr />
</div>


                            </div>
                            <div id="Graph.get_destination_node_name_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_destination_node_name_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_destination_node_name_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns destination node name corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose destination node name is to be retrieved.</li>
<li><strong>Raises</strong></li>
</ul>

<hr />
</div>


                            </div>
                            <div id="Graph.get_node_names_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_names_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_names_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[str, str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node names corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source and destination node IDs are to e retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node names corresponding to given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source and destination node IDs are to e retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_id_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_id_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_id_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source and destination node IDs do</span>
<span class="sd">        not correspond to an edge in this graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs do not exist in the graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge ID corresponding to given source and destination node IDs.</p>

<p>The method will panic if the given source and destination node IDs do
not correspond to an edge in this graph instance.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The source node ID.</li>
<li><strong>dst</strong> (int):
The destination node ID.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If any of the given node IDs do not exist in the graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_edge_id_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_id_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_id_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge ID corresponding to given source and destination node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The source node ID.</li>
<li><strong>dst</strong> (int):
The destination node ID.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_unique_source_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_unique_source_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_unique_source_node_id</span><span class="signature">(self, source_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_unique_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_id: int</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given source node ID does not exist in the current graph the method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge ID corresponding to given source and destination node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_id</strong> (int):
The source node ID.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given source node ID does not exist in the current graph the method will panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_ids_and_edge_type_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[int, int, Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the src, dst, edge type of a given edge ID.</p>

<p>This method will raise a panic when an improper configuration is used.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source, destination and edge type are to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_node_ids_and_edge_type_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_and_edge_type_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_and_edge_type_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Tuple[int, int, Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the src, dst, edge type of a given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source, destination and edge type are to be retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="signature">(
    self,
    edge_id: int
) -&gt; Tuple[int, int, Union[int, NoneType], Union[float, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the src, dst, edge type and weight of a given edge ID.</p>

<p>This method will raise a panic when an improper configuration is used.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source, destination, edge type and weight are to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="signature">(
    self,
    edge_id: int
) -&gt; Tuple[int, int, Union[int, NoneType], Union[float, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the src, dst, edge type and weight of a given edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose source, destination, edge type and weight are to be retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_top_k_central_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_top_k_central_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_top_k_central_node_ids</span><span class="signature">(self, k: int) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with unweighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has no nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with unweighted top k central node Ids.</p>

<p>If the k passed is bigger than the number of nodes this method will return
all the nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
Number of central nodes to extract.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given value k is zero.</li>
<li><strong>ValueError</strong>: If the graph has no nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_top_k_central_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_top_k_central_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_top_k_central_node_ids</span><span class="signature">(self, k: int) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with weighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph instance does not contain edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with weighted top k central node Ids.</p>

<p>If the k passed is bigger than the number of nodes this method will return
all the nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
Number of central nodes to extract.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the current graph instance does not contain edge weights.</li>
<li><strong>ValueError</strong>: If the given value k is zero.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of outbound neighbours of given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_unchecked_weighted_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_weighted_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_weighted_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given node id is higher than the number of</span>
<span class="sd">        nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted sum of outbound neighbours of given node.</p>

<p>The method will panic if the given node id is higher than the number of
nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of outbound neighbours of given node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_comulative_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_comulative_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_comulative_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the comulative node degree up to the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_comulative_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_comulative_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_comulative_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the comulative node degree up to the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_reciprocal_sqrt_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_reciprocal_sqrt_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_reciprocal_sqrt_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_reciprocal_sqrt_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the reciprocal squared root node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the reciprocal squared root node degree up to the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_reciprocal_sqrt_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_reciprocal_sqrt_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_reciprocal_sqrt_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_reciprocal_sqrt_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the reciprocal squared root node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the reciprocal squared root node degree up to the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_reciprocal_sqrt_degrees_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_reciprocal_sqrt_degrees_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_reciprocal_sqrt_degrees_from_node_ids</span><span class="signature">(self, node_ids: List[int]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_reciprocal_sqrt_degrees_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with reciprocal squared root degree of the provided nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The vector of node IDs whose reciprocal squared root degree is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method makes the assumption that the provided node IDs exist in the graph, that is</span>
<span class="sd">         they are not higher than the number of nodes in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with reciprocal squared root degree of the provided nodes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids</strong> (List[int]):
The vector of node IDs whose reciprocal squared root degree is to be retrieved.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>This method makes the assumption that the provided node IDs exist in the graph, that is
 they are not higher than the number of nodes in the graph.</p>
</div>


                            </div>
                            <div id="Graph.get_weighted_node_degree_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_node_degree_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_node_degree_from_node_id</span><span class="signature">(self, node_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the weighted sum of outbound neighbours of given node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_degree_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_degree_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_degree_from_node_name</span><span class="signature">(self, node_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_degree_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of outbound neighbours of given node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Integer ID of the node.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node name does not exist in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_top_k_central_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_top_k_central_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_top_k_central_node_names</span><span class="signature">(self, k: int) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_top_k_central_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector with top k central node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int</span>
<span class="sd">            Number of central nodes to extract.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector with top k central node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int):
Number of central nodes to extract.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_type_id_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_type_id_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_type_id_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Union[List[int], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with vector of node types of given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID is greater than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have node types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node whose node type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        Even though the method will return an option when the node types are</span>
<span class="sd">         not available for the current graph, the behaviour is undefined.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns option with vector of node types of given node.</p>

<p>This method will panic if the given node ID is greater than
the number of nodes in the graph.
Furthermore, if the graph does NOT have node types, it will NOT
return neither an error or a panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
node whose node type is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>Even though the method will return an option when the node types are
 not available for the current graph, the behaviour is undefined.</p>
</div>


                            </div>
                            <div id="Graph.get_node_type_ids_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_ids_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_ids_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Union[List[int], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns node type of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            node whose node type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns node type of given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
node whose node type is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_type_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_type_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_type_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given edge ID is greater than</span>
<span class="sd">        the number of edges in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have edge types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            edge whose edge type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge type of given edge.</p>

<p>This method will panic if the given edge ID is greater than
the number of edges in the graph.
Furthermore, if the graph does NOT have edge types, it will NOT
return neither an error or a panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
edge whose edge type is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_edge_type_id_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_id_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_id_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            edge whose edge type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns edge type of given edge.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
edge whose edge type is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_type_names_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_type_names_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_type_names_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Union[List[str], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will return an iterator of None values when the graph</span>
<span class="sd">         does not contain node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result of option with the node type of the given node id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose node types are to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>This method will return an iterator of None values when the graph
 does not contain node types.</p>
</div>


                            </div>
                            <div id="Graph.get_node_type_names_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_names_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_names_from_node_id</span><span class="signature">(self, node_id: int) -&gt; Union[List[str], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node types are not available for the current graph instance.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result of option with the node type of the given node id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose node types are to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the node types are not available for the current graph instance.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_names_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_names_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_names_from_node_name</span><span class="signature">(self, node_name: str) -&gt; Union[List[str], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node types are to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result of option with the node type of the given node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name whose node types are to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_type_name_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_name_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_name_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; Union[str, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the edge type of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose edge type is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns option with the edge type of the given edge id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose edge type is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_type_name_from_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_name_from_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_name_from_edge_type_id</span><span class="signature">(self, edge_type_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type name of given edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            Id of the edge type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge type name of given edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (int):
Id of the edge type.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_weight_from_edge_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weight_from_edge_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weight_from_edge_id</span><span class="signature">(self, edge_id: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int</span>
<span class="sd">            The edge ID whose weight is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weight of the given edge id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_id</strong> (int):
The edge ID whose weight is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_weight_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weight_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weight_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The node ID of the destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weight of the given node ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The node ID of the source node.</li>
<li><strong>dst</strong> (int):
The node ID of the destination node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_weight_from_node_ids_and_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weight_from_node_ids_and_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weight_from_node_ids_and_edge_type_id</span><span class="signature">(self, src: int, dst: int, edge_type: Union[int, NoneType]) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The node ID of the destination node.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The edge type ID of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weight of the given node ids and edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The node ID of the source node.</li>
<li><strong>dst</strong> (int):
The node ID of the destination node.</li>
<li><strong>edge_type</strong> (Optional[int]):
The edge type ID of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_weight_from_node_names_and_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weight_from_node_names_and_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weight_from_node_names_and_edge_type_name</span><span class="signature">(self, src: str, dst: str, edge_type: Union[str, NoneType]) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: str</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst: str</span>
<span class="sd">            The node name of the destination node.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The edge type name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weight of the given node names and edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (str):
The node name of the source node.</li>
<li><strong>dst</strong> (str):
The node name of the destination node.</li>
<li><strong>edge_type</strong> (Optional[str]):
The edge type name of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_weight_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weight_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weight_from_node_names</span><span class="signature">(self, src_name: str, dst_name: str) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The node name of the destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns weight of the given node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_name</strong> (str):
The node name of the source node.</li>
<li><strong>dst_name</strong> (str):
The node name of the destination node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_name_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_name_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_name_from_node_id</span><span class="signature">(self, node_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose name is to be returned.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_node_name_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_name_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_name_from_node_id</span><span class="signature">(self, node_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node ID whose name is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node ID whose name is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_id_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_id_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_id_from_node_name</span><span class="signature">(self, node_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name whose node ID is to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: When the given node name does not exists in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_ids_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_ids_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_ids_from_node_names</span><span class="signature">(self, node_names: List[str]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str]</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_names</strong> (List[str]):
The node names whose node IDs is to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: When any of the given node name does not exists in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_ids_from_edge_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_ids_from_edge_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_ids_from_edge_node_names</span><span class="signature">(
    self,
    edge_node_names: List[Tuple[str, str]]
) -&gt; List[Tuple[int, int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_ids_from_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_names: List[Tuple[str, str]]</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the edge node IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_node_names</strong> (List[Tuple[str, str]]):
The node names whose node IDs is to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: When any of the given node name does not exists in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_node_names_from_edge_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_node_names_from_edge_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_node_names_from_edge_node_ids</span><span class="signature">(self, edge_node_ids: List[Tuple[int, int]]) -&gt; List[Tuple[str, str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_node_names_from_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_ids: List[Tuple[int, int]]</span>
<span class="sd">            The node names whose node names is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node IDs does not exists in the current graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns result with the edge node names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_node_ids</strong> (List[Tuple[int, int]]):
The node names whose node names is to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: When any of the given node IDs does not exists in the current graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_ids_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_ids_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_ids_from_node_name</span><span class="signature">(self, node_name: str) -&gt; Union[List[int], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return node type ID for the given node name if available.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Name of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_name_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_name_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_name_from_node_name</span><span class="signature">(self, node_name: str) -&gt; Union[List[str], NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return node type name for the given node name if available.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Name of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_count_from_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_count_from_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_count_from_edge_type_id</span><span class="signature">(self, edge_type_id: Union[int, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, the unknown edge type IDs</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int]</span>
<span class="sd">            The edge type ID to count the edges of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of edges with given edge type ID.</p>

<p>If None is given as an edge type ID, the unknown edge type IDs
will be returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (Optional[int]):
The edge type ID to count the edges of.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_type_id_from_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_id_from_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_id_from_edge_type_name</span><span class="signature">(self, edge_type_name: Union[str, NoneType]) -&gt; Union[int, NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID curresponding to given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The edge type name whose ID is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge type ID curresponding to given edge type name.</p>

<p>If None is given as an edge type ID, None is returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (Optional[str]):
The edge type name whose ID is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_count_from_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_count_from_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_count_from_edge_type_name</span><span class="signature">(self, edge_type_name: Union[str, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type name, the unknown edge types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The edge type name to count the edges of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of edges with given edge type name.</p>

<p>If None is given as an edge type name, the unknown edge types
will be returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (Optional[str]):
The edge type name to count the edges of.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_id_from_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_id_from_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_id_from_node_type_name</span><span class="signature">(self, node_type_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_id_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID curresponding to given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type name whose ID is to be returned.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return node type ID curresponding to given node type name.</p>

<p>If None is given as an node type ID, None is returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_name</strong> (str):
The node type name whose ID is to be returned.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_count_from_node_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_count_from_node_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_count_from_node_type_id</span><span class="signature">(self, node_type_id: Union[int, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int]</span>
<span class="sd">            The node type ID to count the nodes of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of nodes with given node type ID.</p>

<p>If None is given as an node type ID, the unknown node types
will be returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id</strong> (Optional[int]):
The node type ID to count the nodes of.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_count_from_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_count_from_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_count_from_node_type_name</span><span class="signature">(self, node_type_name: Union[str, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type name, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: Optional[str]</span>
<span class="sd">            The node type name to count the nodes of.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return number of nodes with given node type name.</p>

<p>If None is given as an node type name, the unknown node types
will be returned.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_name</strong> (Optional[str]):
The node type name to count the nodes of.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_neighbour_node_ids_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_neighbour_node_ids_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_neighbour_node_ids_from_node_id</span><span class="signature">(self, node_id: int) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of destinations for the given source node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Node ID whose neighbours are to be retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_neighbour_node_ids_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_neighbour_node_ids_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_neighbour_node_ids_from_node_name</span><span class="signature">(self, node_name: str) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of destinations for the given source node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Node ID whose neighbours are to be retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_neighbour_node_names_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_neighbour_node_names_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_neighbour_node_names_from_node_name</span><span class="signature">(self, node_name: str) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_neighbour_node_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destination names for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Node name whose neighbours are to be retrieved.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return vector of destination names for the given source node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Node name whose neighbours are to be retrieved.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_minmax_edge_ids_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_minmax_edge_ids_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_minmax_edge_ids_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return range of outbound edges IDs for all the edges bewteen the given
source and destination nodes.
This operation is meaningfull only in a multigraph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Source node.</li>
<li><strong>dst</strong> (int):
Destination node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_id_from_node_ids_and_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_id_from_node_ids_and_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_id_from_node_ids_and_edge_type_id</span><span class="signature">(self, src: int, dst: int, edge_type: Union[int, NoneType]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            Edge Type of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge ID for given tuple of nodes and edge type.</p>

<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Source node of the edge.</li>
<li><strong>dst</strong> (int):
Destination node of the edge.</li>
<li><strong>edge_type</strong> (Optional[int]):
Edge Type of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_id_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_id_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_id_from_node_names</span><span class="signature">(self, src_name: str, dst_name: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            Destination node name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge ID for given tuple of node names.</p>

<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_name</strong> (str):
Source node name of the edge.</li>
<li><strong>dst_name</strong> (str):
Destination node name of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_id_from_node_names_and_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_id_from_node_names_and_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_id_from_node_names_and_edge_type_name</span><span class="signature">(
    self,
    src_name: str,
    dst_name: str,
    edge_type_name: Union[str, NoneType]
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names and edge type name.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            Destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            Edge type name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge ID for given tuple of node names and edge type name.</p>

<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_name</strong> (str):
Source node name of the edge.</li>
<li><strong>dst_name</strong> (str):
Destination node name of the edge.</li>
<li><strong>edge_type_name</strong> (Optional[str]):
Edge type name.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_type_ids_from_edge_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_type_ids_from_edge_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_type_ids_from_edge_type_names</span><span class="signature">(
    self,
    edge_type_names: List[Union[str, NoneType]]
) -&gt; List[Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_type_ids_from_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated edge types from string to internal edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_names: List[Optional[str]]</span>
<span class="sd">            Vector of edge types to be converted.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return translated edge types from string to internal edge ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_names</strong> (List[Optional[str]]):
Vector of edge types to be converted.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_ids_from_node_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_ids_from_node_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_ids_from_node_type_names</span><span class="signature">(
    self,
    node_type_names: List[Union[str, NoneType]]
) -&gt; List[Union[int, NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[str]]</span>
<span class="sd">            Vector of node types to be converted.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return translated node types from string to internal node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_names</strong> (List[Optional[str]]):
Vector of node types to be converted.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_multiple_node_type_ids_from_node_type_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_multiple_node_type_ids_from_node_type_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_multiple_node_type_ids_from_node_type_names</span><span class="signature">(
    self,
    node_type_names: List[Union[List[str], NoneType]]
) -&gt; List[Union[List[int], NoneType]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_multiple_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[List[str]]]</span>
<span class="sd">            Vector of node types to be converted.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node type names do not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return translated node types from string to internal node ID.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_names</strong> (List[Optional[List[str]]]):
Vector of node types to be converted.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If any of the given node type names do not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_minmax_edge_ids_from_source_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_minmax_edge_ids_from_source_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_minmax_edge_ids_from_source_node_id</span><span class="signature">(self, src: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source node ID is higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return range of outbound edges IDs which have as source the given Node.</p>

<p>The method will panic if the given source node ID is higher than
the number of nodes in the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Node for which we need to compute the cumulative_node_degrees range.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</div>


                            </div>
                            <div id="Graph.get_minmax_edge_ids_from_source_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_minmax_edge_ids_from_source_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_minmax_edge_ids_from_source_node_id</span><span class="signature">(self, src: int) -&gt; Tuple[int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return range of outbound edges IDs which have as source the given Node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Node for which we need to compute the cumulative_node_degrees range.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_type_name_from_node_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_type_name_from_node_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_type_name_from_node_type_id</span><span class="signature">(self, node_type_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        There is no need for a unchecked version since we will have to map</span>
<span class="sd">        on the note_types anyway.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            Id of the node type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return node type name of given node type.</p>

<p>There is no need for a unchecked version since we will have to map
on the note_types anyway.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id</strong> (int):
Id of the node type.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_node_type_names_from_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_node_type_names_from_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_node_type_names_from_node_type_ids</span><span class="signature">(self, node_type_ids: List[int]) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[int]</span>
<span class="sd">            Id of the node type.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will panic if the graph does not contain node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return node type name of given node type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_ids</strong> (List[int]):
Id of the node type.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>The method will panic if the graph does not contain node types.</p>
</div>


                            </div>
                            <div id="Graph.is_unchecked_connected_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_connected_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_connected_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_connected_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is not a singleton nor a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is not a singleton nor a singleton with selfloop.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.is_unchecked_disconnected_node_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_disconnected_node_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_disconnected_node_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_disconnected_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton or a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton or a singleton with selfloop.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.is_unchecked_singleton_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_singleton_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_singleton_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.is_singleton_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_singleton_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_singleton_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_unchecked_singleton_with_selfloops_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_singleton_with_selfloops_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_singleton_with_selfloops_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton with self-loops.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_singleton_with_selfloops_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_singleton_with_selfloops_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_singleton_with_selfloops_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton with self-loops.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
The node to be checked for.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_unchecked_singleton_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_singleton_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_singleton_from_node_name</span><span class="signature">(self, node_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Nota that this method will raise a panic if caled with unproper</span>
<span class="sd">        parametrization.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exist in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton.</p>

<p>Nota that this method will raise a panic if caled with unproper
parametrization.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name to be checked for.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node name does not exist in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.is_singleton_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_singleton_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_singleton_from_node_name</span><span class="signature">(self, node_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name to be checked for.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a singleton.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name to be checked for.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_name</span><span class="signature">(self, node_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has the given node name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Name of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_type_id</span><span class="signature">(self, node_type_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            id of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has the given node type id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id</strong> (int):
id of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_type_name</span><span class="signature">(self, node_type_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has the given node type name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_name</strong> (str):
Name of the node.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_type_id</span><span class="signature">(self, edge_type_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            id of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has the given edge type id.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (int):
id of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_type_name</span><span class="signature">(self, edge_type_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            Name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the graph has the given edge type name.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (str):
Name of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_from_node_ids</span><span class="signature">(self, src: int, dst: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge passing between given node ids exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            Source node id.</span>
<span class="sd">        dst: int</span>
<span class="sd">            Destination node id.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether edge passing between given node ids exists.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
Source node id.</li>
<li><strong>dst</strong> (int):
Destination node id.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_selfloop_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_selfloop_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_selfloop_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_selfloop_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node ID has a selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Source node id.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the given node ID has a selfloop.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Source node id.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_from_node_ids_and_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_from_node_ids_and_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_from_node_ids_and_edge_type_id</span><span class="signature">(self, src: int, dst: int, edge_type: Union[int, NoneType]) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge with the given type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int</span>
<span class="sd">            The source node of the edge.</span>
<span class="sd">        dst: int</span>
<span class="sd">            The destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int]</span>
<span class="sd">            The (optional) edge type.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether edge with the given type passing between given nodes exists.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src</strong> (int):
The source node of the edge.</li>
<li><strong>dst</strong> (int):
The destination node of the edge.</li>
<li><strong>edge_type</strong> (Optional[int]):
The (optional) edge type.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.is_unchecked_trap_node_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_unchecked_trap_node_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_unchecked_trap_node_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_unchecked_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        If the provided node_id is higher than the number of nodes in the graph,</span>
<span class="sd">        the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a trap.</p>

<p>If the provided node_id is higher than the number of nodes in the graph,
the method will panic.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node, if this is bigger that the number of nodes it will panic.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>If the given node ID does not exists in the graph this method will panic.</p>
</div>


                            </div>
                            <div id="Graph.is_trap_node_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.is_trap_node_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_trap_node_from_node_id</span><span class="signature">(self, node_id: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns boolean representing if given node is a trap.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Integer ID of the node, if this is bigger that the number of nodes it will panic.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_node_name_and_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_node_name_and_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_node_name_and_node_type_name</span><span class="signature">(
    self,
    node_name: str,
    node_type_name: Union[List[str], NoneType]
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_node_name_and_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node name and node type name exist in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            The node name.</span>
<span class="sd">        node_type_name: Optional[List[str]]</span>
<span class="sd">            The node types name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the given node name and node type name exist in current graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
The node name.</li>
<li><strong>node_type_name</strong> (Optional[List[str]]):
The node types name.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_from_node_names</span><span class="signature">(self, src_name: str, dst_name: str) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The destination node name of the edge.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether if edge passing between given nodes exists.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_name</strong> (str):
The source node name of the edge.</li>
<li><strong>dst_name</strong> (str):
The destination node name of the edge.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.has_edge_from_node_names_and_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.has_edge_from_node_names_and_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">has_edge_from_node_names_and_edge_type_name</span><span class="signature">(
    self,
    src_name: str,
    dst_name: str,
    edge_type_name: Union[str, NoneType]
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">has_edge_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge with type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str</span>
<span class="sd">            The destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str]</span>
<span class="sd">            The (optional) edge type name.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether if edge with type passing between given nodes exists.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>src_name</strong> (str):
The source node name of the edge.</li>
<li><strong>dst_name</strong> (str):
The destination node name of the edge.</li>
<li><strong>edge_type_name</strong> (Optional[str]):
The (optional) edge type name.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_random_connected_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_random_connected_graph">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_random_connected_graph</span><span class="signature">(
    random_state: Union[int, NoneType],
    minimum_node_id: Union[int, NoneType],
    minimum_node_sampling: Union[int, NoneType],
    maximum_node_sampling: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    node_type: Union[str, NoneType],
    edge_type: Union[str, NoneType],
    weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_random_connected_graph</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_sampling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximum_node_sampling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new random connected graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>random_state</strong> (int):
The random state to use to reproduce the sampling.</li>
<li><strong>minimum_node_id</strong> (int):
The minimum node ID for the connected graph.</li>
<li><strong>minimum_node_sampling</strong> (int):
The minimum amount of nodes to sample per node.</li>
<li><strong>maximum_node_sampling</strong> (int):
The maximum amount of nodes to sample per node.</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
Number of nodes in the chain. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>node_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>edge_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>weight</strong> (Optional[float]):
The weight to use for the edges in the chain. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Chain'.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_random_spanning_tree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_random_spanning_tree">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_random_spanning_tree</span><span class="signature">(
    random_state: Union[int, NoneType],
    minimum_node_id: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    node_type: Union[str, NoneType],
    edge_type: Union[str, NoneType],
    weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_random_spanning_tree</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new random connected graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>random_state</strong> (int):
The random state to use to reproduce the sampling.</li>
<li><strong>minimum_node_id</strong> (int):
The minimum node ID for the connected graph.</li>
<li><strong>minimum_node_sampling</strong> (int):
The minimum amount of nodes to sample per node.</li>
<li><strong>maximum_node_sampling</strong> (int):
The maximum amount of nodes to sample per node.</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
Number of nodes in the chain. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>node_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>edge_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>weight</strong> (Optional[float]):
The weight to use for the edges in the chain. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Chain'.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_circle_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_circle_graph">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_circle_graph</span><span class="signature">(
    minimum_node_id: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    node_type: Union[str, NoneType],
    edge_type: Union[str, NoneType],
    weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_circle_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new circle graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when circleing graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the circle. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the circle. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Circle&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new circle graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>minimum_node_id</strong> (Optional[int]):
Minimum node ID to start with. May be needed when circleing graphs. By default 0.</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
Number of nodes in the circle. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>node_type</strong> (Optional[str]):
The node type to use for the circle. By default 'circle'.</li>
<li><strong>edge_type</strong> (Optional[str]):
The node type to use for the circle. By default 'circle'.</li>
<li><strong>weight</strong> (Optional[float]):
The weight to use for the edges in the circle. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Circle'.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_chain_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_chain_graph">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_chain_graph</span><span class="signature">(
    minimum_node_id: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    node_type: Union[str, NoneType],
    edge_type: Union[str, NoneType],
    weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_chain_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new chain graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new chain graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>minimum_node_id</strong> (Optional[int]):
Minimum node ID to start with. May be needed when chaining graphs. By default 0.</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
Number of nodes in the chain. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>node_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>edge_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>weight</strong> (Optional[float]):
The weight to use for the edges in the chain. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Chain'.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_complete_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_complete_graph">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_complete_graph</span><span class="signature">(
    minimum_node_id: Union[int, NoneType],
    number_of_nodes: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    node_type: Union[str, NoneType],
    edge_type: Union[str, NoneType],
    weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_complete_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">number_of_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new complete graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when combining graphs. By default 0.</span>
<span class="sd">        number_of_nodes: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str]</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        edge_type: Optional[str]</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Complete&#39;.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new complete graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>minimum_node_id</strong> (Optional[int]):
Minimum node ID to start with. May be needed when combining graphs. By default 0.</li>
<li><strong>number_of_nodes</strong> (Optional[int]):
Number of nodes in the chain. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>node_type</strong> (Optional[str]):
The node type to use. By default 'complete'.</li>
<li><strong>edge_type</strong> (Optional[str]):
The node type to use. By default 'complete'.</li>
<li><strong>weight</strong> (Optional[float]):
The weight to use for the edges. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Complete'.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.generate_barbell_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_barbell_graph">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">generate_barbell_graph</span><span class="signature">(
    minimum_node_id: Union[int, NoneType],
    left_clique_nodes_number: Union[int, NoneType],
    right_clique_nodes_number: Union[int, NoneType],
    chain_nodes_number: Union[int, NoneType],
    include_selfloops: Union[bool, NoneType],
    left_clique_node_type: Union[str, NoneType],
    right_clique_node_type: Union[str, NoneType],
    chain_node_type: Union[str, NoneType],
    left_clique_edge_type: Union[str, NoneType],
    right_clique_edge_type: Union[str, NoneType],
    chain_edge_type: Union[str, NoneType],
    left_clique_weight: Union[float, NoneType],
    right_clique_weight: Union[float, NoneType],
    chain_weight: Union[float, NoneType],
    directed: Union[bool, NoneType],
    name: Union[str, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_barbell_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">left_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">right_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">chain_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">left_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">right_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">chain_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new barbell graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int]</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        left_clique_nodes_number: Optional[int]</span>
<span class="sd">            Number of nodes in the left clique. By default 10.</span>
<span class="sd">        right_clique_nodes_number: Optional[int]</span>
<span class="sd">             Number of nodes in the right clique. By default equal to the left clique.</span>
<span class="sd">        chain_nodes_number: Optional[int]</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool]</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        left_clique_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_node_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_edge_type: Optional[str]</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the left clique. By default None.</span>
<span class="sd">        right_clique_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the right clique. By default None.</span>
<span class="sd">        chain_weight: Optional[float]</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool]</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str]</span>
<span class="sd">            Name of the graph. By default &#39;Barbell&#39;.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weights are provided only for a subset.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates new barbell graph with given sizes and types.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>minimum_node_id</strong> (Optional[int]):
Minimum node ID to start with. May be needed when chaining graphs. By default 0.</li>
<li><strong>left_clique_nodes_number</strong> (Optional[int]):
Number of nodes in the left clique. By default 10.</li>
<li><strong>right_clique_nodes_number</strong> (Optional[int]):
Number of nodes in the right clique. By default equal to the left clique.</li>
<li><strong>chain_nodes_number</strong> (Optional[int]):
Number of nodes in the chain. By default 10.</li>
<li><strong>include_selfloops</strong> (Optional[bool]):
Whether to include selfloops.</li>
<li><strong>left_clique_node_type</strong> (Optional[str]):
The node type to use for the left clique. By default 'left_clique'.</li>
<li><strong>right_clique_node_type</strong> (Optional[str]):
The node type to use for the right clique. By default 'right_clique'.</li>
<li><strong>chain_node_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>left_clique_edge_type</strong> (Optional[str]):
The node type to use for the left clique. By default 'left_clique'.</li>
<li><strong>right_clique_edge_type</strong> (Optional[str]):
The node type to use for the right clique. By default 'right_clique'.</li>
<li><strong>chain_edge_type</strong> (Optional[str]):
The node type to use for the chain. By default 'chain'.</li>
<li><strong>left_clique_weight</strong> (Optional[float]):
The weight to use for the edges in the left clique. By default None.</li>
<li><strong>right_clique_weight</strong> (Optional[float]):
The weight to use for the edges in the right clique. By default None.</li>
<li><strong>chain_weight</strong> (Optional[float]):
The weight to use for the edges in the chain. By default None.</li>
<li><strong>directed</strong> (Optional[bool]):
Whether the graph is to built as directed. By default false.</li>
<li><strong>name</strong> (Optional[str]):
Name of the graph. By default 'Barbell'.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the edge weights are provided only for a subset.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.are_nodes_remappable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.are_nodes_remappable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">are_nodes_remappable</span><span class="signature">(self, other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">are_nodes_remappable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether nodes are remappable to those of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            graph towards remap the nodes to.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return whether nodes are remappable to those of the given graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
graph towards remap the nodes to.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remap_unchecked_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remap_unchecked_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remap_unchecked_from_node_ids</span><span class="signature">(self, node_ids: List[int]) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remap_unchecked_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will cause a panic if the node IDs are either:</span>
<span class="sd">         * Not unique</span>
<span class="sd">         * Not available for each of the node IDs of the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph remapped using given node IDs ordering.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids</strong> (List[int]):
The node Ids to remap the graph to.</li>
</ul>

<h6 id="safety">Safety</h6>

<p>This method will cause a panic if the node IDs are either:</p>

<ul>
<li>Not unique</li>
<li>Not available for each of the node IDs of the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remap_from_node_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remap_from_node_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remap_from_node_ids</span><span class="signature">(self, node_ids: List[int]) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remap_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int]</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not available for all the values in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph remapped using given node IDs ordering.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_ids</strong> (List[int]):
The node Ids to remap the graph to.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node IDs are not unique.</li>
<li><strong>ValueError</strong>: If the given node IDs are not available for all the values in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remap_from_node_names" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remap_from_node_names">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remap_from_node_names</span><span class="signature">(self, node_names: List[str]) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remap_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node names ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str]</span>
<span class="sd">            The node names to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not available for all the values in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph remapped using given node names ordering.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_names</strong> (List[str]):
The node names to remap the graph to.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node names are not unique.</li>
<li><strong>ValueError</strong>: If the given node names are not available for all the values in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remap_from_graph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remap_from_graph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remap_from_graph</span><span class="signature">(
    self,
    other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remap_from_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return graph remapped towards nodes of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            The graph to remap towards.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return graph remapped towards nodes of the given graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
The graph to remap towards.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_components" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_components">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_components</span><span class="signature">(
    self,
    node_names: Union[List[str], NoneType],
    node_types: Union[List[Union[str, NoneType]], NoneType],
    edge_types: Union[List[Union[str, NoneType]], NoneType],
    minimum_component_size: Union[int, NoneType],
    top_k_components: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">minimum_component_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">top_k_components</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;remove all the components that are not connected to interesting</span>
<span class="sd">        nodes and edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: Optional[List[str]]</span>
<span class="sd">            The name of the nodes of which components to keep.</span>
<span class="sd">        node_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The types of the nodes of which components to keep.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]]</span>
<span class="sd">            The types of the edges of which components to keep.</span>
<span class="sd">        minimum_component_size: Optional[int]</span>
<span class="sd">            Optional, Minimum size of the components to keep.</span>
<span class="sd">        top_k_components: Optional[int]</span>
<span class="sd">            Optional, number of components to keep sorted by number of nodes.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>remove all the components that are not connected to interesting
nodes and edges.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_names</strong> (Optional[List[str]]):
The name of the nodes of which components to keep.</li>
<li><strong>node_types</strong> (Optional[List[Optional[str]]]):
The types of the nodes of which components to keep.</li>
<li><strong>edge_types</strong> (Optional[List[Optional[str]]]):
The types of the edges of which components to keep.</li>
<li><strong>minimum_component_size</strong> (Optional[int]):
Optional, Minimum size of the components to keep.</li>
<li><strong>top_k_components</strong> (Optional[int]):
Optional, number of components to keep sorted by number of nodes.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show the loading bar.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.replace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.replace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">replace</span><span class="signature">(
    self,
    node_name_mapping: Union[Dict[str, str], NoneType],
    node_type_name_mapping: Union[Dict[str, str], NoneType],
    edge_type_name_mapping: Union[Dict[str, str], NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">edge_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace given node, node type and edge type names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The node names to replace.</span>
<span class="sd">        node_type_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The node type names to replace.</span>
<span class="sd">        edge_type_name_mapping: Optional[Dict[str, str]]</span>
<span class="sd">            The edge type names to replace.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names mapping would lead to nodes duplication.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Replace given node, node type and edge type names.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name_mapping</strong> (Optional[Dict[str, str]]):
The node names to replace.</li>
<li><strong>node_type_name_mapping</strong> (Optional[Dict[str, str]]):
The node type names to replace.</li>
<li><strong>edge_type_name_mapping</strong> (Optional[Dict[str, str]]):
The edge type names to replace.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given node names mapping would lead to nodes duplication.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.report" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.report">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">report</span><span class="signature">(self) -&gt; Dict[str, str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns report relative to the graph metrics</span>
<span class="sd">        </span>
<span class="sd">        The report includes the following metrics by default:</span>
<span class="sd">        * Name of the graph</span>
<span class="sd">        * Whether the graph is directed or undirected</span>
<span class="sd">        * Number of singleton nodes</span>
<span class="sd">        * Number of nodes</span>
<span class="sd">        - If the graph has nodes, we also compute:</span>
<span class="sd">        * Minimum unweighted node degree</span>
<span class="sd">        * Maximum unweighted node degree</span>
<span class="sd">        * Unweighted node degree mean</span>
<span class="sd">        * Number of edges</span>
<span class="sd">        * Number of self-loops</span>
<span class="sd">        * Number of singleton with self-loops</span>
<span class="sd">        * Whether the graph is a multigraph</span>
<span class="sd">        * Number of parallel edges</span>
<span class="sd">        * Number of directed edges</span>
<span class="sd">        - If the graph has edges, we also compute:</span>
<span class="sd">        * Rate of self-loops</span>
<span class="sd">        * Whether the graph has weighted edges</span>
<span class="sd">        - If the graph has weights, we also compute:</span>
<span class="sd">        * Minimum weighted node degree</span>
<span class="sd">        * Maximum weighted node degree</span>
<span class="sd">        * Weighted node degree mean</span>
<span class="sd">        * The total edge weights</span>
<span class="sd">        * Whether the graph has node types</span>
<span class="sd">        - If the graph has node types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton node types</span>
<span class="sd">        * The number of node types</span>
<span class="sd">        * The number of nodes with unknown node types</span>
<span class="sd">        * The number of nodes with known node types</span>
<span class="sd">        * Whether the graph has edge types</span>
<span class="sd">        - If the graph has edge types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton edge types</span>
<span class="sd">        * The number of edge types</span>
<span class="sd">        * The number of edges with unknown edge types</span>
<span class="sd">        * The number of edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        On request, since it takes more time to compute it, the method also provides:&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns report relative to the graph metrics</p>

<p>The report includes the following metrics by default:</p>

<ul>
<li>Name of the graph</li>
<li>Whether the graph is directed or undirected</li>
<li>Number of singleton nodes</li>
<li>Number of nodes</li>
<li>If the graph has nodes, we also compute:</li>
<li>Minimum unweighted node degree</li>
<li>Maximum unweighted node degree</li>
<li>Unweighted node degree mean</li>
<li>Number of edges</li>
<li>Number of self-loops</li>
<li>Number of singleton with self-loops</li>
<li>Whether the graph is a multigraph</li>
<li>Number of parallel edges</li>
<li>Number of directed edges</li>
<li>If the graph has edges, we also compute:</li>
<li>Rate of self-loops</li>
<li>Whether the graph has weighted edges</li>
<li>If the graph has weights, we also compute:</li>
<li>Minimum weighted node degree</li>
<li>Maximum weighted node degree</li>
<li>Weighted node degree mean</li>
<li>The total edge weights</li>
<li>Whether the graph has node types</li>
<li>If the graph has node types, we also compute:</li>
<li>Whether the graph has singleton node types</li>
<li>The number of node types</li>
<li>The number of nodes with unknown node types</li>
<li>The number of nodes with known node types</li>
<li>Whether the graph has edge types</li>
<li>If the graph has edge types, we also compute:</li>
<li>Whether the graph has singleton edge types</li>
<li>The number of edge types</li>
<li>The number of edges with unknown edge types</li>
<li>The number of edges with known edge types</li>
</ul>

<p>On request, since it takes more time to compute it, the method also provides:</p>
</div>


                            </div>
                            <div id="Graph.overlap_textual_report" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.overlap_textual_report">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">overlap_textual_report</span><span class="signature">(
    self,
    other: <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>,
    verbose: Union[bool, NoneType]
) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">overlap_textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return rendered textual report about the graph overlaps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph</span>
<span class="sd">            graph to create overlap report with.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to shor the loading bars.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return rendered textual report about the graph overlaps.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>other</strong> (Graph):
graph to create overlap report with.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to shor the loading bars.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_report_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_report_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_report_from_node_id</span><span class="signature">(self, node_id: int) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_report_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return human-readable html report of the given node.</p>

<p>The report, by default, is rendered using html.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_id</strong> (int):
Whether to show a loading bar in graph operations.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_report_from_node_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_report_from_node_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_report_from_node_name</span><span class="signature">(self, node_name: str) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_report_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return human-readable html report of the given node.</p>

<p>The report, by default, is rendered using html.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_name</strong> (str):
Whether to show a loading bar in graph operations.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.textual_report" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.textual_report">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">textual_report</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return html short textual report of the graph.</span>
<span class="sd">        </span>
<span class="sd">        TODO! Add reports on triangles</span>
<span class="sd">        TODO! Add reports on connected components</span>
<span class="sd">        TODO! Add reports on various node metrics</span>
<span class="sd">        TODO! Add reports on various edge metrics</span>
<span class="sd">        NOTE! Most of the above TODOs will require first to implement the</span>
<span class="sd">        support for the fast computation of the inbound edges in a directed</span>
<span class="sd">        graphs&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return html short textual report of the graph.</p>

<p>TODO! Add reports on triangles
TODO! Add reports on connected components
TODO! Add reports on various node metrics
TODO! Add reports on various edge metrics
NOTE! Most of the above TODOs will require first to implement the
support for the fast computation of the inbound edges in a directed
graphs</p>
</div>


                            </div>
                            <div id="Graph.add_selfloops" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.add_selfloops">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add_selfloops</span><span class="signature">(
    self,
    edge_type_name: Union[str, NoneType],
    weight: Union[float, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">add_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph with added in missing self-loops with given edge type and weight.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge type for the new selfloops is provided but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is provided but the graph does not have edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns new graph with added in missing self-loops with given edge type and weight.</p>

<h6 id="parameters">Parameters</h6>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the edge type for the new selfloops is provided but the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the edge weight for the new selfloops is provided but the graph does not have edge weights.</li>
<li><strong>ValueError</strong>: If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.set_inplace_all_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.set_inplace_all_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_inplace_all_edge_types</span><span class="signature">(self, edge_type: str)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_inplace_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This happens INPLACE, that is edits the current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str</span>
<span class="sd">            The edge type to assing to all the edges.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Replace all edge types (if present) and set all the edge to edge_type.</p>

<p>This happens INPLACE, that is edits the current graph instance.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type</strong> (str):
The edge type to assing to all the edges.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edges.</li>
<li><strong>ValueError</strong>: If the graph is a multigraph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.set_all_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.set_all_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_all_edge_types</span><span class="signature">(self, edge_type: str) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str</span>
<span class="sd">            The edge type to assing to all the edges.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Replace all edge types (if present) and set all the edge to edge_type.</p>

<p>This DOES NOT happen inplace, but created a new instance of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type</strong> (str):
The edge type to assing to all the edges.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.set_inplace_all_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.set_inplace_all_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_inplace_all_node_types</span><span class="signature">(self, node_type: str)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_inplace_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Replace all node types (if present) and set all the node to node_type.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type</strong> (str):
The node type to assing to all the nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.set_all_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.set_all_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_all_node_types</span><span class="signature">(self, node_type: str) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Replace all node types (if present) and set all the node to node_type.</p>

<p>This DOES NOT happen inplace, but created a new instance of the graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type</strong> (str):
The node type to assing to all the nodes.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_node_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_node_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_node_type_ids</span><span class="signature">(self, node_type_ids_to_remove: List[int])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids_to_remove</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id_to_remove: int</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given node type ID from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id_to_remove</strong> (int):
The node type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If the given node type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_singleton_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_singleton_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_singleton_node_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove singleton node types from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_edge_type_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_edge_type_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_edge_type_ids</span><span class="signature">(self, edge_type_ids_to_remove: List[int])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_ids_to_remove</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given edge type ID from all edges.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (int):
The edge type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph is a multigraph.</li>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the given edge type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_singleton_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_singleton_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_singleton_edge_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove singleton edge types from all edges.</p>

<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification happens inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_node_type_name</span><span class="signature">(self, node_type_name: str)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given node type name from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_name</strong> (str):
The node type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If the given node type name does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_node_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_node_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_node_type_id</span><span class="signature">(self, node_type_id: int) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given node type ID from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_id</strong> (int):
The node type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If the given node type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_singleton_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_singleton_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_singleton_node_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove singleton node types from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_node_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_node_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_node_type_name</span><span class="signature">(self, node_type_name: str) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given node type name from all nodes.</p>

<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_name</strong> (str):
The node type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
<li><strong>ValueError</strong>: If the given node type name does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_edge_type_name</span><span class="signature">(self, edge_type_name: str)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given edge type name from all edges.</p>

<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification happens inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (str):
The edge type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the given edge type name does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_edge_type_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_edge_type_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_edge_type_id</span><span class="signature">(self, edge_type_id: int) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given edge type ID from all edges.</p>

<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_id</strong> (int):
The edge type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the given edge type ID does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_singleton_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_singleton_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_singleton_edge_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove singleton edge types from all edges.</p>

<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_edge_type_name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_edge_type_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_edge_type_name</span><span class="signature">(self, edge_type_name: str) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove given edge type name from all edges.</p>

<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_name</strong> (str):
The edge type ID to remove.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the given edge type name does not exists in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_node_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove node types from the graph.</p>

<p>Note that the modification happens inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_node_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove node types from the graph.</p>

<p>Note that the modification does not happen inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have node types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_edge_types</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove edge types from the graph.</p>

<p>Note that the modification happens inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError</strong>: If the graph is a multigraph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_edge_types</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove edge types from the graph.</p>

<p>Note that the modification does not happen inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_inplace_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_inplace_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_inplace_edge_weights</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_inplace_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove edge weights from the graph.</p>

<p>Note that the modification happens inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.remove_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.remove_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_edge_weights</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">remove_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove edge weights from the graph.</p>

<p>Note that the modification does not happen inplace.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have edge weights.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.sort_by_increasing_outbound_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.sort_by_increasing_outbound_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_by_increasing_outbound_node_degree</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by increasing outbound node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with node IDs sorted by increasing outbound node degree</p>
</div>


                            </div>
                            <div id="Graph.sort_by_decreasing_outbound_node_degree" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.sort_by_decreasing_outbound_node_degree">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_by_decreasing_outbound_node_degree</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by decreasing outbound node degree&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with node IDs sorted by decreasing outbound node degree</p>
</div>


                            </div>
                            <div id="Graph.sort_by_node_lexicographic_order" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.sort_by_node_lexicographic_order">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_by_node_lexicographic_order</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_by_node_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by lexicographic order&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with node IDs sorted by lexicographic order</p>
</div>


                            </div>
                            <div id="Graph.get_bfs_topological_sorting_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_bfs_topological_sorting_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_bfs_topological_sorting_from_node_id</span><span class="signature">(self, root_node_id: int) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns topological sorting map using breadth-first search from the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>root_node_id</strong> (int):
Node ID of node to be used as root of BFS</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given root node ID does not exist in the graph</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_reversed_bfs_topological_sorting_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_reversed_bfs_topological_sorting_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_reversed_bfs_topological_sorting_from_node_id</span><span class="signature">(self, root_node_id: int) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_reversed_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting reversed map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns topological sorting reversed map using breadth-first search from the given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>root_node_id</strong> (int):
Node ID of node to be used as root of BFS</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given root node ID does not exist in the graph</li>
</ul>
</div>


                            </div>
                            <div id="Graph.sort_by_bfs_topological_sorting_from_node_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.sort_by_bfs_topological_sorting_from_node_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort_by_bfs_topological_sorting_from_node_id</span><span class="signature">(self, root_node_id: int) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort_by_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted using a BFS</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with node IDs sorted using a BFS</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>root_node_id</strong> (int):
Node ID of node to be used as root of BFS</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given root node ID does not exist in the graph</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_sparse_edge_weighting_methods" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_sparse_edge_weighting_methods">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sparse_edge_weighting_methods</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sparse_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported sparse edge weighting methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return list of the supported sparse edge weighting methods</p>
</div>


                            </div>
                            <div id="Graph.get_edge_weighting_methods" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_weighting_methods">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_weighting_methods</span><span class="signature">(self) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported edge weighting methods&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return list of the supported edge weighting methods</p>
</div>


                            </div>
                            <div id="Graph.strongly_connected_components" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.strongly_connected_components">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">strongly_connected_components</span><span class="signature">(self) -&gt; List[Set[int]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">strongly_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of nodes of the various strongly connected components.</span>
<span class="sd">        </span>
<span class="sd">        This is an implementation of Tarjan algorithm.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns list of nodes of the various strongly connected components.</p>

<p>This is an implementation of Tarjan algorithm.</p>
</div>


                            </div>
                            <div id="Graph.generate_new_edges_from_node_features" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.generate_new_edges_from_node_features">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_new_edges_from_node_features</span><span class="signature">(
    self,
    features: List[List[float]],
    neighbours_number: Union[int, NoneType],
    max_degree: Union[int, NoneType],
    distance_name: Union[str, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_new_edges_from_node_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">neighbours_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_degree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">distance_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with edges added extracted from given node_features.</span>
<span class="sd">        </span>
<span class="sd">        This operation might distrupt the graph topology.</span>
<span class="sd">        Proceed with caution!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[List[float]]</span>
<span class="sd">            node_features to use to identify the new neighbours.</span>
<span class="sd">        neighbours_number: Optional[int]</span>
<span class="sd">            Number of neighbours to add.</span>
<span class="sd">        max_degree: Optional[int]</span>
<span class="sd">            The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.</span>
<span class="sd">        distance_name: Optional[str]</span>
<span class="sd">            Name of distance to use. Can either be L2 or COSINE. By default COSINE.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show loading bars.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node_features are not provided exactly for each node.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node_features do not have a consistent shape.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the provided number of neighbours is zero.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with edges added extracted from given node_features.</p>

<p>This operation might distrupt the graph topology.
Proceed with caution!</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>features</strong> (List[List[float]]):
node_features to use to identify the new neighbours.</li>
<li><strong>neighbours_number</strong> (Optional[int]):
Number of neighbours to add.</li>
<li><strong>max_degree</strong> (Optional[int]):
The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.</li>
<li><strong>distance_name</strong> (Optional[str]):
Name of distance to use. Can either be L2 or COSINE. By default COSINE.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show loading bars.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have nodes.</li>
<li><strong>ValueError</strong>: If the given node_features are not provided exactly for each node.</li>
<li><strong>ValueError</strong>: If the node_features do not have a consistent shape.</li>
<li><strong>ValueError</strong>: If the provided number of neighbours is zero.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.to_directed_inplace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_directed_inplace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_directed_inplace</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_directed_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert inplace the graph to directed.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convert inplace the graph to directed.</p>
</div>


                            </div>
                            <div id="Graph.to_directed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_directed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_directed</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new instance of the current graph as directed&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return a new instance of the current graph as directed</p>
</div>


                            </div>
                            <div id="Graph.to_upper_triangular" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_upper_triangular">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_upper_triangular</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the upper triangular adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the directed graph from the upper triangular adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_lower_triangular" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_lower_triangular">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_lower_triangular</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the lower triangular adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the directed graph from the lower triangular adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_main_diagonal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_main_diagonal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_main_diagonal</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_main_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the main diagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the graph from the main diagonal adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_anti_diagonal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_anti_diagonal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_anti_diagonal</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_anti_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the anti-diagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the graph from the anti-diagonal adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_bidiagonal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_bidiagonal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_bidiagonal</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_bidiagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the bidiagonal adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the graph from the bidiagonal adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_arrowhead" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_arrowhead">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_arrowhead</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_arrowhead</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the arrowhead adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the graph from the arrowhead adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_transposed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_transposed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_transposed</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_transposed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the transposed adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the graph from the transposed adjacency matrix.</p>
</div>


                            </div>
                            <div id="Graph.to_complementary" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_complementary">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_complementary</span><span class="signature">(self) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_complementary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the complementary graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the complementary graph.</p>
</div>


                            </div>
                            <div id="Graph.get_transitive_closure" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_transitive_closure">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_transitive_closure</span><span class="signature">(
    self,
    iterations: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph to the i-th transitivity closure iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph to the i-th transitivity closure iteration.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>iterations</strong> (Optional[int]):
The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar while building the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_all_shortest_paths" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_all_shortest_paths">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_all_shortest_paths</span><span class="signature">(
    self,
    iterations: Union[int, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with unweighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with unweighted shortest paths computed up to the given depth.</p>

<p>The returned graph will have no selfloops.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>iterations</strong> (Optional[int]):
The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar while building the graph.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_weighted_all_shortest_paths" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_weighted_all_shortest_paths">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_weighted_all_shortest_paths</span><span class="signature">(
    self,
    iterations: Union[int, NoneType],
    use_edge_weights_as_probabilities: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; <a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_weighted_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with weighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int]</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool]</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar while building the graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns graph with weighted shortest paths computed up to the given depth.</p>

<p>The returned graph will have no selfloops.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>iterations</strong> (Optional[int]):
The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</li>
<li><strong>use_edge_weights_as_probabilities</strong> (Optional[bool]):
Whether to treat the edge weights as probabilities.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar while building the graph.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the graph does not have weights.</li>
<li><strong>ValueError</strong>: If the graph contains negative weights.</li>
<li><strong>ValueError</strong>: If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.random_spanning_arborescence_kruskal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.random_spanning_arborescence_kruskal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">random_spanning_arborescence_kruskal</span><span class="signature">(
    self,
    random_state: Union[int, NoneType],
    undesired_edge_types: Union[Set[Union[int, NoneType]], NoneType],
    verbose: Union[bool, NoneType]
) -&gt; Tuple[Set[Tuple[int, int]], List[int], int, int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">random_spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">undesired_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns set of edges composing a spanning tree and connected components.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        The given random_state is NOT the root of the tree.</span>
<span class="sd">        </span>
<span class="sd">        This method, additionally, allows for undesired edge types to be</span>
<span class="sd">        used to build the spanning tree only in extremis when it is utterly</span>
<span class="sd">        necessary in order to complete the spanning arborescence.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: Optional[int]</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        undesired_edge_types: Optional[Set[Optional[int]]]</span>
<span class="sd">            Which edge types id to try to avoid.</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns set of edges composing a spanning tree and connected components.</p>

<p>The spanning tree is NOT minimal.
The given random_state is NOT the root of the tree.</p>

<p>This method, additionally, allows for undesired edge types to be
used to build the spanning tree only in extremis when it is utterly
necessary in order to complete the spanning arborescence.</p>

<p>The quintuple returned contains:</p>

<ul>
<li>Set of the edges used in order to build the spanning arborescence.</li>
<li>Vector of the connected component of each node.</li>
<li>Number of connected components.</li>
<li>Minimum component size.</li>
<li>Maximum component size.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>random_state</strong> (Optional[int]):
The random_state to use for the holdout,</li>
<li><strong>undesired_edge_types</strong> (Optional[Set[Optional[int]]]):
Which edge types id to try to avoid.</li>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar or not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.spanning_arborescence_kruskal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.spanning_arborescence_kruskal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">spanning_arborescence_kruskal</span><span class="signature">(
    self,
    verbose: Union[bool, NoneType]
) -&gt; Tuple[Set[Tuple[int, int]], List[int], int, int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns consistent spanning arborescence using Kruskal.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns consistent spanning arborescence using Kruskal.</p>

<p>The spanning tree is NOT minimal.</p>

<p>The quintuple returned contains:</p>

<ul>
<li>Set of the edges used in order to build the spanning arborescence.</li>
<li>Vector of the connected component of each node.</li>
<li>Number of connected components.</li>
<li>Minimum component size.</li>
<li>Maximum component size.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar or not.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.connected_components" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.connected_components">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">connected_components</span><span class="signature">(
    self,
    verbose: Union[bool, NoneType]
) -&gt; Tuple[List[int], int, int, int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Compute the connected components building in parallel a spanning tree using [bader&#39;s algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).</span>
<span class="sd">        </span>
<span class="sd">        **This works only for undirected graphs.**</span>
<span class="sd">        </span>
<span class="sd">        This method is **not thread save and not deterministic** but by design of the algorithm this</span>
<span class="sd">        shouldn&#39;t matter but if we will encounter non-detemristic bugs here is where we want to look.</span>
<span class="sd">        </span>
<span class="sd">        The returned quadruple contains:</span>
<span class="sd">        - Vector of the connected component for each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum connected component size.</span>
<span class="sd">        - Maximum connected component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool]</span>
<span class="sd">            Whether to show a loading bar or not.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given graph is directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the system configuration does not allow for the creation of the thread pool.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the connected components building in parallel a spanning tree using <a href="https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882">bader's algorithm</a>.</p>

<p><strong>This works only for undirected graphs.</strong></p>

<p>This method is <strong>not thread save and not deterministic</strong> but by design of the algorithm this
shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.</p>

<p>The returned quadruple contains:</p>

<ul>
<li>Vector of the connected component for each node.</li>
<li>Number of connected components.</li>
<li>Minimum connected component size.</li>
<li>Maximum connected component size.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>verbose</strong> (Optional[bool]):
Whether to show a loading bar or not.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given graph is directed.</li>
<li><strong>ValueError</strong>: If the system configuration does not allow for the creation of the thread pool.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.approximated_vertex_cover_set" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.approximated_vertex_cover_set">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">approximated_vertex_cover_set</span><span class="signature">(self) -&gt; Set[int]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">approximated_vertex_cover_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns 2-approximated verted cover set using greedy algorithm.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns 2-approximated verted cover set using greedy algorithm.</p>
</div>


                            </div>
                            <div id="Graph.to_dot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.to_dot">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_dot</span><span class="signature">(self) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Print the current graph in a format compatible with Graphviz dot&#39;s format&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print the current graph in a format compatible with Graphviz dot's format</p>
</div>


                            </div>
                            <div id="Graph.cooccurence_matrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.cooccurence_matrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cooccurence_matrix</span><span class="signature">(
    self,
    walk_length: int,
    **kwargs
) -&gt; Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">cooccurence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return cooccurence matrix-based triples of words, contexts and frequencies.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        window_size: int = 4</span>
<span class="sd">            Size of the window for local contexts.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of cycles on the graphs to execute.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        random_state: int = 42</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        verbose: int = True</span>
<span class="sd">            whether to show or not the loading bar of the walks.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        Triple with integer vectors of words and contexts and max-min normalized frequencies.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return cooccurence matrix-based triples of words, contexts and frequencies.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>walk_length</strong> (int):
Maximal length of the random walk.
On graphs without traps, all walks have this length.</li>
<li><strong>window_size</strong> (int = 4):
Size of the window for local contexts.</li>
<li><strong>iterations</strong> (int = 1):
Number of cycles on the graphs to execute.</li>
<li><strong>return_weight</strong> (float = 1.0):
Weight on the probability of returning to node coming from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method available from graph
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>max_neighbours</strong> (int = None):
Maximum number of randomly sampled neighbours to consider.
If this parameter is used, the walks becomes probabilistic in nature
and becomes an approximation of an exact walk.</li>
<li><strong>random_state</strong> (int = 42):
random_state to use to reproduce the walks.</li>
<li><strong>verbose</strong> (int = True):
whether to show or not the loading bar of the walks.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Triple with integer vectors of words and contexts and max-min normalized frequencies.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.node2vec" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.node2vec">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">node2vec</span><span class="signature">(
    self,
    batch_size: int,
    walk_length: int,
    window_size: int,
    **kwargs
) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">node2vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return training batches for Node2Vec models.</span>
<span class="sd">        </span>
<span class="sd">        The batch is composed of a tuple as the following:</span>
<span class="sd">        </span>
<span class="sd">        - (Contexts indices, central nodes indices): the tuple of nodes</span>
<span class="sd">        </span>
<span class="sd">        This does not provide any output value as the model uses NCE loss</span>
<span class="sd">        and basically the central nodes that are fed as inputs work as the</span>
<span class="sd">        outputs value.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        batch_size: int</span>
<span class="sd">            Number of walks to include within this batch.</span>
<span class="sd">            In some pathological cases, this might leed to an empty batch.</span>
<span class="sd">            These cases include graphs with particularly high number of traps.</span>
<span class="sd">            Consider using the method graph.report() to verify if this might</span>
<span class="sd">            apply to your use case.</span>
<span class="sd">        walk_length: int</span>
<span class="sd">            Maximal length of the random walk.</span>
<span class="sd">            On graphs without traps, all walks have this length.</span>
<span class="sd">        window_size: int</span>
<span class="sd">            Size of the window for local contexts.</span>
<span class="sd">        iterations: int = 1</span>
<span class="sd">            Number of iterations for each node.</span>
<span class="sd">        return_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of returning to node coming from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        dense_node_mapping: Dict[int, int]</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method available from graph</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        max_neighbours: int = None</span>
<span class="sd">            Maximum number of randomly sampled neighbours to consider.</span>
<span class="sd">            If this parameter is used, the walks becomes probabilistic in nature</span>
<span class="sd">            and becomes an approximation of an exact walk.</span>
<span class="sd">        random_state: int</span>
<span class="sd">            random_state to use to reproduce the walks.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        Tuple with vector of integer with contexts and words.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return training batches for Node2Vec models.</p>

<p>The batch is composed of a tuple as the following:</p>

<ul>
<li>(Contexts indices, central nodes indices): the tuple of nodes</li>
</ul>

<p>This does not provide any output value as the model uses NCE loss
and basically the central nodes that are fed as inputs work as the
outputs value.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>batch_size</strong> (int):
Number of walks to include within this batch.
In some pathological cases, this might leed to an empty batch.
These cases include graphs with particularly high number of traps.
Consider using the method graph.report() to verify if this might
apply to your use case.</li>
<li><strong>walk_length</strong> (int):
Maximal length of the random walk.
On graphs without traps, all walks have this length.</li>
<li><strong>window_size</strong> (int):
Size of the window for local contexts.</li>
<li><strong>iterations</strong> (int = 1):
Number of iterations for each node.</li>
<li><strong>return_weight</strong> (float = 1.0):
Weight on the probability of returning to node coming from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int]):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method available from graph
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>max_neighbours</strong> (int = None):
Maximum number of randomly sampled neighbours to consider.
If this parameter is used, the walks becomes probabilistic in nature
and becomes an approximation of an exact walk.</li>
<li><strong>random_state</strong> (int):
random_state to use to reproduce the walks.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with vector of integer with contexts and words.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_node_label_prediction_mini_batch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_node_label_prediction_mini_batch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_node_label_prediction_mini_batch</span><span class="signature">(
    self,
    idx: int,
    batch_size: Union[int, NoneType],
    include_central_node: Union[bool, NoneType],
    return_edge_weights: Union[bool, NoneType],
    max_neighbours: Union[int, NoneType]
) -&gt; Tuple[Tuple[List[List[int]], Union[List[List[float]], NoneType]], numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_label_prediction_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_central_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">max_neighbours</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return iterator over neighbours for the given node</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        `idx`: int - Seed for the batch.</span>
<span class="sd">        `batch_size`: Optional[int] = 1024 - The dimension of the batch.</span>
<span class="sd">        `include_central_node`: Optional[bool] - Whether to include the central node.</span>
<span class="sd">        `return_edge_weights`: Optional[bool] - Whether to return the edge weights.</span>
<span class="sd">        `max_neighbours`: Optional[int] - Maximal number of neighbours to sample.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        Tuple with input nodes, optionally edge weights and one-hot encoded node types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return iterator over neighbours for the given node</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><p><strong><code>idx</code></strong> (int - Seed for the batch.):</p></li>
<li><p><strong><code>batch_size</code></strong> (Optional[int] = 1024 - The dimension of the batch.):</p></li>
<li><p><strong><code>include_central_node</code></strong> (Optional[bool] - Whether to include the central node.):</p></li>
<li><p><strong><code>return_edge_weights</code></strong> (Optional[bool] - Whether to return the edge weights.):</p></li>
<li><p><strong><code>max_neighbours</code></strong> (Optional[int] - Maximal number of neighbours to sample.):</p></li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with input nodes, optionally edge weights and one-hot encoded node types.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_prediction_mini_batch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_prediction_mini_batch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_prediction_mini_batch</span><span class="signature">(
    self,
    idx: int,
    batch_size: Union[int, NoneType],
    negative_samples_rate: Union[float, NoneType],
    return_node_types: Union[bool, NoneType],
    return_edge_types: Union[bool, NoneType],
    return_edge_metrics: Union[bool, NoneType],
    avoid_false_negatives: Union[bool, NoneType],
    maximal_sampling_attempts: Union[int, NoneType],
    shuffle: Union[bool, NoneType],
    graph_to_avoid: Union[<a href="#ensmallen.Graph">grape.ensmallen.ensmallen.Graph</a>, NoneType]
) -&gt; Tuple[numpy.ndarray, Union[numpy.ndarray, NoneType], numpy.ndarray, Union[numpy.ndarray, NoneType], Union[numpy.ndarray, NoneType], Union[numpy.ndarray, NoneType], numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_prediction_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">return_node_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">return_edge_metrics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_sampling_attempts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">shuffle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Graph</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns n-ple with index to build numpy array, source node, source node type, destination node, destination node type, edge type and whether this edge is real or artificial.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        idx: int</span>
<span class="sd">            The index of the batch to generate, behaves like a random random_state,</span>
<span class="sd">        batch_size: Optional[int]</span>
<span class="sd">            The maximal size of the batch to generate,</span>
<span class="sd">        negative_samples: Optional[float]</span>
<span class="sd">            The component of netagetive samples to use.</span>
<span class="sd">        return_node_types: Optional[bool]</span>
<span class="sd">            Whether to return the source and destination nodes node types.</span>
<span class="sd">        return_edge_types: Optional[bool]</span>
<span class="sd">            Whether to return the edge types. The negative edges edge type will be samples at random.</span>
<span class="sd">        return_edge_metrics: Optional[bool]</span>
<span class="sd">            Whether to return the edge metrics.</span>
<span class="sd">        avoid_false_negatives: Optional[bool]</span>
<span class="sd">            Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.</span>
<span class="sd">        maximal_sampling_attempts: Optional[int]</span>
<span class="sd">            Number of attempts to execute to sample the negative edges.</span>
<span class="sd">        shuffle: Optional[bool]</span>
<span class="sd">            Whether to shuffle the samples within the batch.</span>
<span class="sd">        graph_to_avoid: Optional[Graph]</span>
<span class="sd">            The graph whose edges are to be avoided during the generation of false negatives,</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ---------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given amount of negative samples is not a positive finite real value.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If node types are requested but the graph does not contain any.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If node types are requested but the graph contains unknown node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types are requested but the graph does not contain any.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types are requested but the graph contains unknown edge types.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns n-ple with index to build numpy array, source node, source node type, destination node, destination node type, edge type and whether this edge is real or artificial.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>idx</strong> (int):
The index of the batch to generate, behaves like a random random_state,</li>
<li><strong>batch_size</strong> (Optional[int]):
The maximal size of the batch to generate,</li>
<li><strong>negative_samples</strong> (Optional[float]):
The component of netagetive samples to use.</li>
<li><strong>return_node_types</strong> (Optional[bool]):
Whether to return the source and destination nodes node types.</li>
<li><strong>return_edge_types</strong> (Optional[bool]):
Whether to return the edge types. The negative edges edge type will be samples at random.</li>
<li><strong>return_edge_metrics</strong> (Optional[bool]):
Whether to return the edge metrics.</li>
<li><strong>avoid_false_negatives</strong> (Optional[bool]):
Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.</li>
<li><strong>maximal_sampling_attempts</strong> (Optional[int]):
Number of attempts to execute to sample the negative edges.</li>
<li><strong>shuffle</strong> (Optional[bool]):
Whether to shuffle the samples within the batch.</li>
<li><strong>graph_to_avoid</strong> (Optional[Graph]):
The graph whose edges are to be avoided during the generation of false negatives,</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If the given amount of negative samples is not a positive finite real value.</li>
<li><strong>ValueError</strong>: If node types are requested but the graph does not contain any.</li>
<li><strong>ValueError</strong>: If node types are requested but the graph contains unknown node types.</li>
<li><strong>ValueError</strong>: If edge types are requested but the graph does not contain any.</li>
<li><strong>ValueError</strong>: If edge types are requested but the graph contains unknown edge types.</li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_unchecked_edge_prediction_metrics" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_unchecked_edge_prediction_metrics">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_unchecked_edge_prediction_metrics</span><span class="signature">(
    self,
    source_node_ids: List[int],
    destination_node_ids: List[int],
    normalize: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_unchecked_edge_prediction_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destination_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all available edge prediction metrics for given edges.</span>
<span class="sd">        </span>
<span class="sd">        The metrics returned are, in order:</span>
<span class="sd">        - Adamic Adar index</span>
<span class="sd">        - Jaccard Coefficient</span>
<span class="sd">        - Resource Allocation index</span>
<span class="sd">        - Normalized preferential attachment score</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_ids: List[int]</span>
<span class="sd">            List of source node IDs.</span>
<span class="sd">        destination_node_ids: List[int]</span>
<span class="sd">            List of destination node IDs.</span>
<span class="sd">        normalize: Optional[bool] = True</span>
<span class="sd">            Whether to normalize the metrics.</span>
<span class="sd">        verbose: Optional[bool] = True</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array with metrics.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns all available edge prediction metrics for given edges.</p>

<p>The metrics returned are, in order:</p>

<ul>
<li>Adamic Adar index</li>
<li>Jaccard Coefficient</li>
<li>Resource Allocation index</li>
<li>Normalized preferential attachment score</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>source_node_ids</strong> (List[int]):
List of source node IDs.</li>
<li><strong>destination_node_ids</strong> (List[int]):
List of destination node IDs.</li>
<li><strong>normalize</strong> (Optional[bool] = True):
Whether to normalize the metrics.</li>
<li><strong>verbose</strong> (Optional[bool] = True):
Whether to show a loading bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>2D numpy array with metrics.</strong></li>
</ul>
</div>


                            </div>
                            <div id="Graph.get_edge_prediction_metrics" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Graph.get_edge_prediction_metrics">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_edge_prediction_metrics</span><span class="signature">(
    self,
    normalize: Union[bool, NoneType],
    verbose: Union[bool, NoneType]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_edge_prediction_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns all available edge prediction metrics for given edges.</span>
<span class="sd">        </span>
<span class="sd">        The metrics returned are, in order:</span>
<span class="sd">        - Adamic Adar index</span>
<span class="sd">        - Jaccard Coefficient</span>
<span class="sd">        - Resource Allocation index</span>
<span class="sd">        - Normalized preferential attachment score</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool] = True</span>
<span class="sd">            Whether to normalize the metrics.</span>
<span class="sd">        verbose: Optional[bool] = True</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array with metrics.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns all available edge prediction metrics for given edges.</p>

<p>The metrics returned are, in order:</p>

<ul>
<li>Adamic Adar index</li>
<li>Jaccard Coefficient</li>
<li>Resource Allocation index</li>
<li>Normalized preferential attachment score</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>normalize</strong> (Optional[bool] = True):
Whether to normalize the metrics.</li>
<li><strong>verbose</strong> (Optional[bool] = True):
Whether to show a loading bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>2D numpy array with metrics.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="preprocessing">
                                <div class="attr module"><a class="headerlink" href="#preprocessing">#&nbsp;&nbsp</a>
<span class="name">grape.ensmallen.ensmallen.preprocessing</span></div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>



<span class="k">def</span> <span class="nf">okapi_bm25_tfidf_int</span><span class="p">(</span><span class="n">documents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">vocabulary_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Return vocabulary and TFIDF matrix of given documents.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    documents: List[List[str]],</span>
<span class="sd">        The documents to parse</span>
<span class="sd">    k1: Optional[float]</span>
<span class="sd">        The default parameter for k1, tipically between 1.2 and 2.0.</span>
<span class="sd">    b: Optional[float]</span>
<span class="sd">        The default parameter for b, tipically equal to 0.75.</span>
<span class="sd">    vocabulary_size: Optional[int]</span>
<span class="sd">        The expected vocabulary size.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show a loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">okapi_bm25_tfidf_str</span><span class="p">(</span><span class="n">documents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">vocabulary_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Return vocabulary and TFIDF matrix of given documents.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    documents: List[List[str]],</span>
<span class="sd">        The documents to parse</span>
<span class="sd">    k1: Optional[float]</span>
<span class="sd">        The default parameter for k1, tipically between 1.2 and 2.0.</span>
<span class="sd">    b: Optional[float]</span>
<span class="sd">        The default parameter for b, tipically equal to 0.75.</span>
<span class="sd">    vocabulary_size: Optional[int]</span>
<span class="sd">        The expected vocabulary size.</span>
<span class="sd">    verbose: Optional[bool]</span>
<span class="sd">        Whether to show a loading bar.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">word2vec</span><span class="p">(</span><span class="n">sequences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return training batches for Word2Vec models.</span>
<span class="sd">    </span>
<span class="sd">    The batch is composed of a tuple as the following:</span>
<span class="sd">    </span>
<span class="sd">    - (Contexts indices, central nodes indices): the tuple of nodes</span>
<span class="sd">    </span>
<span class="sd">    This does not provide any output value as the model uses NCE loss</span>
<span class="sd">    and basically the central nodes that are fed as inputs work as the</span>
<span class="sd">    outputs value.</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    </span>
<span class="sd">    sequences: List[List[int]]</span>
<span class="sd">        the sequence of sequences of integers to preprocess.</span>
<span class="sd">    window_size: int</span>
<span class="sd">        Window size to consider for the sequences.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>

        </details>

    

                </section>
                <section id="datasets">
                                <div class="attr module"><a class="headerlink" href="#datasets">#&nbsp;&nbsp</a>
<span class="name"><a href="ensmallen/datasets.html">grape.ensmallen.datasets</a></span></div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;Module with datasets.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="p">(</span><span class="n">kghub</span><span class="p">,</span> <span class="n">linqs</span><span class="p">,</span> <span class="n">monarchinitiative</span><span class="p">,</span> <span class="n">networkrepository</span><span class="p">,</span>
               <span class="n">pheknowlatorkg</span><span class="p">,</span> <span class="n">yue</span><span class="p">,</span> <span class="n">zenodo</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.get_dataset</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_all_available_graphs_dataframe</span><span class="p">,</span>
                          <span class="n">get_available_graphs_from_repository</span><span class="p">,</span>
                          <span class="n">get_available_repositories</span><span class="p">,</span>
                          <span class="n">get_available_versions_from_graph_and_repository</span><span class="p">,</span>
                          <span class="n">validate_graph_version</span><span class="p">,</span>
                          <span class="n">get_dataset</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;get_dataset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_available_repositories&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_available_graphs_from_repository&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_all_available_graphs_dataframe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_available_versions_from_graph_and_repository&quot;</span><span class="p">,</span>
    <span class="s2">&quot;validate_graph_version&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kghub&quot;</span><span class="p">,</span> <span class="s2">&quot;linqs&quot;</span><span class="p">,</span> <span class="s2">&quot;monarchinitiative&quot;</span><span class="p">,</span>
    <span class="s2">&quot;networkrepository&quot;</span><span class="p">,</span> <span class="s2">&quot;yue&quot;</span><span class="p">,</span> <span class="s2">&quot;zenodo&quot;</span><span class="p">,</span> <span class="s2">&quot;pheknowlatorkg&quot;</span>
<span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Module with datasets.</p>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>