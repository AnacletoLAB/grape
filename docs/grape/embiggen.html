<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.0" />
    <title>grape.embiggen API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../grape.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;grape</a>

                        <img src="https://raw.githubusercontent.com/AnacletoLAB/grape/main/images/GRAPE.jpg" class="logo" alt="project logo"/>

                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#CBOW">CBOW</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CBOW.__init__">CBOW</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SkipGram">SkipGram</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SkipGram.__init__">SkipGram</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GloVe">GloVe</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GloVe.__init__">GloVe</a>
                        </li>
                        <li>
                                <a class="function" href="#GloVe.fit">fit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphCBOW">GraphCBOW</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphCBOW.__init__">GraphCBOW</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphSkipGram">GraphSkipGram</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphSkipGram.__init__">GraphSkipGram</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphGloVe">GraphGloVe</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphGloVe.__init__">GraphGloVe</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphGloVe.get_embedding_dataframe">get_embedding_dataframe</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphGloVe.fit">fit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Word2VecSequence">Word2VecSequence</a>
                            <ul class="memberlist">
                </ul>

            </li>
            <li>
                    <a class="class" href="#NodeTransformer">NodeTransformer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#NodeTransformer.__init__">NodeTransformer</a>
                        </li>
                        <li>
                                <a class="variable" href="#NodeTransformer.numeric_node_ids">numeric_node_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#NodeTransformer.fit">fit</a>
                        </li>
                        <li>
                                <a class="function" href="#NodeTransformer.transform">transform</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#EdgeTransformer">EdgeTransformer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#EdgeTransformer.__init__">EdgeTransformer</a>
                        </li>
                        <li>
                                <a class="variable" href="#EdgeTransformer.methods">methods</a>
                        </li>
                        <li>
                                <a class="variable" href="#EdgeTransformer.numeric_node_ids">numeric_node_ids</a>
                        </li>
                        <li>
                                <a class="variable" href="#EdgeTransformer.method">method</a>
                        </li>
                        <li>
                                <a class="function" href="#EdgeTransformer.fit">fit</a>
                        </li>
                        <li>
                                <a class="function" href="#EdgeTransformer.transform">transform</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphTransformer">GraphTransformer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphTransformer.__init__">GraphTransformer</a>
                        </li>
                        <li>
                                <a class="variable" href="#GraphTransformer.numeric_node_ids">numeric_node_ids</a>
                        </li>
                        <li>
                                <a class="variable" href="#GraphTransformer.method">method</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphTransformer.fit">fit</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphTransformer.transform">transform</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#CorpusTransformer">CorpusTransformer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CorpusTransformer.__init__">CorpusTransformer</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.get_synonym">get_synonym</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.split_line">split_line</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.tokenize_line">tokenize_line</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.tokenize_lines">tokenize_lines</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.tokenize">tokenize</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.parse_tokens_for_low_frequency">parse_tokens_for_low_frequency</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.fit">fit</a>
                        </li>
                        <li>
                                <a class="variable" href="#CorpusTransformer.vocabulary_size">vocabulary_size</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.reverse_transform">reverse_transform</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.get_word_id">get_word_id</a>
                        </li>
                        <li>
                                <a class="function" href="#CorpusTransformer.transform">transform</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#LinkPredictionTransformer">LinkPredictionTransformer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LinkPredictionTransformer.__init__">LinkPredictionTransformer</a>
                        </li>
                        <li>
                                <a class="function" href="#LinkPredictionTransformer.fit">fit</a>
                        </li>
                        <li>
                                <a class="function" href="#LinkPredictionTransformer.transform">transform</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphVisualization">GraphVisualization</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphVisualization.__init__">GraphVisualization</a>
                        </li>
                        <li>
                                <a class="variable" href="#GraphVisualization.DEFAULT_SCATTER_KWARGS">DEFAULT_SCATTER_KWARGS</a>
                        </li>
                        <li>
                                <a class="variable" href="#GraphVisualization.DEFAULT_SUBPLOT_KWARGS">DEFAULT_SUBPLOT_KWARGS</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.decompose">decompose</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.fit_transform_nodes">fit_transform_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.fit_transform_edges">fit_transform_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_edge_segments">plot_edge_segments</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_nodes">plot_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.annotate_nodes">annotate_nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_edges">plot_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_node_types">plot_node_types</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_connected_components">plot_connected_components</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_node_degrees">plot_node_degrees</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_edge_types">plot_edge_types</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_edge_weights">plot_edge_weights</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphVisualization.plot_dot">plot_dot</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TransE">TransE</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TransE.__init__">TransE</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TransH">TransH</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TransH.__init__">TransH</a>
                        </li>
                        <li>
                                <a class="function" href="#TransH.fit">fit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TransR">TransR</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TransR.__init__">TransR</a>
                        </li>
                        <li>
                                <a class="function" href="#TransR.fit">fit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SimplE">SimplE</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SimplE.__init__">SimplE</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Siamese">Siamese</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Siamese.__init__">Siamese</a>
                        </li>
                        <li>
                                <a class="variable" href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">NODE_TYPE_EMBEDDING_LAYER_NAME</a>
                        </li>
                        <li>
                                <a class="variable" href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">EDGE_TYPE_EMBEDDING_LAYER_NAME</a>
                        </li>
                        <li>
                                <a class="function" href="#Siamese.get_embedding_dataframe">get_embedding_dataframe</a>
                        </li>
                        <li>
                                <a class="variable" href="#Siamese.embedding">embedding</a>
                        </li>
                        <li>
                                <a class="function" href="#Siamese.fit">fit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GraphConvolutionalNeuralNetwork">GraphConvolutionalNeuralNetwork</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.__init__">GraphConvolutionalNeuralNetwork</a>
                        </li>
                        <li>
                                <a class="variable" href="#GraphConvolutionalNeuralNetwork.name">name</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.summary">summary</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.run_batch_size_check">run_batch_size_check</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.fit">fit</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.predict">predict</a>
                        </li>
                        <li>
                                <a class="function" href="#GraphConvolutionalNeuralNetwork.evaluate">evaluate</a>
                        </li>
                </ul>

            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../grape.html">grape</a><wbr>.embiggen    </h1>

                        <div class="docstring"><p>Module with models for graph and text embedding and their Keras Sequences.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;Module with models for graph and text embedding and their Keras Sequences.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">.embedders</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CBOW</span><span class="p">,</span> <span class="n">GloVe</span><span class="p">,</span> <span class="n">GraphCBOW</span><span class="p">,</span> <span class="n">GraphGloVe</span><span class="p">,</span> <span class="n">GraphSkipGram</span><span class="p">,</span>
    <span class="n">SkipGram</span><span class="p">,</span> <span class="n">TransE</span><span class="p">,</span> <span class="n">TransH</span><span class="p">,</span> <span class="n">TransR</span><span class="p">,</span> <span class="n">SimplE</span><span class="p">,</span> <span class="n">Siamese</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.node_prediction</span> <span class="kn">import</span> <span class="n">GraphConvolutionalNeuralNetwork</span>
<span class="kn">from</span> <span class="nn">.sequences</span> <span class="kn">import</span> <span class="n">Word2VecSequence</span>
<span class="kn">from</span> <span class="nn">.transformers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">CorpusTransformer</span><span class="p">,</span> <span class="n">EdgeTransformer</span><span class="p">,</span>
                           <span class="n">GraphTransformer</span><span class="p">,</span> <span class="n">LinkPredictionTransformer</span><span class="p">,</span>
                           <span class="n">NodeTransformer</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.visualizations</span> <span class="kn">import</span> <span class="n">GraphVisualization</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;CBOW&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SkipGram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GloVe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphCBOW&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphSkipGram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphGloVe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Word2VecSequence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NodeTransformer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;EdgeTransformer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphTransformer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CorpusTransformer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LinkPredictionTransformer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphVisualization&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TransE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TransH&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TransR&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SimplE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Siamese&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GraphConvolutionalNeuralNetwork&quot;</span>
<span class="p">]</span>
</pre></div>

        </details>

            </section>
                <section id="CBOW">
                                <div class="attr class">
        <a class="headerlink" href="#CBOW">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">CBOW</span><wbr>(<span class="base">grape.embiggen.embedders.embedder.Embedder</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CBOW</span><span class="p">(</span><span class="n">Embedder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;CBOW model for sequence embedding.</span>

<span class="sd">    The CBOW model for graoh embedding receives a list of contexts and tries</span>
<span class="sd">    to predict the central word. The model makes use of an NCE loss layer</span>
<span class="sd">    during the training process to generate the negatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to parent constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO! Figure out a way to test for Zifian distribution in the</span>
        <span class="c1"># data used for the word2vec sampling! The values in the vocabulary</span>
        <span class="c1"># should have a decreasing node degree order!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span> <span class="o">=</span> <span class="n">negative_samples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return CBOW model.&quot;&quot;&quot;</span>
        <span class="c1"># Creating the inputs layers</span>

        <span class="c1"># Create first the input with the central terms</span>
        <span class="n">central_terms_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CentralTermsInput&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Then we create the input of the contextual terms</span>
        <span class="n">contextual_terms_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ContextualTermsInput&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Creating the embedding layer for the contexts</span>
        <span class="n">contextual_terms_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">contextual_terms_input</span><span class="p">)</span>

        <span class="n">contextual_embedding</span> <span class="o">=</span> <span class="n">GlobalAveragePooling1D</span><span class="p">()(</span>
            <span class="n">contextual_terms_embedding</span>
        <span class="p">)</span>

        <span class="c1"># Adding layer that also executes the loss function</span>
        <span class="n">sampled_softmax</span> <span class="o">=</span> <span class="n">SampledSoftmax</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span><span class="p">,</span>
        <span class="p">)((</span><span class="n">contextual_embedding</span><span class="p">,</span> <span class="n">central_terms_input</span><span class="p">))</span>

        <span class="c1"># Creating the actual model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">contextual_terms_input</span><span class="p">,</span> <span class="n">central_terms_input</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">sampled_softmax</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CBOW&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compile model.&quot;&quot;&quot;</span>
        <span class="c1"># No loss function is needed because it is already executed in</span>
        <span class="c1"># the Sampled Softmax loss layer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>CBOW model for sequence embedding.</p>

<p>The CBOW model for graoh embedding receives a list of contexts and tries
to predict the central word. The model makes use of an NCE loss layer
during the training process to generate the negatives.</p>
</div>


                            <div id="CBOW.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CBOW.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">CBOW</span><span class="signature">(
    window_size: int = 4,
    negative_samples: int = 10,
    use_gradient_centralization: bool = True,
    **kwargs: Dict
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to parent constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO! Figure out a way to test for Zifian distribution in the</span>
        <span class="c1"># data used for the word2vec sampling! The values in the vocabulary</span>
        <span class="c1"># should have a decreasing node degree order!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span> <span class="o">=</span> <span class="n">negative_samples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>negative_samples</strong> (int = 10,):
The number of negative classes to randomly sample per batch.
This single sample of negative classes is evaluated for each element in the batch.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to parent constructor.</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="CBOW.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="CBOW.trainable" class="variable">trainable</dd>
                <dd id="CBOW.summary" class="function">summary</dd>
                <dd id="CBOW.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="CBOW.embedding" class="variable">embedding</dd>
                <dd id="CBOW.get_embedding_dataframe" class="function">get_embedding_dataframe</dd>
                <dd id="CBOW.save_embedding" class="function">save_embedding</dd>
                <dd id="CBOW.name" class="variable">name</dd>
                <dd id="CBOW.save_weights" class="function">save_weights</dd>
                <dd id="CBOW.load_weights" class="function">load_weights</dd>
                <dd id="CBOW.fit" class="function">fit</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SkipGram">
                                <div class="attr class">
        <a class="headerlink" href="#SkipGram">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SkipGram</span><wbr>(<span class="base">grape.embiggen.embedders.embedder.Embedder</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SkipGram</span><span class="p">(</span><span class="n">Embedder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;SkipGram model for sequence embedding.</span>

<span class="sd">    The SkipGram model for graoh embedding receives a central word and tries</span>
<span class="sd">    to predict its contexts. The model makes use of an NCE loss layer</span>
<span class="sd">    during the training process to generate the negatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to parent constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO! Figure out a way to test for Zifian distribution in the</span>
        <span class="c1"># data used for the word2vec sampling! The values in the vocabulary</span>
        <span class="c1"># should have a decreasing node degree order!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span> <span class="o">=</span> <span class="n">negative_samples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return SkipGram model.&quot;&quot;&quot;</span>
        <span class="c1"># Creating the inputs layers</span>

        <span class="c1"># Create first the input with the central terms</span>
        <span class="n">central_terms_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CentralTermsInput&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Then we create the input of the contextual terms</span>
        <span class="n">contextual_terms_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ContextualTermsInput&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Creating the embedding layer for the contexts</span>
        <span class="n">central_terms_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">central_terms_input</span><span class="p">)</span>

        <span class="n">central_embedding</span> <span class="o">=</span> <span class="n">Flatten</span><span class="p">()(</span>
            <span class="n">central_terms_embedding</span>
        <span class="p">)</span>

        <span class="c1"># Adding layer that also executes the loss function</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">NoiseContrastiveEstimation</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span><span class="p">,</span>
            <span class="n">positive_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="o">*</span><span class="mi">2</span>
        <span class="p">)((</span><span class="n">central_embedding</span><span class="p">,</span> <span class="n">contextual_terms_input</span><span class="p">))</span>

        <span class="c1"># Creating the actual model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">contextual_terms_input</span><span class="p">,</span> <span class="n">central_terms_input</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;SkipGram&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compile model.&quot;&quot;&quot;</span>
        <span class="c1"># No loss function is needed because it is already executed in</span>
        <span class="c1"># the Noise Contrastive Estimation loss layer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>SkipGram model for sequence embedding.</p>

<p>The SkipGram model for graoh embedding receives a central word and tries
to predict its contexts. The model makes use of an NCE loss layer
during the training process to generate the negatives.</p>
</div>


                            <div id="SkipGram.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SkipGram.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SkipGram</span><span class="signature">(
    window_size: int = 4,
    negative_samples: int = 10,
    use_gradient_centralization: bool = True,
    **kwargs: Dict
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to parent constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO! Figure out a way to test for Zifian distribution in the</span>
        <span class="c1"># data used for the word2vec sampling! The values in the vocabulary</span>
        <span class="c1"># should have a decreasing node degree order!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_samples</span> <span class="o">=</span> <span class="n">negative_samples</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>negative_samples</strong> (int = 10,):
The number of negative classes to randomly sample per batch.
This single sample of negative classes is evaluated for each element in the batch.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to parent constructor.</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="SkipGram.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="SkipGram.trainable" class="variable">trainable</dd>
                <dd id="SkipGram.summary" class="function">summary</dd>
                <dd id="SkipGram.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="SkipGram.embedding" class="variable">embedding</dd>
                <dd id="SkipGram.get_embedding_dataframe" class="function">get_embedding_dataframe</dd>
                <dd id="SkipGram.save_embedding" class="function">save_embedding</dd>
                <dd id="SkipGram.name" class="variable">name</dd>
                <dd id="SkipGram.save_weights" class="function">save_weights</dd>
                <dd id="SkipGram.load_weights" class="function">load_weights</dd>
                <dd id="SkipGram.fit" class="function">fit</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GloVe">
                                <div class="attr class">
        <a class="headerlink" href="#GloVe">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GloVe</span><wbr>(<span class="base">grape.embiggen.embedders.embedder.Embedder</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GloVe</span><span class="p">(</span><span class="n">Embedder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;GloVe model for graph and words embedding.</span>

<span class="sd">    The GloVe model for graph embedding receives two words and is asked to</span>
<span class="sd">    predict its cooccurrence probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vocabulary_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------</span>
<span class="sd">        vocabulary_size: int,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">        embedding_size: int,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        alpha: float = 0.75,</span>
<span class="sd">            Alpha to use for the function.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        directed: bool = False,</span>
<span class="sd">            Whether to treat the data as directed or not.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_directed</span> <span class="o">=</span> <span class="n">directed</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="n">vocabulary_size</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_glove_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute the glove loss function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        y_true: tf.Tensor,</span>
<span class="sd">            The true values Tensor for this batch.</span>
<span class="sd">        y_pred: tf.Tensor,</span>
<span class="sd">            The predicted values Tensor for this batch.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        Loss function score related to this batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">K</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_true</span><span class="p">)),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new Glove model.&quot;&quot;&quot;</span>
        <span class="c1"># Creating the input layers</span>
        <span class="n">left_input_layer</span> <span class="o">=</span> <span class="n">Input</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;left_input_layer&quot;</span><span class="p">)</span>
        <span class="n">right_input_layer</span> <span class="o">=</span> <span class="n">Input</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;right_input_layer&quot;</span><span class="p">)</span>

        <span class="n">trainable_left_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span>
            <span class="p">],</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span>
        <span class="p">)(</span><span class="n">left_input_layer</span><span class="p">)</span>

        <span class="n">trainable_right_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">right_input_layer</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_features_matrix</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_extra_features</span><span class="p">,</span>
                <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extra_features</span><span class="p">,</span>
                <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;extra_features_matrix&quot;</span>
            <span class="p">)</span>
            <span class="n">trainable_left_embedding</span> <span class="o">=</span> <span class="n">Concatenate</span><span class="p">()([</span>
                <span class="n">extra_features_matrix</span><span class="p">(</span><span class="n">left_input_layer</span><span class="p">),</span>
                <span class="n">trainable_left_embedding</span>
            <span class="p">])</span>
            <span class="n">trainable_right_embedding</span> <span class="o">=</span> <span class="n">Concatenate</span><span class="p">()([</span>
                <span class="n">extra_features_matrix</span><span class="p">(</span><span class="n">right_input_layer</span><span class="p">),</span>
                <span class="n">trainable_right_embedding</span>
            <span class="p">])</span>

        <span class="c1"># Creating the dot product of the embedding layers</span>
        <span class="n">dot_product_layer</span> <span class="o">=</span> <span class="n">Dot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">)([</span>
            <span class="n">trainable_left_embedding</span><span class="p">,</span>
            <span class="n">trainable_right_embedding</span>
        <span class="p">])</span>

        <span class="c1"># Creating the biases layer</span>
        <span class="n">biases</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Embedding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">input_layer</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">input_layer</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left_input_layer</span><span class="p">,</span> <span class="n">right_input_layer</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Concatenating with an add the three layers</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">Add</span><span class="p">()([</span><span class="n">dot_product_layer</span><span class="p">,</span> <span class="o">*</span><span class="n">biases</span><span class="p">]))</span>

        <span class="c1"># Creating the model</span>
        <span class="n">glove</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span>
                <span class="n">left_input_layer</span><span class="p">,</span>
                <span class="n">right_input_layer</span>
            <span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">prediction</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;GloVe&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">glove</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compile model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_glove_loss</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        X: Tuple[np.ndarray, np.ndarray],</span>
<span class="sd">            Tuple with source and destinations.</span>
<span class="sd">        frequencies: np.ndarray,</span>
<span class="sd">            The frequencies to predict.</span>
<span class="sd">        *args: List,</span>
<span class="sd">            Other arguments to provide to the model.</span>
<span class="sd">        epochs: int = 1000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        batch_size: int = 2**20,</span>
<span class="sd">            The batch size.</span>
<span class="sd">            Tipically batch sizes for the GloVe model can be immense.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.001,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 0.01,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 1,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">GloveSequence</span><span class="p">(</span>
                <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">directed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_directed</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>GloVe model for graph and words embedding.</p>

<p>The GloVe model for graph embedding receives two words and is asked to
predict its cooccurrence probability.</p>
</div>


                            <div id="GloVe.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GloVe.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GloVe</span><span class="signature">(
    vocabulary_size: int,
    embedding_size: int,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    alpha: float = 0.75,
    random_state: int = 42,
    directed: bool = False,
    use_gradient_centralization: bool = True
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vocabulary_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------</span>
<span class="sd">        vocabulary_size: int,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">        embedding_size: int,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        alpha: float = 0.75,</span>
<span class="sd">            Alpha to use for the function.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        directed: bool = False,</span>
<span class="sd">            Whether to treat the data as directed or not.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_directed</span> <span class="o">=</span> <span class="n">directed</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="n">vocabulary_size</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new GloVe-based Embedder object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.</li>
<li><strong>embedding_size</strong> (int,):
Dimension of the embedding.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.
By default, if None is provided, Nadam with learning rate
set at 0.01 is used.</li>
<li><strong>alpha</strong> (float = 0.75,):
Alpha to use for the function.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to reproduce the training sequence.</li>
<li><strong>directed</strong> (bool = False,):
Whether to treat the data as directed or not.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div id="GloVe.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GloVe.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    X: Tuple[numpy.ndarray, numpy.ndarray],
    frequencies: numpy.ndarray,
    *args: List,
    epochs: int = 1000,
    batch_size: int = 1048576,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_min_delta: float = 0.001,
    early_stopping_patience: int = 10,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_min_delta: float = 0.01,
    reduce_lr_patience: int = 10,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 1,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        X: Tuple[np.ndarray, np.ndarray],</span>
<span class="sd">            Tuple with source and destinations.</span>
<span class="sd">        frequencies: np.ndarray,</span>
<span class="sd">            The frequencies to predict.</span>
<span class="sd">        *args: List,</span>
<span class="sd">            Other arguments to provide to the model.</span>
<span class="sd">        epochs: int = 1000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        batch_size: int = 2**20,</span>
<span class="sd">            The batch size.</span>
<span class="sd">            Tipically batch sizes for the GloVe model can be immense.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.001,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 0.01,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 1,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">GloveSequence</span><span class="p">(</span>
                <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">directed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_directed</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>X</strong> (Tuple[np.ndarray, np.ndarray],):
Tuple with source and destinations.</li>
<li><strong>frequencies</strong> (np.ndarray,):
The frequencies to predict.</li>
<li><strong>*args</strong> (List,):
Other arguments to provide to the model.</li>
<li><strong>epochs</strong> (int = 1000,):
Epochs to train the model for.</li>
<li><strong>batch_size</strong> (int = 2**20,):
The batch size.
Tipically batch sizes for the GloVe model can be immense.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_min_delta</strong> (float = 0.001,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int = 10,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_min_delta</strong> (float = 0.01,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int = 10,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 1,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If given verbose value is not within the available set (-1, 0, 1).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="GloVe.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="GloVe.trainable" class="variable">trainable</dd>
                <dd id="GloVe.summary" class="function">summary</dd>
                <dd id="GloVe.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="GloVe.embedding" class="variable">embedding</dd>
                <dd id="GloVe.get_embedding_dataframe" class="function">get_embedding_dataframe</dd>
                <dd id="GloVe.save_embedding" class="function">save_embedding</dd>
                <dd id="GloVe.name" class="variable">name</dd>
                <dd id="GloVe.save_weights" class="function">save_weights</dd>
                <dd id="GloVe.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GraphCBOW">
                                <div class="attr class">
        <a class="headerlink" href="#GraphCBOW">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphCBOW</span><wbr>(<span class="base">grape.embiggen.embedders.node2vec.Node2Vec</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphCBOW</span><span class="p">(</span><span class="n">Node2Vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;GraphCBOW model for graph embedding.</span>

<span class="sd">    The GraphCBOW model for graoh embedding receives a list of contexts and tries</span>
<span class="sd">    to predict the central word. The model makes use of an NCE loss layer</span>
<span class="sd">    during the training process to generate the negatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to be embedded.</span>
<span class="sd">        word2vec_model: Word2Vec,</span>
<span class="sd">            Word2Vec model to use.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = None,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        batch_size: int = 256,</span>
<span class="sd">            Number of nodes to include in a single batch.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The given graph does not have the nodes sorted by decreasing &quot;</span>
                <span class="s2">&quot;order, therefore the NCE loss sampling (which follows a zipfian &quot;</span>
                <span class="s2">&quot;distribution) would not approximate well the Softmax.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to sort the given graph in such a way that the node IDs &quot;</span>
                <span class="s2">&quot;are sorted by decreasing outbound node degrees, you can use &quot;</span>
                <span class="s2">&quot;the Graph method &quot;</span>
                <span class="s2">&quot;`graph.sort_by_decreasing_outbound_node_degree()`&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">word2vec_model</span><span class="o">=</span><span class="n">CBOW</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="n">negative_samples</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="n">walk_length</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="n">return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="n">explore_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="n">change_node_type_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="n">change_edge_type_weight</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="n">max_neighbours</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="n">dense_node_mapping</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>GraphCBOW model for graph embedding.</p>

<p>The GraphCBOW model for graoh embedding receives a list of contexts and tries
to predict the central word. The model makes use of an NCE loss layer
during the training process to generate the negatives.</p>
</div>


                            <div id="GraphCBOW.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphCBOW.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphCBOW</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    negative_samples: int = 10,
    walk_length: int = 128,
    batch_size: int = 256,
    iterations: int = 16,
    window_size: int = 4,
    return_weight: float = 1.0,
    explore_weight: float = 1.0,
    change_node_type_weight: float = 1.0,
    change_edge_type_weight: float = 1.0,
    max_neighbours: int = None,
    elapsed_epochs: int = 0,
    support_mirrored_strategy: bool = False,
    random_state: int = 42,
    dense_node_mapping: Dict[int, int] = None,
    use_gradient_centralization: bool = True
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to be embedded.</span>
<span class="sd">        word2vec_model: Word2Vec,</span>
<span class="sd">            Word2Vec model to use.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = None,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        batch_size: int = 256,</span>
<span class="sd">            Number of nodes to include in a single batch.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The given graph does not have the nodes sorted by decreasing &quot;</span>
                <span class="s2">&quot;order, therefore the NCE loss sampling (which follows a zipfian &quot;</span>
                <span class="s2">&quot;distribution) would not approximate well the Softmax.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to sort the given graph in such a way that the node IDs &quot;</span>
                <span class="s2">&quot;are sorted by decreasing outbound node degrees, you can use &quot;</span>
                <span class="s2">&quot;the Graph method &quot;</span>
                <span class="s2">&quot;`graph.sort_by_decreasing_outbound_node_degree()`&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">word2vec_model</span><span class="o">=</span><span class="n">CBOW</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="n">negative_samples</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="n">walk_length</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="n">return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="n">explore_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="n">change_node_type_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="n">change_edge_type_weight</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="n">max_neighbours</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="n">dense_node_mapping</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
Graph to be embedded.</li>
<li><strong>word2vec_model</strong> (Word2Vec,):
Word2Vec model to use.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = None,):
The optimizer to be used during the training of the model.
By default, if None is provided, Nadam with learning rate
set at 0.01 is used.</li>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>negative_samples</strong> (int = 10,):
The number of negative classes to randomly sample per batch.
This single sample of negative classes is evaluated for each element in the batch.</li>
<li><strong>walk_length</strong> (int = 128,):
Maximal length of the walks.</li>
<li><strong>batch_size</strong> (int = 256,):
Number of nodes to include in a single batch.</li>
<li><strong>iterations</strong> (int = 16,):
Number of iterations of the single walks.</li>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>return_weight</strong> (float = 1.0,):
Weight on the probability of returning to the same node the walk just came from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>max_neighbours</strong> (int = None,):
Number of maximum neighbours to consider when using approximated walks.
By default, None, we execute exact random walks.
This is mainly useful for graphs containing nodes with extremely high degrees.</li>
<li><strong>elapsed_epochs</strong> (int = 0,):
Number of elapsed epochs to init state of generator.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to reproduce the training sequence.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None,):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method (available from the
graph object created using Graph)
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.node2vec.Node2Vec</dt>
                                <dd id="GraphCBOW.fit" class="function">fit</dd>
                <dd id="GraphCBOW.summary" class="function">summary</dd>
                <dd id="GraphCBOW.embedding" class="variable">embedding</dd>
                <dd id="GraphCBOW.trainable" class="variable">trainable</dd>
                <dd id="GraphCBOW.get_embedding_dataframe" class="function">get_embedding_dataframe</dd>
                <dd id="GraphCBOW.save_embedding" class="function">save_embedding</dd>
                <dd id="GraphCBOW.name" class="variable">name</dd>
                <dd id="GraphCBOW.save_weights" class="function">save_weights</dd>
                <dd id="GraphCBOW.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GraphSkipGram">
                                <div class="attr class">
        <a class="headerlink" href="#GraphSkipGram">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphSkipGram</span><wbr>(<span class="base">grape.embiggen.embedders.node2vec.Node2Vec</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphSkipGram</span><span class="p">(</span><span class="n">Node2Vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;GraphSkipGram model for graph embedding.</span>

<span class="sd">    The SkipGram model for graoh embedding receives a central word and tries</span>
<span class="sd">    to predict its contexts. The model makes use of an NCE loss layer</span>
<span class="sd">    during the training process to generate the negatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to be embedded.</span>
<span class="sd">        word2vec_model: Word2Vec,</span>
<span class="sd">            Word2Vec model to use.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = None,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        batch_size: int = 256,</span>
<span class="sd">            Number of nodes to include in a single batch.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The given graph does not have the nodes sorted by decreasing &quot;</span>
                <span class="s2">&quot;order, therefore the NCE loss sampling (which follows a zipfian &quot;</span>
                <span class="s2">&quot;distribution) would not approximate well the Softmax.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to sort the given graph in such a way that the node IDs &quot;</span>
                <span class="s2">&quot;are sorted by decreasing outbound node degrees, you can use &quot;</span>
                <span class="s2">&quot;the Graph method &quot;</span>
                <span class="s2">&quot;`graph.sort_by_decreasing_outbound_node_degree()`&quot;</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">word2vec_model</span><span class="o">=</span><span class="n">SkipGram</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="n">negative_samples</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="n">walk_length</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="n">return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="n">explore_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="n">change_node_type_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="n">change_edge_type_weight</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="n">max_neighbours</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="n">dense_node_mapping</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>GraphSkipGram model for graph embedding.</p>

<p>The SkipGram model for graoh embedding receives a central word and tries
to predict its contexts. The model makes use of an NCE loss layer
during the training process to generate the negatives.</p>
</div>


                            <div id="GraphSkipGram.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphSkipGram.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphSkipGram</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    negative_samples: int = 10,
    walk_length: int = 128,
    batch_size: int = 256,
    iterations: int = 16,
    window_size: int = 3,
    return_weight: float = 1.0,
    explore_weight: float = 1.0,
    change_node_type_weight: float = 1.0,
    change_edge_type_weight: float = 1.0,
    max_neighbours: int = None,
    elapsed_epochs: int = 0,
    support_mirrored_strategy: bool = False,
    random_state: int = 42,
    dense_node_mapping: Dict[int, int] = None,
    use_gradient_centralization: bool = True
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">negative_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to be embedded.</span>
<span class="sd">        word2vec_model: Word2Vec,</span>
<span class="sd">            Word2Vec model to use.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = None,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        negative_samples: int = 10,</span>
<span class="sd">            The number of negative classes to randomly sample per batch.</span>
<span class="sd">            This single sample of negative classes is evaluated for each element in the batch.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        batch_size: int = 256,</span>
<span class="sd">            Number of nodes to include in a single batch.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The given graph does not have the nodes sorted by decreasing &quot;</span>
                <span class="s2">&quot;order, therefore the NCE loss sampling (which follows a zipfian &quot;</span>
                <span class="s2">&quot;distribution) would not approximate well the Softmax.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to sort the given graph in such a way that the node IDs &quot;</span>
                <span class="s2">&quot;are sorted by decreasing outbound node degrees, you can use &quot;</span>
                <span class="s2">&quot;the Graph method &quot;</span>
                <span class="s2">&quot;`graph.sort_by_decreasing_outbound_node_degree()`&quot;</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">word2vec_model</span><span class="o">=</span><span class="n">SkipGram</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">negative_samples</span><span class="o">=</span><span class="n">negative_samples</span><span class="p">,</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="n">walk_length</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="n">return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="n">explore_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="n">change_node_type_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="n">change_edge_type_weight</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="n">max_neighbours</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="n">dense_node_mapping</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
Graph to be embedded.</li>
<li><strong>word2vec_model</strong> (Word2Vec,):
Word2Vec model to use.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = None,):
The optimizer to be used during the training of the model.
By default, if None is provided, Nadam with learning rate
set at 0.01 is used.</li>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>negative_samples</strong> (int = 10,):
The number of negative classes to randomly sample per batch.
This single sample of negative classes is evaluated for each element in the batch.</li>
<li><strong>walk_length</strong> (int = 128,):
Maximal length of the walks.</li>
<li><strong>batch_size</strong> (int = 256,):
Number of nodes to include in a single batch.</li>
<li><strong>iterations</strong> (int = 16,):
Number of iterations of the single walks.</li>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>return_weight</strong> (float = 1.0,):
Weight on the probability of returning to the same node the walk just came from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>max_neighbours</strong> (int = None,):
Number of maximum neighbours to consider when using approximated walks.
By default, None, we execute exact random walks.
This is mainly useful for graphs containing nodes with extremely high degrees.</li>
<li><strong>elapsed_epochs</strong> (int = 0,):
Number of elapsed epochs to init state of generator.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to reproduce the training sequence.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None,):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method (available from the
graph object created using Graph)
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.node2vec.Node2Vec</dt>
                                <dd id="GraphSkipGram.fit" class="function">fit</dd>
                <dd id="GraphSkipGram.summary" class="function">summary</dd>
                <dd id="GraphSkipGram.embedding" class="variable">embedding</dd>
                <dd id="GraphSkipGram.trainable" class="variable">trainable</dd>
                <dd id="GraphSkipGram.get_embedding_dataframe" class="function">get_embedding_dataframe</dd>
                <dd id="GraphSkipGram.save_embedding" class="function">save_embedding</dd>
                <dd id="GraphSkipGram.name" class="variable">name</dd>
                <dd id="GraphSkipGram.save_weights" class="function">save_weights</dd>
                <dd id="GraphSkipGram.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GraphGloVe">
                                <div class="attr class">
        <a class="headerlink" href="#GraphGloVe">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphGloVe</span><wbr>(<span class="base"><a href="#GloVe">grape.embiggen.GloVe</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphGloVe</span><span class="p">(</span><span class="n">GloVe</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;GloVe model for graph and words embedding.</span>

<span class="sd">    The GloVe model for graoh embedding receives two words and is asked to</span>
<span class="sd">    predict its cooccurrence probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        vocabulary_size: int,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">        embedding_size: int,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        alpha: float = 0.75,</span>
<span class="sd">            Alpha to use for the function.</span>
<span class="sd">        directed: bool = False,</span>
<span class="sd">            Whether to treat the data as directed or not.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walk_length</span> <span class="o">=</span> <span class="n">walk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_weight</span> <span class="o">=</span> <span class="n">return_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_explore_weight</span> <span class="o">=</span> <span class="n">explore_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_node_type_weight</span> <span class="o">=</span> <span class="n">change_node_type_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_edge_type_weight</span> <span class="o">=</span> <span class="n">change_edge_type_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_neighbours</span> <span class="o">=</span> <span class="n">max_neighbours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dense_node_mapping</span> <span class="o">=</span> <span class="n">dense_node_mapping</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">(),</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return terms embedding using given index names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        epochs: int = 1000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        batch_size: int = 2**20,</span>
<span class="sd">            The batch size.</span>
<span class="sd">            Tipically batch sizes for the GloVe model can be immense.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.001,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 0.01,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">cooccurence_matrix</span><span class="p">(</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_walk_length</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iterations</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_explore_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_change_edge_type_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_change_node_type_weight</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dense_node_mapping</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_neighbours</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">destinations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">),</span> <span class="n">frequencies</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>GloVe model for graph and words embedding.</p>

<p>The GloVe model for graoh embedding receives two words and is asked to
predict its cooccurrence probability.</p>
</div>


                            <div id="GraphGloVe.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphGloVe.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphGloVe</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    alpha: float = 0.75,
    directed: bool = False,
    walk_length: int = 128,
    iterations: int = 16,
    window_size: int = 4,
    return_weight: float = 1.0,
    explore_weight: float = 1.0,
    change_node_type_weight: float = 1.0,
    change_edge_type_weight: float = 1.0,
    max_neighbours: int = None,
    support_mirrored_strategy: bool = False,
    random_state: int = 42,
    dense_node_mapping: Dict[int, int] = None,
    use_gradient_centralization: bool = True
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">return_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">explore_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_node_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">change_edge_type_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">dense_node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        vocabulary_size: int,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">        embedding_size: int,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">            By default, if None is provided, Nadam with learning rate</span>
<span class="sd">            set at 0.01 is used.</span>
<span class="sd">        alpha: float = 0.75,</span>
<span class="sd">            Alpha to use for the function.</span>
<span class="sd">        directed: bool = False,</span>
<span class="sd">            Whether to treat the data as directed or not.</span>
<span class="sd">        walk_length: int = 128,</span>
<span class="sd">            Maximal length of the walks.</span>
<span class="sd">        iterations: int = 16,</span>
<span class="sd">            Number of iterations of the single walks.</span>
<span class="sd">        window_size: int = 4,</span>
<span class="sd">            Window size for the local context.</span>
<span class="sd">            On the borders the window size is trimmed.</span>
<span class="sd">        return_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of returning to the same node the walk just came from</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Breadth-First Search.</span>
<span class="sd">            Having this very high  (&gt; 2) makes search very local.</span>
<span class="sd">            Equal to the inverse of p in the Node2Vec paper.</span>
<span class="sd">        explore_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node</span>
<span class="sd">            to the one we&#39;re coming from in the random walk</span>
<span class="sd">            Having this higher tends the walks to be</span>
<span class="sd">            more like a Depth-First Search.</span>
<span class="sd">            Having this very high makes search more outward.</span>
<span class="sd">            Having this very low makes search very local.</span>
<span class="sd">            Equal to the inverse of q in the Node2Vec paper.</span>
<span class="sd">        change_node_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor node of a</span>
<span class="sd">            different type than the previous node. This only applies to</span>
<span class="sd">            colored graphs, otherwise it has no impact.</span>
<span class="sd">        change_edge_type_weight: float = 1.0,</span>
<span class="sd">            Weight on the probability of visiting a neighbor edge of a</span>
<span class="sd">            different type than the previous edge. This only applies to</span>
<span class="sd">            multigraphs, otherwise it has no impact.</span>
<span class="sd">        max_neighbours: int = None,</span>
<span class="sd">            Number of maximum neighbours to consider when using approximated walks.</span>
<span class="sd">            By default, None, we execute exact random walks.</span>
<span class="sd">            This is mainly useful for graphs containing nodes with extremely high degrees.</span>
<span class="sd">        elapsed_epochs: int = 0,</span>
<span class="sd">            Number of elapsed epochs to init state of generator.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the training sequence.</span>
<span class="sd">        dense_node_mapping: Dict[int, int] = None,</span>
<span class="sd">            Mapping to use for converting sparse walk space into a dense space.</span>
<span class="sd">            This object can be created using the method (available from the</span>
<span class="sd">            graph object created using Graph)</span>
<span class="sd">            called `get_dense_node_mapping` that returns a mapping from</span>
<span class="sd">            the non trap nodes (those from where a walk could start) and</span>
<span class="sd">            maps these nodes into a dense range of values.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_walk_length</span> <span class="o">=</span> <span class="n">walk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span> <span class="o">=</span> <span class="n">validate_window_size</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_weight</span> <span class="o">=</span> <span class="n">return_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_explore_weight</span> <span class="o">=</span> <span class="n">explore_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_node_type_weight</span> <span class="o">=</span> <span class="n">change_node_type_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_edge_type_weight</span> <span class="o">=</span> <span class="n">change_edge_type_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_neighbours</span> <span class="o">=</span> <span class="n">max_neighbours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dense_node_mapping</span> <span class="o">=</span> <span class="n">dense_node_mapping</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">(),</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new GloVe-based Embedder object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.</li>
<li><strong>embedding_size</strong> (int,):
Dimension of the embedding.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.
By default, if None is provided, Nadam with learning rate
set at 0.01 is used.</li>
<li><strong>alpha</strong> (float = 0.75,):
Alpha to use for the function.</li>
<li><strong>directed</strong> (bool = False,):
Whether to treat the data as directed or not.</li>
<li><strong>walk_length</strong> (int = 128,):
Maximal length of the walks.</li>
<li><strong>iterations</strong> (int = 16,):
Number of iterations of the single walks.</li>
<li><strong>window_size</strong> (int = 4,):
Window size for the local context.
On the borders the window size is trimmed.</li>
<li><strong>return_weight</strong> (float = 1.0,):
Weight on the probability of returning to the same node the walk just came from
Having this higher tends the walks to be
more like a Breadth-First Search.
Having this very high  (&gt; 2) makes search very local.
Equal to the inverse of p in the Node2Vec paper.</li>
<li><strong>explore_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node
to the one we're coming from in the random walk
Having this higher tends the walks to be
more like a Depth-First Search.
Having this very high makes search more outward.
Having this very low makes search very local.
Equal to the inverse of q in the Node2Vec paper.</li>
<li><strong>change_node_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor node of a
different type than the previous node. This only applies to
colored graphs, otherwise it has no impact.</li>
<li><strong>change_edge_type_weight</strong> (float = 1.0,):
Weight on the probability of visiting a neighbor edge of a
different type than the previous edge. This only applies to
multigraphs, otherwise it has no impact.</li>
<li><strong>max_neighbours</strong> (int = None,):
Number of maximum neighbours to consider when using approximated walks.
By default, None, we execute exact random walks.
This is mainly useful for graphs containing nodes with extremely high degrees.</li>
<li><strong>elapsed_epochs</strong> (int = 0,):
Number of elapsed epochs to init state of generator.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to reproduce the training sequence.</li>
<li><strong>dense_node_mapping</strong> (Dict[int, int] = None,):
Mapping to use for converting sparse walk space into a dense space.
This object can be created using the method (available from the
graph object created using Graph)
called <code>get_dense_node_mapping</code> that returns a mapping from
the non trap nodes (those from where a walk could start) and
maps these nodes into a dense range of values.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div id="GraphGloVe.get_embedding_dataframe" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphGloVe.get_embedding_dataframe">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_embedding_dataframe</span><span class="signature">(self) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return terms embedding using given index names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return terms embedding using given index names.</p>
</div>


                            </div>
                            <div id="GraphGloVe.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphGloVe.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    epochs: int = 1000,
    batch_size: int = 1048576,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_min_delta: float = 0.0001,
    early_stopping_patience: int = 10,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_min_delta: float = 0.0001,
    reduce_lr_patience: int = 5,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 2,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        epochs: int = 1000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        batch_size: int = 2**20,</span>
<span class="sd">            The batch size.</span>
<span class="sd">            Tipically batch sizes for the GloVe model can be immense.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.001,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 0.01,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 10,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">cooccurence_matrix</span><span class="p">(</span>
            <span class="n">walk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_walk_length</span><span class="p">,</span>
            <span class="n">window_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iterations</span><span class="p">,</span>
            <span class="n">return_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_weight</span><span class="p">,</span>
            <span class="n">explore_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_explore_weight</span><span class="p">,</span>
            <span class="n">change_edge_type_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_change_edge_type_weight</span><span class="p">,</span>
            <span class="n">change_node_type_weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_change_node_type_weight</span><span class="p">,</span>
            <span class="n">dense_node_mapping</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dense_node_mapping</span><span class="p">,</span>
            <span class="n">max_neighbours</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_neighbours</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">destinations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">),</span> <span class="n">frequencies</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>epochs</strong> (int = 1000,):
Epochs to train the model for.</li>
<li><strong>batch_size</strong> (int = 2**20,):
The batch size.
Tipically batch sizes for the GloVe model can be immense.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_min_delta</strong> (float = 0.001,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int = 10,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_min_delta</strong> (float = 0.01,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int = 10,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 2,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If given verbose value is not within the available set (-1, 0, 1).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="GraphGloVe.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="GraphGloVe.trainable" class="variable">trainable</dd>
                <dd id="GraphGloVe.summary" class="function">summary</dd>
                <dd id="GraphGloVe.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="GraphGloVe.embedding" class="variable">embedding</dd>
                <dd id="GraphGloVe.save_embedding" class="function">save_embedding</dd>
                <dd id="GraphGloVe.name" class="variable">name</dd>
                <dd id="GraphGloVe.save_weights" class="function">save_weights</dd>
                <dd id="GraphGloVe.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Word2VecSequence">
                                <div class="attr class">
        <a class="headerlink" href="#Word2VecSequence">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Word2VecSequence</span><wbr>(<span class="base">grape.embiggen.sequences.abstract_word2vec_sequence.AbstractWord2VecSequence</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Word2VecSequence</span><span class="p">(</span><span class="n">AbstractWord2VecSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keras Sequence object for running CBOW and SkipGram on texts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return batch corresponding to given index.</span>

<span class="sd">        The return tuple of tuples is composed of an inner tuple, containing</span>
<span class="sd">        the words vector and the vector of vectors of the contexts.</span>
<span class="sd">        Depending on the order of the input_layers of the models that can</span>
<span class="sd">        accept these data format, one of the vectors is used as training</span>
<span class="sd">        input and the other one is used as the output for the NCE loss layer.</span>

<span class="sd">        The words vectors and contexts vectors contain numeric IDs, that</span>
<span class="sd">        represent the index of the words&#39; embedding column.</span>

<span class="sd">        The true output value is None, since no loss function is used after</span>
<span class="sd">        the NCE loss, that is implemented as a layer, and this vastly improves</span>
<span class="sd">        the speed of the training process since it does not require to allocate</span>
<span class="sd">        empty vectors of considerable size for the one-hot encoding process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------</span>
<span class="sd">        idx: int,</span>
<span class="sd">            Index corresponding to batch to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------</span>
<span class="sd">        Tuple of tuples with input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contexts</span><span class="p">,</span> <span class="n">words</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">word2vec</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sequences</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
            <span class="n">window_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">contexts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">words</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)),</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">contexts</span><span class="p">,</span> <span class="n">words</span><span class="p">),</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Keras Sequence object for running CBOW and SkipGram on texts.</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.sequences.abstract_word2vec_sequence.AbstractWord2VecSequence</dt>
                                <dd id="Word2VecSequence.__init__" class="function">AbstractWord2VecSequence</dd>
                <dd id="Word2VecSequence.on_epoch_end" class="function">on_epoch_end</dd>

            </div>
            <div><dt>keras_mixed_sequence.utils.sequence.Sequence</dt>
                                <dd id="Word2VecSequence.batch_size" class="variable">batch_size</dd>
                <dd id="Word2VecSequence.reset" class="function">reset</dd>
                <dd id="Word2VecSequence.elapsed_epochs" class="variable">elapsed_epochs</dd>
                <dd id="Word2VecSequence.sample_number" class="variable">sample_number</dd>
                <dd id="Word2VecSequence.steps_per_epoch" class="variable">steps_per_epoch</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="NodeTransformer">
                                <div class="attr class">
        <a class="headerlink" href="#NodeTransformer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">NodeTransformer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">NodeTransformer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;NodeTransformer class to convert nodes to edge embeddings.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numeric_node_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new NodeTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------</span>
<span class="sd">        numeric_node_ids: bool = False,</span>
<span class="sd">            Wether to return the numeric node IDs instead of the node embedding.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numeric_node_ids</span> <span class="o">=</span> <span class="n">numeric_node_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span> <span class="o">=</span> <span class="n">aligned_node_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numeric_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the transformer returns numeric node IDs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numeric_node_ids</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given embedding is not a pandas DataFrame.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span> <span class="o">=</span> <span class="n">embedding</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return embeddings from given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        nodes: Union[List[str], List[int]],</span>
<span class="sd">            List of nodes whose embedding is to be returned.</span>
<span class="sd">            By default this should be a list of strings, if the</span>
<span class="sd">            aligned_node_mapping is setted, then this methods also accepts</span>
<span class="sd">            a list of ints.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Transformer was not fitted yet.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">nodes</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ids</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>NodeTransformer class to convert nodes to edge embeddings.</p>
</div>


                            <div id="NodeTransformer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NodeTransformer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">NodeTransformer</span><span class="signature">(
    numeric_node_ids: bool = False,
    aligned_node_mapping: bool = False,
    support_mirrored_strategy: bool = False
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">numeric_node_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new NodeTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------</span>
<span class="sd">        numeric_node_ids: bool = False,</span>
<span class="sd">            Wether to return the numeric node IDs instead of the node embedding.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numeric_node_ids</span> <span class="o">=</span> <span class="n">numeric_node_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span> <span class="o">=</span> <span class="n">aligned_node_mapping</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new NodeTransformer object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>numeric_node_ids</strong> (bool = False,):
Wether to return the numeric node IDs instead of the node embedding.</li>
<li><strong>aligned_node_mapping</strong> (bool = False,):
This parameter specifies whether the mapping of the embeddings nodes
matches the internal node mapping of the given graph.
If these two mappings do not match, the generated edge embedding
will be meaningless.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
</ul>
</div>


                            </div>
                            <div id="NodeTransformer.numeric_node_ids" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#NodeTransformer.numeric_node_ids">#&nbsp;&nbsp</a>

        <span class="name">numeric_node_ids</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return whether the transformer returns numeric node IDs.</p>
</div>


                            </div>
                            <div id="NodeTransformer.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NodeTransformer.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(self, embedding: pandas.core.frame.DataFrame)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given embedding is not a pandas DataFrame.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span> <span class="o">=</span> <span class="n">embedding</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit the model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>embedding</strong> (pd.DataFrame,):
Embedding to use to fit the transformer.
This is a pandas DataFrame and NOT a numpy array because we need
to be able to remap correctly the vector embeddings in case of
graphs that do not respect the same internal node mapping but have
the same node set. It is possible to remap such graphs using
Ensmallen's remap method but it may be less intuitive to users.</li>
</ul>
</div>


                            </div>
                            <div id="NodeTransformer.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NodeTransformer.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(self, nodes: Union[List[str], List[int]]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return embeddings from given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        nodes: Union[List[str], List[int]],</span>
<span class="sd">            List of nodes whose embedding is to be returned.</span>
<span class="sd">            By default this should be a list of strings, if the</span>
<span class="sd">            aligned_node_mapping is setted, then this methods also accepts</span>
<span class="sd">            a list of ints.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Transformer was not fitted yet.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">nodes</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_numpy</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_node_ids</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ids</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_embedding</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return embeddings from given node.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>nodes</strong> (Union[List[str], List[int]],):
List of nodes whose embedding is to be returned.
By default this should be a list of strings, if the
aligned_node_mapping is setted, then this methods also accepts
a list of ints.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If embedding is not fitted.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Numpy array of embeddings.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="EdgeTransformer">
                                <div class="attr class">
        <a class="headerlink" href="#EdgeTransformer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">EdgeTransformer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">EdgeTransformer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;EdgeTransformer class to convert edges to edge embeddings.&quot;&quot;&quot;</span>

    <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Hadamard&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;Sum&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;Average&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;L1&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;AbsoluteL1&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;L2&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">x1</span><span class="p">),</span>
        <span class="s2">&quot;Concatenate&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
        <span class="kc">None</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new EdgeTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;Hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            If None is used, we return instead the numeric tuples.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span>
                <span class="s2">&quot;Given method &#39;</span><span class="si">{}</span><span class="s2">&#39; is not supported. &quot;</span>
                <span class="s2">&quot;Supported methods are </span><span class="si">{}</span><span class="s2">, or alternatively a lambda.&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">NodeTransformer</span><span class="p">(</span>
            <span class="n">numeric_node_ids</span><span class="o">=</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method_name</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_method_name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numeric_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the transformer returns numeric node IDs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">numeric_node_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the used edge embedding method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method_name</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given method is None there is no need to call the fit method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There is no need to call the fit when edge method is None.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sources</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return embedding for given edges using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        sources: List[str],</span>
<span class="sd">            List of source nodes whose embedding is to be returned.</span>
<span class="sd">        destinations: List[str],</span>
<span class="sd">            List of destination nodes whose embedding is to be returned.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">destinations</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>EdgeTransformer class to convert edges to edge embeddings.</p>
</div>


                            <div id="EdgeTransformer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EdgeTransformer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">EdgeTransformer</span><span class="signature">(
    method: str = &#39;Hadamard&#39;,
    aligned_node_mapping: bool = False,
    support_mirrored_strategy: bool = False
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new EdgeTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;Hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            If None is used, we return instead the numeric tuples.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span>
                <span class="s2">&quot;Given method &#39;</span><span class="si">{}</span><span class="s2">&#39; is not supported. &quot;</span>
                <span class="s2">&quot;Supported methods are </span><span class="si">{}</span><span class="s2">, or alternatively a lambda.&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">NodeTransformer</span><span class="p">(</span>
            <span class="n">numeric_node_ids</span><span class="o">=</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method_name</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">EdgeTransformer</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_method_name</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new EdgeTransformer object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>method</strong> (str = "Hadamard",):
Method to use for the embedding.
If None is used, we return instead the numeric tuples.
Can either be 'Hadamard', 'Sum', 'Average', 'L1', 'AbsoluteL1', 'L2' or 'Concatenate'.</li>
<li><strong>aligned_node_mapping</strong> (bool = False,):
This parameter specifies whether the mapping of the embeddings nodes
matches the internal node mapping of the given graph.
If these two mappings do not match, the generated edge embedding
will be meaningless.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
</ul>
</div>


                            </div>
                            <div id="EdgeTransformer.methods" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#EdgeTransformer.methods">#&nbsp;&nbsp</a>

        <span class="name">methods</span><span class="default_value"> = {&#39;Hadamard&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd6daf0&gt;, &#39;Sum&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd6db80&gt;, &#39;Average&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd6de50&gt;, &#39;L1&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd6dee0&gt;, &#39;AbsoluteL1&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd6df70&gt;, &#39;L2&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd79040&gt;, &#39;Concatenate&#39;: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd790d0&gt;, None: &lt;function EdgeTransformer.&lt;lambda&gt; at 0x7f108bd79160&gt;}</span>
    </div>

    

                            </div>
                            <div id="EdgeTransformer.numeric_node_ids" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#EdgeTransformer.numeric_node_ids">#&nbsp;&nbsp</a>

        <span class="name">numeric_node_ids</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return whether the transformer returns numeric node IDs.</p>
</div>


                            </div>
                            <div id="EdgeTransformer.method" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#EdgeTransformer.method">#&nbsp;&nbsp</a>

        <span class="name">method</span><span class="annotation">: str</span>
    </div>

            <div class="docstring"><p>Return the used edge embedding method.</p>
</div>


                            </div>
                            <div id="EdgeTransformer.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EdgeTransformer.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(self, embedding: pandas.core.frame.DataFrame)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given method is None there is no need to call the fit method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There is no need to call the fit when edge method is None.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit the model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>embedding</strong> (pd.DataFrame,):
Embedding to use to fit the transformer.
This is a pandas DataFrame and NOT a numpy array because we need
to be able to remap correctly the vector embeddings in case of
graphs that do not respect the same internal node mapping but have
the same node set. It is possible to remap such graphs using
Ensmallen's remap method but it may be less intuitive to users.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the given method is None there is no need to call the fit method.</li>
</ul>
</div>


                            </div>
                            <div id="EdgeTransformer.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#EdgeTransformer.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(self, sources: List[str], destinations: List[str]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sources</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return embedding for given edges using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        sources: List[str],</span>
<span class="sd">            List of source nodes whose embedding is to be returned.</span>
<span class="sd">        destinations: List[str],</span>
<span class="sd">            List of destination nodes whose embedding is to be returned.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">destinations</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return embedding for given edges using provided method.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>sources</strong> (List[str],):
List of source nodes whose embedding is to be returned.</li>
<li><strong>destinations</strong> (List[str],):
List of destination nodes whose embedding is to be returned.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If embedding is not fitted.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Numpy array of embeddings.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="GraphTransformer">
                                <div class="attr class">
        <a class="headerlink" href="#GraphTransformer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphTransformer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphTransformer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;GraphTransformer class to convert graphs to edge embeddings.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GraphTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">EdgeTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span> <span class="o">=</span> <span class="n">aligned_node_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numeric_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether the transformer returns numeric node IDs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">numeric_node_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the used edge embedding method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">method</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge embedding for given graph using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        graph: Union[Graph, np.ndarray, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to embed.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge__node_ids</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge_node_names</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>GraphTransformer class to convert graphs to edge embeddings.</p>
</div>


                            <div id="GraphTransformer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphTransformer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphTransformer</span><span class="signature">(
    method: str = &#39;Hadamard&#39;,
    aligned_node_mapping: bool = False,
    support_mirrored_strategy: bool = False
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GraphTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">EdgeTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span> <span class="o">=</span> <span class="n">aligned_node_mapping</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new GraphTransformer object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>method</strong> (str = "hadamard",):
Method to use for the embedding.
Can either be 'Hadamard', 'Sum', 'Average', 'L1', 'AbsoluteL1', 'L2' or 'Concatenate'.</li>
<li><strong>aligned_node_mapping</strong> (bool = False,):
This parameter specifies whether the mapping of the embeddings nodes
matches the internal node mapping of the given graph.
If these two mappings do not match, the generated edge embedding
will be meaningless.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
</ul>
</div>


                            </div>
                            <div id="GraphTransformer.numeric_node_ids" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GraphTransformer.numeric_node_ids">#&nbsp;&nbsp</a>

        <span class="name">numeric_node_ids</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return whether the transformer returns numeric node IDs.</p>
</div>


                            </div>
                            <div id="GraphTransformer.method" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GraphTransformer.method">#&nbsp;&nbsp</a>

        <span class="name">method</span><span class="annotation">: str</span>
    </div>

            <div class="docstring"><p>Return the used edge embedding method.</p>
</div>


                            </div>
                            <div id="GraphTransformer.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphTransformer.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(self, embedding: pandas.core.frame.DataFrame)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit the model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>embedding</strong> (pd.DataFrame,):
Embedding to use to fit the transformer.
This is a pandas DataFrame and NOT a numpy array because we need
to be able to remap correctly the vector embeddings in case of
graphs that do not respect the same internal node mapping but have
the same node set. It is possible to remap such graphs using
Ensmallen's remap method but it may be less intuitive to users.</li>
</ul>
</div>


                            </div>
                            <div id="GraphTransformer.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphTransformer.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(
    self,
    graph: Union[Graph, numpy.ndarray, List[List[str]], List[List[int]]]
) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return edge embedding for given graph using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        graph: Union[Graph, np.ndarray, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to embed.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array of embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">Graph</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_node_mapping</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge__node_ids</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge_node_names</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge embedding for given graph using provided method.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Union[Graph, np.ndarray, List[List[str]], List[List[int]]],):
The graph whose edges are to embed.
It can either be an Graph or a list of lists of edges.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If embedding is not fitted.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Numpy array of embeddings.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="CorpusTransformer">
                                <div class="attr class">
        <a class="headerlink" href="#CorpusTransformer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">CorpusTransformer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CorpusTransformer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simple class to tekenize textual corpuses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">synonyms</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">language</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;english&quot;</span><span class="p">,</span>
        <span class="n">tokenizer_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nltk&quot;</span><span class="p">,</span>
        <span class="n">apply_stemming</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_stop_words</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_punctuation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_digits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">extra_stop_words</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_word_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">min_sequence_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">max_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">to_lower_case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_multiprocessing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new CorpusTransformer object.</span>

<span class="sd">        This is a GENERIC text tokenizer and is only useful for basic examples</span>
<span class="sd">        as in any advanced settings there will be need for a custom tokenizer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        synonyms: Dict = None,</span>
<span class="sd">            The synonyms to use.</span>
<span class="sd">        language: str = &quot;english&quot;,</span>
<span class="sd">            The language for the stopwords.</span>
<span class="sd">        tokenizer_method: str = &quot;nltk&quot;,</span>
<span class="sd">            The tokenizer method to be used.</span>
<span class="sd">            Can either be `nltk`, that is, using the nltk default method,</span>
<span class="sd">            or alternatively can be `space`, that is splitting only on spaces.</span>
<span class="sd">        apply_stemming: bool = True,</span>
<span class="sd">            Wethever to apply or not a stemming procedure, which</span>
<span class="sd">            by default is enabled.</span>
<span class="sd">            The algorithm used is a Porter Stemmer.</span>
<span class="sd">        remove_stop_words: bool = True,</span>
<span class="sd">            Whether to remove stopwords,</span>
<span class="sd">            as defined from NLTK for the given language.</span>
<span class="sd">        remove_punctuation: bool = True,</span>
<span class="sd">            Whether to remove punctuation, as defined from the string package.</span>
<span class="sd">        remove_digits: bool = False,</span>
<span class="sd">            Whether to remove words composed of only digits.</span>
<span class="sd">        extra_stop_words: Set[str] = None,</span>
<span class="sd">            The additional stop words to be removed.</span>
<span class="sd">        min_word_length: int = 2,</span>
<span class="sd">            Minimum length of the corpus words.</span>
<span class="sd">        min_sequence_length: int = 0,</span>
<span class="sd">            Minimum length of the tokenized sequences.</span>
<span class="sd">            If you are using word2vec, the sequences MUST be longer than</span>
<span class="sd">            two times the window size plus one.</span>
<span class="sd">        min_count: int = 0,</span>
<span class="sd">            Whether to drop terms that appear less than the given amount.</span>
<span class="sd">        max_count: int = math.inf,</span>
<span class="sd">            Whether to drop terms that appear more than the given amount.</span>
<span class="sd">        to_lower_case: bool = True,</span>
<span class="sd">            Whether to convert terms to lowercase.</span>
<span class="sd">        processes: int = None,</span>
<span class="sd">            Number of parallel processes to use.</span>
<span class="sd">            If given processes is None, all the available processes is used.</span>
<span class="sd">        verbose: bool = True,</span>
<span class="sd">            Whether to show loading bars and log process.</span>
<span class="sd">        use_multiprocessing: bool = True,</span>
<span class="sd">            Whether to use or not multiprocessing.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given tokenizer method is not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">nltk</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The package nltk is not installed!</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;If you need to use the CorpusTransformer object, &quot;</span>
                <span class="s2">&quot;please do install the nltk package.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;This package has to be installed separetely because it &quot;</span>
                <span class="s2">&quot;comes with added complexity that we prefer to spare the user &quot;</span>
                <span class="s2">&quot;when their main interest lies within graph embedding.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synonyms</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">synonyms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">synonyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">extra_stop_words</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">extra_stop_words</span>
        <span class="k">if</span> <span class="n">remove_stop_words</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="n">language</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">remove_punctuation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_digits</span> <span class="o">=</span> <span class="n">remove_digits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_word_length</span> <span class="o">=</span> <span class="n">min_word_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="o">=</span> <span class="n">min_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span> <span class="o">=</span> <span class="n">max_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_sequence_length</span> <span class="o">=</span> <span class="n">min_sequence_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span> <span class="o">=</span> <span class="n">to_lower_case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_multiprocessing</span> <span class="o">=</span> <span class="n">use_multiprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span> <span class="o">=</span> <span class="n">PorterStemmer</span><span class="p">()</span> <span class="k">if</span> <span class="n">apply_stemming</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">tokenizer_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;nltk&quot;</span><span class="p">,</span> <span class="s2">&quot;space&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;Given tokenizer method `</span><span class="si">{}</span><span class="s2">` is not supported. &quot;</span>
                    <span class="s2">&quot;The supported methods are `nltk` and `space`.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tokenizer_method</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer_method</span> <span class="o">=</span> <span class="n">tokenizer_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_synonym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the synonym of the given word, if available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        word: str,</span>
<span class="sd">            The word whose synonym is to be found.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        The given word synonym.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synonyms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return preliminary tokenization of the line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        line: str,</span>
<span class="sd">            The line to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer_method</span> <span class="o">==</span> <span class="s2">&quot;nltk&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tokenize_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tokenized line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        line: str,</span>
<span class="sd">            The line to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_synonym</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_synonym</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span> <span class="k">else</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_word_length</span> <span class="ow">and</span>
            <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_digits</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">word</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">())</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">tokenize_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return tokenized lines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        lines: List[str],</span>
<span class="sd">            List of lines to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">return_counts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit model using stemming from given text.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The text to use to fit the transformer.</span>
<span class="sd">        return_counts: bool = False,</span>
<span class="sd">            Wethever to return the counts of the terms or not.</span>

<span class="sd">        Return</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        Either the tokens or tuple containing the tokens and the counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">))</span>
        <span class="n">chunks_number</span> <span class="o">=</span> <span class="n">processes</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span> <span class="o">//</span> <span class="n">chunks_number</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">texts</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_multiprocessing</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">all_tokens</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">line</span>
                    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_lines</span><span class="p">,</span>
                            <span class="n">tasks</span>
                        <span class="p">),</span>
                        <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tokenizing&quot;</span><span class="p">,</span>
                        <span class="n">total</span><span class="o">=</span><span class="n">chunks_number</span><span class="p">,</span>
                        <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">chunk</span>
                <span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_tokens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">line</span>
                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">tasks</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tokenizing&quot;</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="n">chunks_number</span><span class="p">,</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_lines</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">return_counts</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">((</span>
                <span class="n">term</span>
                <span class="k">for</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">all_tokens</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Computing counts of terms&quot;</span><span class="p">,</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span>
            <span class="p">))</span>
            <span class="k">return</span> <span class="n">all_tokens</span><span class="p">,</span> <span class="n">counter</span>
        <span class="k">return</span> <span class="n">all_tokens</span>

    <span class="k">def</span> <span class="nf">parse_tokens_for_low_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Yields tokens parsed according to updated stopwords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        tokens_list: List[List[str]],</span>
<span class="sd">            List of the string tokens.</span>

<span class="sd">        Yields</span>
<span class="sd">        --------------------</span>
<span class="sd">        The filtered out tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="n">tokens_list</span><span class="p">,</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens_list</span><span class="p">),</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Filtering low frequency terms&quot;</span><span class="p">,</span>
            <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
        <span class="p">):</span>
            <span class="n">new_tokens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">token</span>
                <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span>
                <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">new_tokens</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Fit the transformer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The texts to use for the fitting.</span>

<span class="sd">        Raises</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are NaN values within given texts.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are non string values within given texts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are NaN values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are not string values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="n">tokens_list</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">texts</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="p">{</span>
                <span class="n">word</span>
                <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span>
            <span class="p">}</span>
            <span class="n">tokens_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_tokens_for_low_frequency</span><span class="p">(</span><span class="n">tokens_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">(</span>
            <span class="n">lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">fit_on_texts</span><span class="p">((</span>
            <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="n">tokens_list</span><span class="p">,</span>
                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Fitting tokenizer&quot;</span><span class="p">,</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
            <span class="p">)</span>
        <span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vocabulary_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return number of different terms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">word_counts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequences</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Reverse the sequence to texts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        sequences: np.ndarray,</span>
<span class="sd">            The sequences to counter transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------</span>
<span class="sd">        The texts created from the given sequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">sequences_to_texts</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_word_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the given words IDs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        word: int</span>
<span class="sd">            The word whose ID is to be retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------</span>
<span class="sd">        The word numeric ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">word_index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Transform given text.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The texts to encode as digits.</span>

<span class="sd">        Raises</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are NaN values within given texts.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are non string values within given texts.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array with numpy arrays of tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are NaN values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are not string values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">texts_to_sequences</span><span class="p">((</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Transform texts&quot;</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sequence_length</span>
            <span class="p">))</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Simple class to tekenize textual corpuses.</p>
</div>


                            <div id="CorpusTransformer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">CorpusTransformer</span><span class="signature">(
    synonyms: Dict = None,
    language: str = &#39;english&#39;,
    tokenizer_method: str = &#39;nltk&#39;,
    apply_stemming: bool = True,
    remove_stop_words: bool = True,
    remove_punctuation: bool = True,
    remove_digits: bool = False,
    extra_stop_words: Set[str] = None,
    min_word_length: int = 2,
    min_sequence_length: int = 0,
    min_count: int = 0,
    max_count: int = inf,
    to_lower_case: bool = True,
    verbose: bool = True,
    processes: int = None,
    use_multiprocessing: bool = True
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">synonyms</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">language</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;english&quot;</span><span class="p">,</span>
        <span class="n">tokenizer_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nltk&quot;</span><span class="p">,</span>
        <span class="n">apply_stemming</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_stop_words</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_punctuation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_digits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">extra_stop_words</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_word_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">min_sequence_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">max_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">to_lower_case</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_multiprocessing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new CorpusTransformer object.</span>

<span class="sd">        This is a GENERIC text tokenizer and is only useful for basic examples</span>
<span class="sd">        as in any advanced settings there will be need for a custom tokenizer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        synonyms: Dict = None,</span>
<span class="sd">            The synonyms to use.</span>
<span class="sd">        language: str = &quot;english&quot;,</span>
<span class="sd">            The language for the stopwords.</span>
<span class="sd">        tokenizer_method: str = &quot;nltk&quot;,</span>
<span class="sd">            The tokenizer method to be used.</span>
<span class="sd">            Can either be `nltk`, that is, using the nltk default method,</span>
<span class="sd">            or alternatively can be `space`, that is splitting only on spaces.</span>
<span class="sd">        apply_stemming: bool = True,</span>
<span class="sd">            Wethever to apply or not a stemming procedure, which</span>
<span class="sd">            by default is enabled.</span>
<span class="sd">            The algorithm used is a Porter Stemmer.</span>
<span class="sd">        remove_stop_words: bool = True,</span>
<span class="sd">            Whether to remove stopwords,</span>
<span class="sd">            as defined from NLTK for the given language.</span>
<span class="sd">        remove_punctuation: bool = True,</span>
<span class="sd">            Whether to remove punctuation, as defined from the string package.</span>
<span class="sd">        remove_digits: bool = False,</span>
<span class="sd">            Whether to remove words composed of only digits.</span>
<span class="sd">        extra_stop_words: Set[str] = None,</span>
<span class="sd">            The additional stop words to be removed.</span>
<span class="sd">        min_word_length: int = 2,</span>
<span class="sd">            Minimum length of the corpus words.</span>
<span class="sd">        min_sequence_length: int = 0,</span>
<span class="sd">            Minimum length of the tokenized sequences.</span>
<span class="sd">            If you are using word2vec, the sequences MUST be longer than</span>
<span class="sd">            two times the window size plus one.</span>
<span class="sd">        min_count: int = 0,</span>
<span class="sd">            Whether to drop terms that appear less than the given amount.</span>
<span class="sd">        max_count: int = math.inf,</span>
<span class="sd">            Whether to drop terms that appear more than the given amount.</span>
<span class="sd">        to_lower_case: bool = True,</span>
<span class="sd">            Whether to convert terms to lowercase.</span>
<span class="sd">        processes: int = None,</span>
<span class="sd">            Number of parallel processes to use.</span>
<span class="sd">            If given processes is None, all the available processes is used.</span>
<span class="sd">        verbose: bool = True,</span>
<span class="sd">            Whether to show loading bars and log process.</span>
<span class="sd">        use_multiprocessing: bool = True,</span>
<span class="sd">            Whether to use or not multiprocessing.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given tokenizer method is not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">nltk</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The package nltk is not installed!</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;If you need to use the CorpusTransformer object, &quot;</span>
                <span class="s2">&quot;please do install the nltk package.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;This package has to be installed separetely because it &quot;</span>
                <span class="s2">&quot;comes with added complexity that we prefer to spare the user &quot;</span>
                <span class="s2">&quot;when their main interest lies within graph embedding.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synonyms</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">synonyms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">synonyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">extra_stop_words</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">extra_stop_words</span>
        <span class="k">if</span> <span class="n">remove_stop_words</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="n">language</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">remove_punctuation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_digits</span> <span class="o">=</span> <span class="n">remove_digits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_word_length</span> <span class="o">=</span> <span class="n">min_word_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="o">=</span> <span class="n">min_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span> <span class="o">=</span> <span class="n">max_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_sequence_length</span> <span class="o">=</span> <span class="n">min_sequence_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span> <span class="o">=</span> <span class="n">to_lower_case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_multiprocessing</span> <span class="o">=</span> <span class="n">use_multiprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span> <span class="o">=</span> <span class="n">PorterStemmer</span><span class="p">()</span> <span class="k">if</span> <span class="n">apply_stemming</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">tokenizer_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;nltk&quot;</span><span class="p">,</span> <span class="s2">&quot;space&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;Given tokenizer method `</span><span class="si">{}</span><span class="s2">` is not supported. &quot;</span>
                    <span class="s2">&quot;The supported methods are `nltk` and `space`.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tokenizer_method</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer_method</span> <span class="o">=</span> <span class="n">tokenizer_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new CorpusTransformer object.</p>

<p>This is a GENERIC text tokenizer and is only useful for basic examples
as in any advanced settings there will be need for a custom tokenizer.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>synonyms</strong> (Dict = None,):
The synonyms to use.</li>
<li><strong>language</strong> (str = "english",):
The language for the stopwords.</li>
<li><strong>tokenizer_method</strong> (str = "nltk",):
The tokenizer method to be used.
Can either be <code>nltk</code>, that is, using the nltk default method,
or alternatively can be <code>space</code>, that is splitting only on spaces.</li>
<li><strong>apply_stemming</strong> (bool = True,):
Wethever to apply or not a stemming procedure, which
by default is enabled.
The algorithm used is a Porter Stemmer.</li>
<li><strong>remove_stop_words</strong> (bool = True,):
Whether to remove stopwords,
as defined from NLTK for the given language.</li>
<li><strong>remove_punctuation</strong> (bool = True,):
Whether to remove punctuation, as defined from the string package.</li>
<li><strong>remove_digits</strong> (bool = False,):
Whether to remove words composed of only digits.</li>
<li><strong>extra_stop_words</strong> (Set[str] = None,):
The additional stop words to be removed.</li>
<li><strong>min_word_length</strong> (int = 2,):
Minimum length of the corpus words.</li>
<li><strong>min_sequence_length</strong> (int = 0,):
Minimum length of the tokenized sequences.
If you are using word2vec, the sequences MUST be longer than
two times the window size plus one.</li>
<li><strong>min_count</strong> (int = 0,):
Whether to drop terms that appear less than the given amount.</li>
<li><strong>max_count</strong> (int = math.inf,):
Whether to drop terms that appear more than the given amount.</li>
<li><strong>to_lower_case</strong> (bool = True,):
Whether to convert terms to lowercase.</li>
<li><strong>processes</strong> (int = None,):
Number of parallel processes to use.
If given processes is None, all the available processes is used.</li>
<li><strong>verbose</strong> (bool = True,):
Whether to show loading bars and log process.</li>
<li><strong>use_multiprocessing</strong> (bool = True,):
Whether to use or not multiprocessing.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the given tokenizer method is not supported.</li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.get_synonym" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.get_synonym">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_synonym</span><span class="signature">(self, word: str) -&gt; str</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_synonym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the synonym of the given word, if available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        word: str,</span>
<span class="sd">            The word whose synonym is to be found.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        The given word synonym.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synonyms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return the synonym of the given word, if available.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>word</strong> (str,):
The word whose synonym is to be found.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The given word synonym.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.split_line" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.split_line">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">split_line</span><span class="signature">(self, line: str) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">split_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return preliminary tokenization of the line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        line: str,</span>
<span class="sd">            The line to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer_method</span> <span class="o">==</span> <span class="s2">&quot;nltk&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return preliminary tokenization of the line.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>line</strong> (str,):
The line to be tokenized.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The list of string tokens.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.tokenize_line" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.tokenize_line">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">tokenize_line</span><span class="signature">(self, line: str) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">tokenize_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tokenized line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        line: str,</span>
<span class="sd">            The line to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_synonym</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stemmer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_synonym</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span> <span class="k">else</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_word_length</span> <span class="ow">and</span>
            <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_digits</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">word</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">())</span>
        <span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tokenized line.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>line</strong> (str,):
The line to be tokenized.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The list of string tokens.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.tokenize_lines" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.tokenize_lines">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">tokenize_lines</span><span class="signature">(self, lines: List[str]) -&gt; List[List[str]]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">tokenize_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return tokenized lines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------</span>
<span class="sd">        lines: List[str],</span>
<span class="sd">            List of lines to be tokenized.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The list of string tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span>
        <span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return tokenized lines.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lines</strong> (List[str],):
List of lines to be tokenized.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The list of string tokens.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.tokenize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.tokenize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">tokenize</span><span class="signature">(self, texts: List[str], return_counts: bool = False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">return_counts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit model using stemming from given text.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The text to use to fit the transformer.</span>
<span class="sd">        return_counts: bool = False,</span>
<span class="sd">            Wethever to return the counts of the terms or not.</span>

<span class="sd">        Return</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        Either the tokens or tuple containing the tokens and the counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">))</span>
        <span class="n">chunks_number</span> <span class="o">=</span> <span class="n">processes</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span> <span class="o">//</span> <span class="n">chunks_number</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">texts</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_multiprocessing</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">all_tokens</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">line</span>
                    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_lines</span><span class="p">,</span>
                            <span class="n">tasks</span>
                        <span class="p">),</span>
                        <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tokenizing&quot;</span><span class="p">,</span>
                        <span class="n">total</span><span class="o">=</span><span class="n">chunks_number</span><span class="p">,</span>
                        <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">chunk</span>
                <span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_tokens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">line</span>
                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">tasks</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Tokenizing&quot;</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="n">chunks_number</span><span class="p">,</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_lines</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">return_counts</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">((</span>
                <span class="n">term</span>
                <span class="k">for</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">all_tokens</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Computing counts of terms&quot;</span><span class="p">,</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span>
            <span class="p">))</span>
            <span class="k">return</span> <span class="n">all_tokens</span><span class="p">,</span> <span class="n">counter</span>
        <span class="k">return</span> <span class="n">all_tokens</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit model using stemming from given text.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>texts</strong> (List[str],):
The text to use to fit the transformer.</li>
<li><strong>return_counts</strong> (bool = False,):
Wethever to return the counts of the terms or not.</li>
</ul>

<h6 id="return">Return</h6>

<p>Either the tokens or tuple containing the tokens and the counts.</p>
</div>


                            </div>
                            <div id="CorpusTransformer.parse_tokens_for_low_frequency" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.parse_tokens_for_low_frequency">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">parse_tokens_for_low_frequency</span><span class="signature">(self, tokens_list: List[List[str]]) -&gt; Generator</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_tokens_for_low_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Yields tokens parsed according to updated stopwords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        tokens_list: List[List[str]],</span>
<span class="sd">            List of the string tokens.</span>

<span class="sd">        Yields</span>
<span class="sd">        --------------------</span>
<span class="sd">        The filtered out tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="n">tokens_list</span><span class="p">,</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens_list</span><span class="p">),</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Filtering low frequency terms&quot;</span><span class="p">,</span>
            <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
        <span class="p">):</span>
            <span class="n">new_tokens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">token</span>
                <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span>
                <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">new_tokens</span>
</pre></div>

        </details>

            <div class="docstring"><p>Yields tokens parsed according to updated stopwords.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>tokens_list</strong> (List[List[str]],):
List of the string tokens.</li>
</ul>

<h6 id="yields">Yields</h6>

<ul>
<li><strong>The filtered out tokens.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(self, texts: List[str])</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Fit the transformer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The texts to use for the fitting.</span>

<span class="sd">        Raises</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are NaN values within given texts.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are non string values within given texts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are NaN values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are not string values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="n">tokens_list</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">texts</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stopwords</span> <span class="o">|=</span> <span class="p">{</span>
                <span class="n">word</span>
                <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_count</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_count</span>
            <span class="p">}</span>
            <span class="n">tokens_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_tokens_for_low_frequency</span><span class="p">(</span><span class="n">tokens_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">(</span>
            <span class="n">lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_lower_case</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">fit_on_texts</span><span class="p">((</span>
            <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="n">tokens_list</span><span class="p">,</span>
                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Fitting tokenizer&quot;</span><span class="p">,</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
            <span class="p">)</span>
        <span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit the transformer.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>texts</strong> (List[str],):
The texts to use for the fitting.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If there are NaN values within given texts.</li>
<li><strong>ValueError,</strong>: If there are non string values within given texts.</li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.vocabulary_size" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#CorpusTransformer.vocabulary_size">#&nbsp;&nbsp</a>

        <span class="name">vocabulary_size</span><span class="annotation">: int</span>
    </div>

            <div class="docstring"><p>Return number of different terms.</p>
</div>


                            </div>
                            <div id="CorpusTransformer.reverse_transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.reverse_transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reverse_transform</span><span class="signature">(self, sequences: numpy.ndarray) -&gt; List[str]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequences</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Reverse the sequence to texts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        sequences: np.ndarray,</span>
<span class="sd">            The sequences to counter transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------</span>
<span class="sd">        The texts created from the given sequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">sequences_to_texts</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reverse the sequence to texts.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>sequences</strong> (np.ndarray,):
The sequences to counter transform.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The texts created from the given sequences.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.get_word_id" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.get_word_id">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_word_id</span><span class="signature">(self, word: str) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_word_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the given words IDs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        word: int</span>
<span class="sd">            The word whose ID is to be retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------</span>
<span class="sd">        The word numeric ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">word_index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the given words IDs.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>word</strong> (int):
The word whose ID is to be retrieved.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The word numeric ID.</strong></li>
</ul>
</div>


                            </div>
                            <div id="CorpusTransformer.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CorpusTransformer.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(self, texts: List[str]) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Transform given text.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        texts: List[str],</span>
<span class="sd">            The texts to encode as digits.</span>

<span class="sd">        Raises</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are NaN values within given texts.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If there are non string values within given texts.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Numpy array with numpy arrays of tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are NaN values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are not string values within the given texts.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">texts_to_sequences</span><span class="p">((</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Transform texts&quot;</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span>
                    <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_sequence_length</span>
            <span class="p">))</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Transform given text.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>texts</strong> (List[str],):
The texts to encode as digits.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If there are NaN values within given texts.</li>
<li><strong>ValueError,</strong>: If there are non string values within given texts.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Numpy array with numpy arrays of tokens.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="LinkPredictionTransformer">
                                <div class="attr class">
        <a class="headerlink" href="#LinkPredictionTransformer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">LinkPredictionTransformer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LinkPredictionTransformer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;LinkPredictionTransformer class to convert graphs to edge embeddings.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new LinkPredictionTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">GraphTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">positive_graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
        <span class="n">negative_graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge embedding for given graph using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        positive_graph: Union[Graph, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to be embedded and labeled as positives.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>
<span class="sd">        negative_graph: Union[Graph, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to be embedded and labeled as positives.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to use to shuffle the labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Tuple with X and y values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positive_edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">positive_graph</span><span class="p">)</span>
        <span class="n">negative_edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">negative_graph</span><span class="p">)</span>
        <span class="n">edge_embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
            <span class="n">positive_edge_embedding</span><span class="p">,</span>
            <span class="n">negative_edge_embedding</span>
        <span class="p">])</span>
        <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">positive_edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">negative_edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">])</span>
        <span class="n">numpy_random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy_random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">edge_embeddings</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">edge_labels</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>LinkPredictionTransformer class to convert graphs to edge embeddings.</p>
</div>


                            <div id="LinkPredictionTransformer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinkPredictionTransformer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">LinkPredictionTransformer</span><span class="signature">(
    method: str = &#39;Hadamard&#39;,
    aligned_node_mapping: bool = False,
    support_mirrored_strategy: bool = False
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">aligned_node_mapping</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new LinkPredictionTransformer object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        method: str = &quot;hadamard&quot;,</span>
<span class="sd">            Method to use for the embedding.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        aligned_node_mapping: bool = False,</span>
<span class="sd">            This parameter specifies whether the mapping of the embeddings nodes</span>
<span class="sd">            matches the internal node mapping of the given graph.</span>
<span class="sd">            If these two mappings do not match, the generated edge embedding</span>
<span class="sd">            will be meaningless.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span> <span class="o">=</span> <span class="n">GraphTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">aligned_node_mapping</span><span class="o">=</span><span class="n">aligned_node_mapping</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new LinkPredictionTransformer object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>method</strong> (str = "hadamard",):
Method to use for the embedding.
Can either be 'Hadamard', 'Sum', 'Average', 'L1', 'AbsoluteL1', 'L2' or 'Concatenate'.</li>
<li><strong>aligned_node_mapping</strong> (bool = False,):
This parameter specifies whether the mapping of the embeddings nodes
matches the internal node mapping of the given graph.
If these two mappings do not match, the generated edge embedding
will be meaningless.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
</ul>
</div>


                            </div>
                            <div id="LinkPredictionTransformer.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinkPredictionTransformer.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(self, embedding: pandas.core.frame.DataFrame)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        embedding: pd.DataFrame,</span>
<span class="sd">            Embedding to use to fit the transformer.</span>
<span class="sd">            This is a pandas DataFrame and NOT a numpy array because we need</span>
<span class="sd">            to be able to remap correctly the vector embeddings in case of</span>
<span class="sd">            graphs that do not respect the same internal node mapping but have</span>
<span class="sd">            the same node set. It is possible to remap such graphs using</span>
<span class="sd">            Ensmallen&#39;s remap method but it may be less intuitive to users.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fit the model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>embedding</strong> (pd.DataFrame,):
Embedding to use to fit the transformer.
This is a pandas DataFrame and NOT a numpy array because we need
to be able to remap correctly the vector embeddings in case of
graphs that do not respect the same internal node mapping but have
the same node set. It is possible to remap such graphs using
Ensmallen's remap method but it may be less intuitive to users.</li>
</ul>
</div>


                            </div>
                            <div id="LinkPredictionTransformer.transform" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinkPredictionTransformer.transform">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">transform</span><span class="signature">(
    self,
    positive_graph: Union[Graph, numpy.ndarray, List[List[str]], List[List[int]]],
    negative_graph: Union[Graph, numpy.ndarray, List[List[str]], List[List[int]]],
    random_state: int = 42
) -&gt; Tuple[numpy.ndarray, numpy.ndarray]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">positive_graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
        <span class="n">negative_graph</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return edge embedding for given graph using provided method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        positive_graph: Union[Graph, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to be embedded and labeled as positives.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>
<span class="sd">        negative_graph: Union[Graph, List[List[str]], List[List[int]]],</span>
<span class="sd">            The graph whose edges are to be embedded and labeled as positives.</span>
<span class="sd">            It can either be an Graph or a list of lists of edges.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to use to shuffle the labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If embedding is not fitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------------</span>
<span class="sd">        Tuple with X and y values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positive_edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">positive_graph</span><span class="p">)</span>
        <span class="n">negative_edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">negative_graph</span><span class="p">)</span>
        <span class="n">edge_embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
            <span class="n">positive_edge_embedding</span><span class="p">,</span>
            <span class="n">negative_edge_embedding</span>
        <span class="p">])</span>
        <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">positive_edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">negative_edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">])</span>
        <span class="n">numpy_random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">random_state</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy_random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">edge_embeddings</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">edge_labels</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return edge embedding for given graph using provided method.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>positive_graph</strong> (Union[Graph, List[List[str]], List[List[int]]],):
The graph whose edges are to be embedded and labeled as positives.
It can either be an Graph or a list of lists of edges.</li>
<li><strong>negative_graph</strong> (Union[Graph, List[List[str]], List[List[int]]],):
The graph whose edges are to be embedded and labeled as positives.
It can either be an Graph or a list of lists of edges.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to use to shuffle the labels.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If embedding is not fitted.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Tuple with X and y values.</strong></li>
</ul>
</div>


                            </div>
                </section>
                <section id="GraphVisualization">
                                <div class="attr class">
        <a class="headerlink" href="#GraphVisualization">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphVisualization</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphVisualization</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Tools to visualize the graph embeddings.&quot;&quot;&quot;</span>

    <span class="n">DEFAULT_SCATTER_KWARGS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span>
    <span class="p">)</span>
    <span class="n">DEFAULT_SUBPLOT_KWARGS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
        <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">decomposition_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TSNE&quot;</span><span class="p">,</span>
        <span class="n">scaler_method</span><span class="p">:</span> <span class="s2">&quot;Scaler&quot;</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">,</span>
        <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">node_embedding_method_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_embedding_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">subsample_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20_000</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">decomposition_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GraphVisualization object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            The graph to visualize.</span>
<span class="sd">        decomposition_method: str = &quot;TSNE&quot;,</span>
<span class="sd">            The decomposition method to use.</span>
<span class="sd">            The supported methods are TSNE and PCA.</span>
<span class="sd">        scaler_method: &quot;Scaler&quot; = RobustScaler,</span>
<span class="sd">            The scaler object to use to normalize the embedding.</span>
<span class="sd">            By default we use a Robust Scaler.</span>
<span class="sd">            Pass None to not use any scaler.</span>
<span class="sd">        n_components: int = 2,</span>
<span class="sd">            Number of components to reduce the image to.</span>
<span class="sd">            Currently, we only support 2D decompositions but we plan</span>
<span class="sd">            to add support for also 3D decompositions.</span>
<span class="sd">        node_embedding_method_name: str = None,</span>
<span class="sd">            Name of the node embedding method used.</span>
<span class="sd">            If provided, it is added to the images titles.</span>
<span class="sd">        edge_embedding_method: str = &quot;Hadamard&quot;,</span>
<span class="sd">            Edge embedding method.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        subsample_points: int = 20_000,</span>
<span class="sd">            Number of points to subsample.</span>
<span class="sd">            Some graphs have a number of nodes and edges in the millions.</span>
<span class="sd">            Using non-CUDA versions of TSNE, the dimensionality reduction</span>
<span class="sd">            procedure can take a considerable amount of time.</span>
<span class="sd">            For this porpose, we include the possibility to subsample the</span>
<span class="sd">            points to the given number.</span>
<span class="sd">            The subsampling is done in a way that takes into consideration</span>
<span class="sd">            the node types and/or edge types (the subsampling is applied</span>
<span class="sd">            separately to the two different sets) by using a Stratified Shuffle</span>
<span class="sd">            Split if there are node types or edge types.</span>
<span class="sd">            Otherwise, a normal train test split is used.</span>
<span class="sd">            If None is given, no subsampling is executed.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the visualizations.</span>
<span class="sd">        decomposition_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to forward to the selected decomposition method.</span>

<span class="sd">        Raises</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the target decomposition size is not supported.</span>
<span class="sd">        ModuleNotFoundError,</span>
<span class="sd">            If TSNE decomposition has been required and no module supporting</span>
<span class="sd">            it is installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span> <span class="o">=</span> <span class="n">GraphTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">edge_embedding_method</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span> <span class="o">=</span> <span class="n">NodeTransformer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding_method_name</span> <span class="o">=</span> <span class="n">node_embedding_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="o">=</span> <span class="n">subsample_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>

        <span class="k">if</span> <span class="n">decomposition_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">decomposition_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">n_components</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;We currently only support 2D and 3D decomposition visualization.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">scaler_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scaler_method</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">decomposition_method</span> <span class="o">==</span> <span class="s2">&quot;TSNE&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># We try to use CUDA tsne if available, but this does not</span>
                <span class="c1"># currently support 3D decomposition. If the user has required a</span>
                <span class="c1"># 3D decomposition we need to switch to the MulticoreTSNE version.</span>
                <span class="c1"># Additionally, in the case that the desired decomposition</span>
                <span class="c1"># uses some not available parameters, such as a cosine distance</span>
                <span class="c1"># metric, we will capture that use case as a NotImplementedError.</span>
                <span class="k">if</span> <span class="n">n_components</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="kn">from</span> <span class="nn">tsnecuda</span> <span class="kn">import</span> <span class="n">TSNE</span> <span class="k">as</span> <span class="n">CUDATSNE</span>  <span class="c1"># pylint: disable=import-error,import-outside-toplevel</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">CUDATSNE</span><span class="p">(</span>
                    <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">random_seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">decomposition_kwargs</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">MulticoreTSNE</span> <span class="kn">import</span> \
                        <span class="n">MulticoreTSNE</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">MulticoreTSNE</span><span class="p">(</span>
                        <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">cpu_count</span><span class="p">(),</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">decomposition_kwargs</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> \
                            <span class="n">TSNE</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span>
                            <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                            <span class="n">n_jobs</span><span class="o">=</span><span class="n">cpu_count</span><span class="p">(),</span>
                            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">decomposition_kwargs</span>
                        <span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                            <span class="s2">&quot;You do not have installed a supported TSNE &quot;</span>
                            <span class="s2">&quot;decomposition algorithm. Depending on your use case, &quot;</span>
                            <span class="s2">&quot;we suggest you install tsne-cuda if your graph is &quot;</span>
                            <span class="s2">&quot;very big (in the millions of nodes) if you have access &quot;</span>
                            <span class="s2">&quot;to a compatible GPU system.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;Alternatively, we suggest (and support) MulticoreTSNE, &quot;</span>
                            <span class="s2">&quot;which tends to be easier to install, and is significantly &quot;</span>
                            <span class="s2">&quot;faster than the Sklearn implementation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;Alternatively, we suggest (and support) MulticoreTSNE, &quot;</span>
                            <span class="s2">&quot;which tends to be easier to install, and is significantly &quot;</span>
                            <span class="s2">&quot;faster than the Sklearn implementation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;If you intend to do 3D decompositions, &quot;</span>
                            <span class="s2">&quot;remember that tsne-cuda, at the time of writing, &quot;</span>
                            <span class="s2">&quot;does not support them.&quot;</span>
                        <span class="p">)</span>
        <span class="k">elif</span> <span class="n">decomposition_method</span> <span class="o">==</span> <span class="s2">&quot;PCA&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                <span class="o">**</span><span class="n">decomposition_kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;We currently only support PCA and TSNE decomposition methods.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return requested decomposition of given array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        X: np.ndarray,</span>
<span class="sd">            The data to embed.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given vector has less components than the required</span>
<span class="sd">            decomposition target.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        The obtained decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The vector to decompose has less components than &quot;</span>
                <span class="s2">&quot;the decomposition target.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_shuffle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return given arrays shuffled synchronously.</span>

<span class="sd">        The reason to shuffle the points is mainly that this avoids for</span>
<span class="sd">        &#39;fake&#39; clusters to appear simply by stacking the points by class</span>
<span class="sd">        artifically according to how the points are sorted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------</span>
<span class="sd">        *args: List[Union[np.ndarray, pd.DataFrame, None]],</span>
<span class="sd">            The lists to shuffle.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------</span>
<span class="sd">        Shuffled data using given random state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
        <span class="p">)</span>
        <span class="n">random_state</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">arg</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">arg</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
            <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_legend</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">handles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">HandlerBase</span><span class="p">],</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the legend with the given values and handles transparency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        axes: Axes,</span>
<span class="sd">            The axes on which to put the legend.</span>
<span class="sd">        labels: List[str],</span>
<span class="sd">            Labels to put in the legend.</span>
<span class="sd">        handles: List,</span>
<span class="sd">            Handles to display in the legend (the curresponding matplotlib</span>
<span class="sd">            objects).</span>
<span class="sd">        legend_title: str,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span>
            <span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">sanitize_ml_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span>
            <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">handler_map</span><span class="o">=</span><span class="p">{</span><span class="nb">tuple</span><span class="p">:</span> <span class="n">HandlerTuple</span><span class="p">(</span><span class="n">ndivide</span><span class="o">=</span><span class="kc">None</span><span class="p">)})</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">handles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">{}</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Setting alpha level in the legend to avoid having a transparent</span>
        <span class="c1"># legend scatter dots.</span>
        <span class="k">for</span> <span class="n">legend_handle</span> <span class="ow">in</span> <span class="n">legend</span><span class="o">.</span><span class="n">legendHandles</span><span class="p">:</span>
            <span class="n">legend_handle</span><span class="o">.</span><span class="n">_legmarker</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span>  <span class="c1"># pylint: disable=protected-access</span>
                <span class="mi">1</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit_transform_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes fitting for plotting node embeddings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        node_embedding: pd.DataFrame,</span>
<span class="sd">            Embedding of the graph nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve the nodes</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">())</span>
        <span class="c1"># If necessary, we proceed with the subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">:</span>
            <span class="c1"># If there are node types, we use a stratified</span>
            <span class="c1"># node sampling so that all the nodes types may be displayed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_singleton_node_types</span><span class="p">():</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">StratifiedShuffleSplit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise there is no need to stratify.</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">ShuffleSplit</span>
            <span class="c1"># We compute the indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">Splitter</span><span class="p">(</span>
                <span class="n">n_splits</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">train_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_multi_label_and_unknown_node_types</span><span class="p">()))</span>
            <span class="c1"># And sample the nodes</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="n">node_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">node_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit_transform_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes fitting for plotting edge embeddings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        node_embedding: Optional[pd.DataFrame] = None,</span>
<span class="sd">            Node embedding obtained from SkipGram, CBOW or GloVe or others.</span>
<span class="sd">        node_embedding: Optional[pd.DataFrame] = None,</span>
<span class="sd">            Edge embedding.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If neither the node embedding nor the edge embedding have</span>
<span class="sd">            been provided. You need to provide exactly one of the two.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the shape of the given node embedding does not match</span>
<span class="sd">            the number of nodes in the graph.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the shape of the given node embedding does not match</span>
<span class="sd">            the number of edges in the graph.   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You need to provide either the node embedding or the &quot;</span>
                <span class="s2">&quot;edge embedding.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You need to provide either the node embedding or the &quot;</span>
                <span class="s2">&quot;edge embedding. You cannot provide both at once.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;The number of rows provided with the given node embedding </span><span class="si">{}</span><span class="s2"> &quot;</span>
                 <span class="s2">&quot;does not match the number of nodes in the graph </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">node_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_directed_edges_number</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;The number of rows provided with the given edge embedding </span><span class="si">{}</span><span class="s2"> &quot;</span>
                 <span class="s2">&quot;does not match the number of directed edges in the graph </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_directed_edges_number</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Retrieve the edges</span>
        <span class="n">edge_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_node_names</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># If necessary, we proceed with the subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">:</span>
            <span class="c1"># If there are edge types, we use a stratified</span>
            <span class="c1"># edge sampling so that all the edges types may be displayed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_singleton_edge_types</span><span class="p">():</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">StratifiedShuffleSplit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise there is no need to stratify.</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">ShuffleSplit</span>
            <span class="c1"># We compute the indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">Splitter</span><span class="p">(</span>
                <span class="n">n_splits</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">train_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">edge_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_unknown_edge_types</span><span class="p">()))</span>
            <span class="c1"># And sample the edges</span>
            <span class="n">edge_names</span> <span class="o">=</span> <span class="n">edge_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_embedding</span> <span class="o">=</span> <span class="n">edge_embedding</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">),</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">)</span>
            <span class="n">edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">edge_embedding</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">edge_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_figure_and_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tuple with figure and axes built using provided kwargs and defaults.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                <span class="o">**</span><span class="n">GraphVisualization</span><span class="o">.</span><span class="n">DEFAULT_SUBPLOT_KWARGS</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">subplots_3d</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                <span class="o">**</span><span class="n">GraphVisualization</span><span class="o">.</span><span class="n">DEFAULT_SUBPLOT_KWARGS</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">})</span>
        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">_plot_scatter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Collection</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Plot nodes of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        title: str,</span>
<span class="sd">            Title to use for the plot.</span>
<span class="sd">        points: np.ndarray,</span>
<span class="sd">            Points to plot.</span>
<span class="sd">        colors: List[int] = None,</span>
<span class="sd">            List of the colors to use for the scatter plot.</span>
<span class="sd">        edgecolors: List[int] = None,</span>
<span class="sd">            List of the edge colors to use for the scatter plot.</span>
<span class="sd">        labels: List[str] = None,</span>
<span class="sd">            Labels for the different colors.</span>
<span class="sd">        legend_title: str = &quot;&quot;,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices, we only plot the</span>
<span class="sd">            training points.</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given train and test indices overlap.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot, followed by tuple of collections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">train_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">test_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The train and test indices overlap.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">figure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_figure_and_axes</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="n">GraphVisualization</span><span class="o">.</span><span class="n">DEFAULT_SCATTER_KWARGS</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">linewidths</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="o">**</span><span class="p">({}</span> <span class="k">if</span> <span class="n">scatter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scatter_kwargs</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="n">train_test_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">train_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_test_mask</span><span class="p">[</span><span class="n">train_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">test_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_test_mask</span><span class="p">[</span><span class="n">test_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">points</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">,</span> <span class="n">train_test_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shuffle</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">colors</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="p">,</span>
            <span class="n">train_test_mask</span>
        <span class="p">)</span>

        <span class="n">legend_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">collections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">color_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="s2">&quot;tab:blue&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:orange&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:green&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:red&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:purple&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:brown&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:pink&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:gray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:olive&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tab:cyan&quot;</span><span class="p">,</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">scatter_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                <span class="s2">&quot;cmap&quot;</span><span class="p">,</span>
                <span class="n">ListedColormap</span><span class="p">(</span><span class="n">color_names</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">train_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">test_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="o">*</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">),</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                <span class="o">**</span><span class="n">scatter_kwargs</span>
            <span class="p">)</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scatter</span><span class="p">)</span>
            <span class="n">legend_elements</span> <span class="o">+=</span> <span class="n">scatter</span><span class="o">.</span><span class="n">legend_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">train_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_mask</span> <span class="o">=</span> <span class="n">train_test_mask</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">train_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="o">*</span><span class="n">points</span><span class="p">[</span><span class="n">train_mask</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">train_mask</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span><span class="p">(</span>
                    <span class="n">edgecolors</span><span class="p">[</span><span class="n">train_mask</span><span class="p">]</span>
                <span class="p">),</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                <span class="o">**</span><span class="n">scatter_kwargs</span>
            <span class="p">)</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_scatter</span><span class="p">)</span>
            <span class="n">legend_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_scatter</span><span class="o">.</span><span class="n">legend_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">test_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">test_mask</span> <span class="o">=</span> <span class="n">train_test_mask</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="n">test_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="o">*</span><span class="n">points</span><span class="p">[</span><span class="n">test_mask</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">test_mask</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span><span class="p">(</span>
                    <span class="n">edgecolors</span><span class="p">[</span><span class="n">test_mask</span><span class="p">]),</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                <span class="o">**</span><span class="n">scatter_kwargs</span>
            <span class="p">)</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_scatter</span><span class="p">)</span>
            <span class="n">legend_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_scatter</span><span class="o">.</span><span class="n">legend_elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">rectangle_to_fill_legend</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
            <span class="n">visible</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">unique_train_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">train_mask</span><span class="p">])</span>
            <span class="n">unique_test_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">test_mask</span><span class="p">])</span>
            <span class="n">new_legend_elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">train_element_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">test_element_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
                <span class="n">new_tuple</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">unique_train_colors</span><span class="p">:</span>
                    <span class="n">new_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">legend_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">train_element_index</span><span class="p">])</span>
                    <span class="n">train_element_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rectangle_to_fill_legend</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">unique_test_colors</span><span class="p">:</span>
                    <span class="n">new_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">legend_elements</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">test_element_index</span><span class="p">])</span>
                    <span class="n">test_element_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rectangle_to_fill_legend</span><span class="p">)</span>

                <span class="n">new_legend_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_tuple</span><span class="p">))</span>
            <span class="n">legend_elements</span> <span class="o">=</span> <span class="n">new_legend_elements</span>

        <span class="k">if</span> <span class="n">show_legend</span> <span class="ow">and</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_legend</span><span class="p">(</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="n">labels</span><span class="p">,</span>
                <span class="n">legend_elements</span><span class="p">,</span>
                <span class="n">legend_title</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">title</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding_method_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">title</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding_method_name</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_title</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">figure</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">collections</span>

    <span class="k">def</span> <span class="nf">_plot_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">type_labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot common node types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        title: str,</span>
<span class="sd">            Title to use for the plot.</span>
<span class="sd">        points: np.ndarray,</span>
<span class="sd">            Points to plot.</span>
<span class="sd">        types: List[int],</span>
<span class="sd">            Types of the provided points.</span>
<span class="sd">        type_labels: List[str],</span>
<span class="sd">            List of the labels for the provided types.</span>
<span class="sd">        legend_title: str,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        predictions: List[int] = None,</span>
<span class="sd">            List of the labels predicted.</span>
<span class="sd">            If None, no prediction is visualized.</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of node types to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the number of given type labels does not match the number</span>
<span class="sd">            of given type counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Values of k greater than 9 are not supported!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># if not isinstance(types, np.ndarray):</span>
        <span class="c1">#     raise ValueError(</span>
        <span class="c1">#         &quot;Expecting types to be a numpy array.&quot;</span>
        <span class="c1">#     )</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="n">number_of_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">types</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
        <span class="n">type_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">type_labels</span><span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">number_of_types</span><span class="p">)</span>
        <span class="n">top_counts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">index</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">type_labels</span><span class="p">)),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)[:</span><span class="n">k</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="n">type_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">type_labels</span><span class="p">[</span><span class="n">top_counts</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">element_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_counts</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_counts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">element_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">predictions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">element_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_counts</span><span class="p">:</span>
                    <span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_counts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">element_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">number_of_types</span><span class="p">:</span>
            <span class="n">type_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_label</span><span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">types</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="n">predictions</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">type_labels</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">plot_edge_segments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">figure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_figure_and_axes</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_ids_from_node_ids</span><span class="p">(</span>
                <span class="n">node_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">,</span>
                <span class="n">add_selfloops_where_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_node_ids</span><span class="p">(</span>
                <span class="n">directed</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="n">lines_collection</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span>
            <span class="n">points</span><span class="p">[</span><span class="n">edge_node_ids</span><span class="p">],</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines_collection</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">plot_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot nodes of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        annotate_nodes: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to show the node name when scattering them.</span>
<span class="sd">            The default behaviour, &quot;auto&quot;, means that it will</span>
<span class="sd">            enable this feature automatically when the graph has</span>
<span class="sd">            less than 100 nodes.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Nodes embedding&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">annotate_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_name_from_node_id</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">txt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_names</span><span class="p">):</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot edge embedding of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Edges embedding&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_flatten_multi_label_and_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># The following is needed to normalize the multiple types</span>
        <span class="n">node_types_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_type_id_counts_hashmap</span><span class="p">()</span>
        <span class="n">node_types_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_types_number</span><span class="p">()</span>
        <span class="c1"># When we have multiple node types for a given node, we set it to</span>
        <span class="c1"># the most common node type of the set.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">node_type_ids</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">node_types_counts</span><span class="p">[</span><span class="n">node_type</span><span class="p">],</span>
                <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_type_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span>
            <span class="n">node_types_number</span>
            <span class="k">for</span> <span class="n">node_type_ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_type_ids</span><span class="p">()</span>
        <span class="p">])</span>

    <span class="k">def</span> <span class="nf">_flatten_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># The following is needed to normalize the multiple types</span>
        <span class="n">edge_types_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_types_number</span><span class="p">()</span>
        <span class="c1"># When we have multiple node types for a given node, we set it to</span>
        <span class="c1"># the most common node type of the set.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">edge_type_id</span>
            <span class="k">if</span> <span class="n">edge_type_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span>
            <span class="n">edge_types_number</span>
            <span class="k">for</span> <span class="n">edge_type_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_type_ids</span><span class="p">()</span>
        <span class="p">])</span>

    <span class="k">def</span> <span class="nf">plot_node_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_type_predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Node types&quot;</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot common node types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        node_type_predictions: List[int] = None,</span>
<span class="sd">            Predictions of the node types.</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of node types to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have node types!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="n">node_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_multi_label_and_unknown_node_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_types</span> <span class="o">=</span> <span class="n">node_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="n">node_type_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">():</span>
            <span class="n">node_type_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>

        <span class="n">node_type_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_type_names</span><span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Node types&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">node_types</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">node_type_names</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">node_type_predictions</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">plot_connected_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Component sizes&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot common node types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of components to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        legend_title: str = &quot;Component sizes&quot;,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">components_number</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">components_number</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Components&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="s2">&quot;Size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span>
            <span class="p">]),</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">plot_node_degrees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">use_log_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot node degrees heatmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices, </span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        use_log_scale: bool = True,</span>
<span class="sd">            Whether to use log scale.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_degrees</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">scatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Node degrees&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="o">**</span><span class="p">({}</span> <span class="k">if</span> <span class="n">scatter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scatter_kwargs</span><span class="p">),</span>
                <span class="s2">&quot;cmap&quot;</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">),</span>
                <span class="o">**</span><span class="p">({</span><span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">LogNorm</span><span class="p">()}</span> <span class="k">if</span> <span class="n">use_log_scale</span> <span class="k">else</span> <span class="p">{})</span>
            <span class="p">},</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">color_bar</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">draw_all</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">plot_edge_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_type_predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Edge types&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot common edge types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        edge_type_predictions: List[int] = None,</span>
<span class="sd">            Predictions of the edge types.</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of edge types to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        legend_title: str = &quot;Edge types&quot;,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have edge types!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting was not yet executed!&quot;</span>
            <span class="p">)</span>

        <span class="n">edge_type_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_types_number</span><span class="p">()</span>
        <span class="n">edge_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">edge_type_id</span>
            <span class="k">if</span> <span class="n">edge_type_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">edge_type_number</span>
            <span class="k">for</span> <span class="n">edge_type_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_type_ids</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_types</span> <span class="o">=</span> <span class="n">edge_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="n">edge_type_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_edge_type_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">():</span>
            <span class="n">edge_type_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>

        <span class="n">edge_type_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_type_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Edge types&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">edge_types</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">edge_type_names</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">edge_type_predictions</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_edge_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot common edge types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices, </span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_weights</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have edge weights!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">scatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Edge weights&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="o">**</span><span class="p">({}</span> <span class="k">if</span> <span class="n">scatter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scatter_kwargs</span><span class="p">),</span>
                <span class="s2">&quot;cmap&quot;</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">color_bar</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">draw_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">plot_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circo&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dot plot of the current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        engine: str = &quot;circo&quot;,</span>
<span class="sd">            The engine to use to visualize the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ModuleNotFoundError,</span>
<span class="sd">            If graphviz is not installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="s2">&quot;In order to run the graph Dot visualization, &quot;</span>
                <span class="s2">&quot;the graphviz library must be installed. This &quot;</span>
                <span class="s2">&quot;library is not an explicit dependency of &quot;</span>
                <span class="s2">&quot;Embiggen because it may be hard to install &quot;</span>
                <span class="s2">&quot;on some systems and cause the Embiggen library &quot;</span>
                <span class="s2">&quot;to fail the installation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to install graphviz, try running &quot;</span>
                <span class="s2">&quot;`pip install graphviz`.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">to_dot</span><span class="p">(),</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Tools to visualize the graph embeddings.</p>
</div>


                            <div id="GraphVisualization.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphVisualization</span><span class="signature">(
    graph: Graph,
    decomposition_method: str = &#39;TSNE&#39;,
    scaler_method: &#39;Scaler&#39; = &lt;class &#39;sklearn.preprocessing._data.RobustScaler&#39;&gt;,
    n_components: int = 2,
    node_embedding_method_name: str = None,
    edge_embedding_method: str = &#39;Hadamard&#39;,
    subsample_points: int = 20000,
    random_state: int = 42,
    decomposition_kwargs: Dict = None
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">decomposition_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TSNE&quot;</span><span class="p">,</span>
        <span class="n">scaler_method</span><span class="p">:</span> <span class="s2">&quot;Scaler&quot;</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">,</span>
        <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">node_embedding_method_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_embedding_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Hadamard&quot;</span><span class="p">,</span>
        <span class="n">subsample_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20_000</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">decomposition_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GraphVisualization object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            The graph to visualize.</span>
<span class="sd">        decomposition_method: str = &quot;TSNE&quot;,</span>
<span class="sd">            The decomposition method to use.</span>
<span class="sd">            The supported methods are TSNE and PCA.</span>
<span class="sd">        scaler_method: &quot;Scaler&quot; = RobustScaler,</span>
<span class="sd">            The scaler object to use to normalize the embedding.</span>
<span class="sd">            By default we use a Robust Scaler.</span>
<span class="sd">            Pass None to not use any scaler.</span>
<span class="sd">        n_components: int = 2,</span>
<span class="sd">            Number of components to reduce the image to.</span>
<span class="sd">            Currently, we only support 2D decompositions but we plan</span>
<span class="sd">            to add support for also 3D decompositions.</span>
<span class="sd">        node_embedding_method_name: str = None,</span>
<span class="sd">            Name of the node embedding method used.</span>
<span class="sd">            If provided, it is added to the images titles.</span>
<span class="sd">        edge_embedding_method: str = &quot;Hadamard&quot;,</span>
<span class="sd">            Edge embedding method.</span>
<span class="sd">            Can either be &#39;Hadamard&#39;, &#39;Sum&#39;, &#39;Average&#39;, &#39;L1&#39;, &#39;AbsoluteL1&#39;, &#39;L2&#39; or &#39;Concatenate&#39;.</span>
<span class="sd">        subsample_points: int = 20_000,</span>
<span class="sd">            Number of points to subsample.</span>
<span class="sd">            Some graphs have a number of nodes and edges in the millions.</span>
<span class="sd">            Using non-CUDA versions of TSNE, the dimensionality reduction</span>
<span class="sd">            procedure can take a considerable amount of time.</span>
<span class="sd">            For this porpose, we include the possibility to subsample the</span>
<span class="sd">            points to the given number.</span>
<span class="sd">            The subsampling is done in a way that takes into consideration</span>
<span class="sd">            the node types and/or edge types (the subsampling is applied</span>
<span class="sd">            separately to the two different sets) by using a Stratified Shuffle</span>
<span class="sd">            Split if there are node types or edge types.</span>
<span class="sd">            Otherwise, a normal train test split is used.</span>
<span class="sd">            If None is given, no subsampling is executed.</span>
<span class="sd">        random_state: int = 42,</span>
<span class="sd">            The random state to reproduce the visualizations.</span>
<span class="sd">        decomposition_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to forward to the selected decomposition method.</span>

<span class="sd">        Raises</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the target decomposition size is not supported.</span>
<span class="sd">        ModuleNotFoundError,</span>
<span class="sd">            If TSNE decomposition has been required and no module supporting</span>
<span class="sd">            it is installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span> <span class="o">=</span> <span class="n">GraphTransformer</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">edge_embedding_method</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span> <span class="o">=</span> <span class="n">NodeTransformer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding_method_name</span> <span class="o">=</span> <span class="n">node_embedding_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="o">=</span> <span class="n">subsample_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span> <span class="o">=</span> <span class="n">random_state</span>

        <span class="k">if</span> <span class="n">decomposition_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">decomposition_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">n_components</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;We currently only support 2D and 3D decomposition visualization.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">scaler_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scaler_method</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">decomposition_method</span> <span class="o">==</span> <span class="s2">&quot;TSNE&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># We try to use CUDA tsne if available, but this does not</span>
                <span class="c1"># currently support 3D decomposition. If the user has required a</span>
                <span class="c1"># 3D decomposition we need to switch to the MulticoreTSNE version.</span>
                <span class="c1"># Additionally, in the case that the desired decomposition</span>
                <span class="c1"># uses some not available parameters, such as a cosine distance</span>
                <span class="c1"># metric, we will capture that use case as a NotImplementedError.</span>
                <span class="k">if</span> <span class="n">n_components</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="kn">from</span> <span class="nn">tsnecuda</span> <span class="kn">import</span> <span class="n">TSNE</span> <span class="k">as</span> <span class="n">CUDATSNE</span>  <span class="c1"># pylint: disable=import-error,import-outside-toplevel</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">CUDATSNE</span><span class="p">(</span>
                    <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">random_seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">decomposition_kwargs</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">MulticoreTSNE</span> <span class="kn">import</span> \
                        <span class="n">MulticoreTSNE</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">MulticoreTSNE</span><span class="p">(</span>
                        <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                        <span class="n">n_jobs</span><span class="o">=</span><span class="n">cpu_count</span><span class="p">(),</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">decomposition_kwargs</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> \
                            <span class="n">TSNE</span>  <span class="c1"># pylint: disable=import-outside-toplevel</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span>
                            <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                            <span class="n">n_jobs</span><span class="o">=</span><span class="n">cpu_count</span><span class="p">(),</span>
                            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">decomposition_kwargs</span>
                        <span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                            <span class="s2">&quot;You do not have installed a supported TSNE &quot;</span>
                            <span class="s2">&quot;decomposition algorithm. Depending on your use case, &quot;</span>
                            <span class="s2">&quot;we suggest you install tsne-cuda if your graph is &quot;</span>
                            <span class="s2">&quot;very big (in the millions of nodes) if you have access &quot;</span>
                            <span class="s2">&quot;to a compatible GPU system.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;Alternatively, we suggest (and support) MulticoreTSNE, &quot;</span>
                            <span class="s2">&quot;which tends to be easier to install, and is significantly &quot;</span>
                            <span class="s2">&quot;faster than the Sklearn implementation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;Alternatively, we suggest (and support) MulticoreTSNE, &quot;</span>
                            <span class="s2">&quot;which tends to be easier to install, and is significantly &quot;</span>
                            <span class="s2">&quot;faster than the Sklearn implementation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;If you intend to do 3D decompositions, &quot;</span>
                            <span class="s2">&quot;remember that tsne-cuda, at the time of writing, &quot;</span>
                            <span class="s2">&quot;does not support them.&quot;</span>
                        <span class="p">)</span>
        <span class="k">elif</span> <span class="n">decomposition_method</span> <span class="o">==</span> <span class="s2">&quot;PCA&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                <span class="o">**</span><span class="n">decomposition_kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;We currently only support PCA and TSNE decomposition methods.&quot;</span>
            <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new GraphVisualization object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
The graph to visualize.</li>
<li><strong>decomposition_method</strong> (str = "TSNE",):
The decomposition method to use.
The supported methods are TSNE and PCA.</li>
<li><strong>scaler_method</strong> ("Scaler" = RobustScaler,):
The scaler object to use to normalize the embedding.
By default we use a Robust Scaler.
Pass None to not use any scaler.</li>
<li><strong>n_components</strong> (int = 2,):
Number of components to reduce the image to.
Currently, we only support 2D decompositions but we plan
to add support for also 3D decompositions.</li>
<li><strong>node_embedding_method_name</strong> (str = None,):
Name of the node embedding method used.
If provided, it is added to the images titles.</li>
<li><strong>edge_embedding_method</strong> (str = "Hadamard",):
Edge embedding method.
Can either be 'Hadamard', 'Sum', 'Average', 'L1', 'AbsoluteL1', 'L2' or 'Concatenate'.</li>
<li><strong>subsample_points</strong> (int = 20_000,):
Number of points to subsample.
Some graphs have a number of nodes and edges in the millions.
Using non-CUDA versions of TSNE, the dimensionality reduction
procedure can take a considerable amount of time.
For this porpose, we include the possibility to subsample the
points to the given number.
The subsampling is done in a way that takes into consideration
the node types and/or edge types (the subsampling is applied
separately to the two different sets) by using a Stratified Shuffle
Split if there are node types or edge types.
Otherwise, a normal train test split is used.
If None is given, no subsampling is executed.</li>
<li><strong>random_state</strong> (int = 42,):
The random state to reproduce the visualizations.</li>
<li><strong>decomposition_kwargs</strong> (Dict = None,):
Kwargs to forward to the selected decomposition method.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the target decomposition size is not supported.</li>
<li><strong>ModuleNotFoundError,</strong>: If TSNE decomposition has been required and no module supporting
it is installed.</li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.DEFAULT_SCATTER_KWARGS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GraphVisualization.DEFAULT_SCATTER_KWARGS">#&nbsp;&nbsp</a>

        <span class="name">DEFAULT_SCATTER_KWARGS</span><span class="default_value"> = {&#39;s&#39;: 5, &#39;alpha&#39;: 0.7}</span>
    </div>

    

                            </div>
                            <div id="GraphVisualization.DEFAULT_SUBPLOT_KWARGS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GraphVisualization.DEFAULT_SUBPLOT_KWARGS">#&nbsp;&nbsp</a>

        <span class="name">DEFAULT_SUBPLOT_KWARGS</span><span class="default_value"> = {&#39;figsize&#39;: (7, 7), &#39;dpi&#39;: 200}</span>
    </div>

    

                            </div>
                            <div id="GraphVisualization.decompose" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.decompose">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">decompose</span><span class="signature">(self, X: numpy.ndarray) -&gt; numpy.ndarray</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return requested decomposition of given array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        X: np.ndarray,</span>
<span class="sd">            The data to embed.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given vector has less components than the required</span>
<span class="sd">            decomposition target.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        The obtained decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_components</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The vector to decompose has less components than &quot;</span>
                <span class="s2">&quot;the decomposition target.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decomposition_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return requested decomposition of given array.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>X</strong> (np.ndarray,):
The data to embed.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the given vector has less components than the required
decomposition target.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>The obtained decomposition.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.fit_transform_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.fit_transform_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit_transform_nodes</span><span class="signature">(self, node_embedding: pandas.core.frame.DataFrame)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit_transform_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_embedding</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes fitting for plotting node embeddings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        node_embedding: pd.DataFrame,</span>
<span class="sd">            Embedding of the graph nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve the nodes</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">())</span>
        <span class="c1"># If necessary, we proceed with the subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">:</span>
            <span class="c1"># If there are node types, we use a stratified</span>
            <span class="c1"># node sampling so that all the nodes types may be displayed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_singleton_node_types</span><span class="p">():</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">StratifiedShuffleSplit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise there is no need to stratify.</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">ShuffleSplit</span>
            <span class="c1"># We compute the indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">Splitter</span><span class="p">(</span>
                <span class="n">n_splits</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">train_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_multi_label_and_unknown_node_types</span><span class="p">()))</span>
            <span class="c1"># And sample the nodes</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="n">node_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">node_names</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Executes fitting for plotting node embeddings.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_embedding</strong> (pd.DataFrame,):
Embedding of the graph nodes.</li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.fit_transform_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.fit_transform_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit_transform_edges</span><span class="signature">(
    self,
    node_embedding: Union[pandas.core.frame.DataFrame, NoneType] = None,
    edge_embedding: Union[pandas.core.frame.DataFrame, NoneType] = None
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit_transform_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes fitting for plotting edge embeddings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------</span>
<span class="sd">        node_embedding: Optional[pd.DataFrame] = None,</span>
<span class="sd">            Node embedding obtained from SkipGram, CBOW or GloVe or others.</span>
<span class="sd">        node_embedding: Optional[pd.DataFrame] = None,</span>
<span class="sd">            Edge embedding.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If neither the node embedding nor the edge embedding have</span>
<span class="sd">            been provided. You need to provide exactly one of the two.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the shape of the given node embedding does not match</span>
<span class="sd">            the number of nodes in the graph.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the shape of the given node embedding does not match</span>
<span class="sd">            the number of edges in the graph.   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You need to provide either the node embedding or the &quot;</span>
                <span class="s2">&quot;edge embedding.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You need to provide either the node embedding or the &quot;</span>
                <span class="s2">&quot;edge embedding. You cannot provide both at once.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;The number of rows provided with the given node embedding </span><span class="si">{}</span><span class="s2"> &quot;</span>
                 <span class="s2">&quot;does not match the number of nodes in the graph </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">node_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_directed_edges_number</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;The number of rows provided with the given edge embedding </span><span class="si">{}</span><span class="s2"> &quot;</span>
                 <span class="s2">&quot;does not match the number of directed edges in the graph </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">edge_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_directed_edges_number</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Retrieve the edges</span>
        <span class="n">edge_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_node_names</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># If necessary, we proceed with the subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">:</span>
            <span class="c1"># If there are edge types, we use a stratified</span>
            <span class="c1"># edge sampling so that all the edges types may be displayed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_singleton_edge_types</span><span class="p">():</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">StratifiedShuffleSplit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise there is no need to stratify.</span>
                <span class="n">Splitter</span> <span class="o">=</span> <span class="n">ShuffleSplit</span>
            <span class="c1"># We compute the indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">Splitter</span><span class="p">(</span>
                <span class="n">n_splits</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">train_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsample_points</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state</span>
            <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">edge_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_unknown_edge_types</span><span class="p">()))</span>
            <span class="c1"># And sample the edges</span>
            <span class="n">edge_names</span> <span class="o">=</span> <span class="n">edge_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_embedding</span> <span class="o">=</span> <span class="n">edge_embedding</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node_embedding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scaler_method</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">),</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">node_embedding</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">node_embedding</span><span class="p">)</span>
            <span class="n">edge_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">edge_embedding</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">edge_names</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Executes fitting for plotting edge embeddings.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_embedding</strong> (Optional[pd.DataFrame] = None,):
Node embedding obtained from SkipGram, CBOW or GloVe or others.</li>
<li><strong>node_embedding</strong> (Optional[pd.DataFrame] = None,):
Edge embedding.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If neither the node embedding nor the edge embedding have
been provided. You need to provide exactly one of the two.</li>
<li><strong>ValueError,</strong>: If the shape of the given node embedding does not match
the number of nodes in the graph.</li>
<li><strong>ValueError,</strong>: If the shape of the given node embedding does not match
the number of edges in the graph.</li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_edge_segments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_edge_segments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_edge_segments</span><span class="signature">(
    self,
    points: numpy.ndarray,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    **kwargs: Dict
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_edge_segments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">figure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_figure_and_axes</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_ids_from_node_ids</span><span class="p">(</span>
                <span class="n">node_ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">,</span>
                <span class="n">add_selfloops_where_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_node_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_node_ids</span><span class="p">(</span>
                <span class="n">directed</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="n">lines_collection</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span>
            <span class="n">points</span><span class="p">[</span><span class="n">edge_node_ids</span><span class="p">],</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lines_collection</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GraphVisualization.plot_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_nodes</span><span class="signature">(
    self,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    annotate_nodes: Union[str, bool] = &#39;auto&#39;,
    show_edges: bool = False,
    **kwargs: Dict
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot nodes of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        annotate_nodes: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to show the node name when scattering them.</span>
<span class="sd">            The default behaviour, &quot;auto&quot;, means that it will</span>
<span class="sd">            enable this feature automatically when the graph has</span>
<span class="sd">            less than 100 nodes.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Nodes embedding&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot nodes of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>annotate_nodes</strong> (Union[str, bool] = "auto",):
Whether to show the node name when scattering them.
The default behaviour, "auto", means that it will
enable this feature automatically when the graph has
less than 100 nodes.</li>
<li><strong>**kwargs</strong> (Dict,):
Arguments to pass to the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.annotate_nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.annotate_nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">annotate_nodes</span><span class="signature">(
    self,
    figure: matplotlib.figure.Figure,
    axes: matplotlib.axes._axes.Axes,
    points: numpy.ndarray
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">annotate_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_name_from_node_id</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">txt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_names</span><span class="p">):</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GraphVisualization.plot_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_edges</span><span class="signature">(
    self,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    **kwargs: Dict
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot edge embedding of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Edges embedding&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot edge embedding of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Arguments to pass to the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_node_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_node_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_node_types</span><span class="signature">(
    self,
    node_type_predictions: List[int] = None,
    k: int = 9,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    legend_title: str = &#39;Node types&#39;,
    other_label: str = &#39;Other&#39;,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    show_edges: bool = False,
    annotate_nodes: Union[str, bool] = &#39;auto&#39;,
    **kwargs
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_node_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_type_predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Node types&quot;</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot common node types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        node_type_predictions: List[int] = None,</span>
<span class="sd">            Predictions of the node types.</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of node types to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have node types!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="n">node_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_multi_label_and_unknown_node_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_types</span> <span class="o">=</span> <span class="n">node_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="n">node_type_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">():</span>
            <span class="n">node_type_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>

        <span class="n">node_type_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_type_names</span><span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Node types&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">node_types</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">node_type_names</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">node_type_predictions</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot common node types of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>node_type_predictions</strong> (List[int] = None,):
Predictions of the node types.</li>
<li><strong>k</strong> (int = 9,):
Number of node types to visualize.</li>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>other_label</strong> (str = "Other",):
Label to use for edges below the top k threshold.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Arguments to pass to the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
<li><strong>ValueError,</strong>: If given k is greater than maximum supported value (10).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_connected_components" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_connected_components">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_connected_components</span><span class="signature">(
    self,
    k: int = 9,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    other_label: str = &#39;Other&#39;,
    legend_title: str = &#39;Component sizes&#39;,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    show_edges: bool = False,
    annotate_nodes: Union[str, bool] = &#39;auto&#39;,
    **kwargs
) -&gt; Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_connected_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Component sizes&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Plot common node types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of components to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        legend_title: str = &quot;Component sizes&quot;,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Arguments to pass to the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="n">components</span><span class="p">,</span> <span class="n">components_number</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">components_number</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Components&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="s2">&quot;Size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span>
            <span class="p">]),</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot common node types of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>k</strong> (int = 9,):
Number of components to visualize.</li>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>other_label</strong> (str = "Other",):
Label to use for edges below the top k threshold.</li>
<li><strong>legend_title</strong> (str = "Component sizes",):
Title for the legend.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Arguments to pass to the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
<li><strong>ValueError,</strong>: If given k is greater than maximum supported value (10).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_node_degrees" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_node_degrees">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_node_degrees</span><span class="signature">(
    self,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    use_log_scale: bool = True,
    show_title: bool = True,
    show_legend: bool = True,
    show_edges: bool = False,
    annotate_nodes: Union[str, bool] = &#39;auto&#39;,
    **kwargs: Dict
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_node_degrees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">use_log_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">annotate_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot node degrees heatmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices, </span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        use_log_scale: bool = True,</span>
<span class="sd">            Whether to use log scale.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Node fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">degrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_degrees</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_node_ids</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">annotate_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_edge_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">scatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Node degrees&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="o">**</span><span class="p">({}</span> <span class="k">if</span> <span class="n">scatter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scatter_kwargs</span><span class="p">),</span>
                <span class="s2">&quot;cmap&quot;</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">),</span>
                <span class="o">**</span><span class="p">({</span><span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">LogNorm</span><span class="p">()}</span> <span class="k">if</span> <span class="n">use_log_scale</span> <span class="k">else</span> <span class="p">{})</span>
            <span class="p">},</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">color_bar</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">draw_all</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">annotate_nodes</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotate_nodes</span><span class="p">(</span>
                <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot node degrees heatmap.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>use_log_scale</strong> (bool = True,):
Whether to use log scale.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs for the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_edge_types" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_edge_types">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_edge_types</span><span class="signature">(
    self,
    edge_type_predictions: List[int] = None,
    k: int = 9,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    other_label: str = &#39;Other&#39;,
    legend_title: str = &#39;Edge types&#39;,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    **kwargs: Dict
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_edge_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_type_predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Other&quot;</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Edge types&quot;</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot common edge types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        edge_type_predictions: List[int] = None,</span>
<span class="sd">            Predictions of the edge types.</span>
<span class="sd">        k: int = 9,</span>
<span class="sd">            Number of edge types to visualize.</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        other_label: str = &quot;Other&quot;,</span>
<span class="sd">            Label to use for edges below the top k threshold.</span>
<span class="sd">        legend_title: str = &quot;Edge types&quot;,</span>
<span class="sd">            Title for the legend.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices,</span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given k is greater than maximum supported value (10).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have edge types!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting was not yet executed!&quot;</span>
            <span class="p">)</span>

        <span class="n">edge_type_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_types_number</span><span class="p">()</span>
        <span class="n">edge_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">edge_type_id</span>
            <span class="k">if</span> <span class="n">edge_type_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">edge_type_number</span>
            <span class="k">for</span> <span class="n">edge_type_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_type_ids</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_types</span> <span class="o">=</span> <span class="n">edge_types</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="n">edge_type_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_edge_type_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">():</span>
            <span class="n">edge_type_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>

        <span class="n">edge_type_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_type_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_types</span><span class="p">(</span>
            <span class="s2">&quot;Edge types&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">types</span><span class="o">=</span><span class="n">edge_types</span><span class="p">,</span>
            <span class="n">type_labels</span><span class="o">=</span><span class="n">edge_type_names</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">edge_type_predictions</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">other_label</span><span class="o">=</span><span class="n">other_label</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot common edge types of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>edge_type_predictions</strong> (List[int] = None,):
Predictions of the edge types.</li>
<li><strong>k</strong> (int = 9,):
Number of edge types to visualize.</li>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>other_label</strong> (str = "Other",):
Label to use for edges below the top k threshold.</li>
<li><strong>legend_title</strong> (str = "Edge types",):
Title for the legend.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs for the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the graph does not have edge types.</li>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
<li><strong>ValueError,</strong>: If given k is greater than maximum supported value (10).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_edge_weights" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_edge_weights">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_edge_weights</span><span class="signature">(
    self,
    figure: matplotlib.figure.Figure = None,
    axes: matplotlib.axes._axes.Axes = None,
    scatter_kwargs: Dict = None,
    train_indices: numpy.ndarray = None,
    test_indices: numpy.ndarray = None,
    train_marker: str = &#39;o&#39;,
    test_marker: str = &#39;X&#39;,
    show_title: bool = True,
    show_legend: bool = True,
    **kwargs: Dict
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_edge_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">Figure</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">test_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">test_marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">show_title</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot common edge types of provided graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        figure: Figure = None,</span>
<span class="sd">            Figure to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        axes: Axes = None,</span>
<span class="sd">            Axes to use to plot. If None, a new one is created using the</span>
<span class="sd">            provided kwargs.</span>
<span class="sd">        scatter_kwargs: Dict = None,</span>
<span class="sd">            Kwargs to pass to the scatter plot call.</span>
<span class="sd">        train_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the training marker.</span>
<span class="sd">            If None, all points are drawn using the training marker.</span>
<span class="sd">        test_indices: np.ndarray = None,</span>
<span class="sd">            Indices to draw using the test marker.</span>
<span class="sd">            If None, while providing the train indices, </span>
<span class="sd">        train_marker: str = &quot;o&quot;,</span>
<span class="sd">            The marker to use to draw the training points.</span>
<span class="sd">        test_marker: str = &quot;X&quot;,</span>
<span class="sd">            The marker to use to draw the test points.</span>
<span class="sd">        show_title: bool = True,</span>
<span class="sd">            Whether to show the figure title.</span>
<span class="sd">        show_legend: bool = True,</span>
<span class="sd">            Whether to show the legend.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs for the subplots.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If edge fitting was not yet executed.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        Figure and Axis of the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">has_edge_weights</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The graph does not have edge weights!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_embedding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge fitting must be executed before plot.&quot;</span>
            <span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_edge_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsampled_edge_ids</span><span class="p">]</span>

        <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">scatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_scatter</span><span class="p">(</span>
            <span class="s2">&quot;Edge weights&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_embedding</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">scatter_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="o">**</span><span class="p">({}</span> <span class="k">if</span> <span class="n">scatter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scatter_kwargs</span><span class="p">),</span>
                <span class="s2">&quot;cmap&quot;</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">train_indices</span><span class="o">=</span><span class="n">train_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="o">=</span><span class="n">test_indices</span><span class="p">,</span>
            <span class="n">train_marker</span><span class="o">=</span><span class="n">train_marker</span><span class="p">,</span>
            <span class="n">test_marker</span><span class="o">=</span><span class="n">test_marker</span><span class="p">,</span>
            <span class="n">show_title</span><span class="o">=</span><span class="n">show_title</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">show_legend</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">color_bar</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">color_bar</span><span class="o">.</span><span class="n">draw_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axes</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plot common edge types of provided graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>figure</strong> (Figure = None,):
Figure to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>axes</strong> (Axes = None,):
Axes to use to plot. If None, a new one is created using the
provided kwargs.</li>
<li><strong>scatter_kwargs</strong> (Dict = None,):
Kwargs to pass to the scatter plot call.</li>
<li><strong>train_indices</strong> (np.ndarray = None,):
Indices to draw using the training marker.
If None, all points are drawn using the training marker.</li>
<li><strong>test_indices</strong> (np.ndarray = None,):
Indices to draw using the test marker.
If None, while providing the train indices,</li>
<li><strong>train_marker</strong> (str = "o",):
The marker to use to draw the training points.</li>
<li><strong>test_marker</strong> (str = "X",):
The marker to use to draw the test points.</li>
<li><strong>show_title</strong> (bool = True,):
Whether to show the figure title.</li>
<li><strong>show_legend</strong> (bool = True,):
Whether to show the legend.</li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs for the subplots.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If edge fitting was not yet executed.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Figure and Axis of the plot.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphVisualization.plot_dot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphVisualization.plot_dot">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">plot_dot</span><span class="signature">(self, engine: str = &#39;circo&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">plot_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circo&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dot plot of the current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        engine: str = &quot;circo&quot;,</span>
<span class="sd">            The engine to use to visualize the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        ModuleNotFoundError,</span>
<span class="sd">            If graphviz is not installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="s2">&quot;In order to run the graph Dot visualization, &quot;</span>
                <span class="s2">&quot;the graphviz library must be installed. This &quot;</span>
                <span class="s2">&quot;library is not an explicit dependency of &quot;</span>
                <span class="s2">&quot;Embiggen because it may be hard to install &quot;</span>
                <span class="s2">&quot;on some systems and cause the Embiggen library &quot;</span>
                <span class="s2">&quot;to fail the installation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;In order to install graphviz, try running &quot;</span>
                <span class="s2">&quot;`pip install graphviz`.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">to_dot</span><span class="p">(),</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return dot plot of the current graph.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>engine</strong> (str = "circo",):
The engine to use to visualize the graph.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ModuleNotFoundError,</strong>: If graphviz is not installed.</li>
</ul>
</div>


                            </div>
                </section>
                <section id="TransE">
                                <div class="attr class">
        <a class="headerlink" href="#TransE">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TransE</span><wbr>(<span class="base"><a href="#Siamese">grape.embiggen.Siamese</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TransE</span><span class="p">(</span><span class="n">Siamese</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Siamese network for node-embedding including optionally node types and edge types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">use_node_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_types_combination</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Add&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransE&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        node_types_combination: str = &quot;Add&quot;,</span>
<span class="sd">            Method to combine the node embedding with the node type ambedding.</span>
<span class="sd">            The supported methods are &quot;Add&quot; and &quot;Concatenate&quot;.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransE&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="n">use_node_types</span><span class="p">,</span>
            <span class="n">node_types_combination</span><span class="o">=</span><span class="n">node_types_combination</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">node_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">edge_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">destination_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">edge_type_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_types_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
            <span class="n">source_node_embedding</span> <span class="o">+</span> <span class="n">edge_type_embedding</span><span class="p">,</span>
            <span class="n">destination_node_embedding</span><span class="p">,</span>
            <span class="n">edge_type_embedding</span><span class="p">,</span>
            <span class="n">edge_types_input</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Siamese network for node-embedding including optionally node types and edge types.</p>
</div>


                            <div id="TransE.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TransE.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TransE</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    distance_metric: str = &#39;COSINE&#39;,
    use_node_types: Union[bool, str] = &#39;auto&#39;,
    node_types_combination: str = &#39;Add&#39;,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    model_name: str = &#39;TransE&#39;,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    support_mirrored_strategy: bool = False,
    use_gradient_centralization: str = &#39;auto&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">use_node_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_types_combination</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Add&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransE&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        node_types_combination: str = &quot;Add&quot;,</span>
<span class="sd">            Method to combine the node embedding with the node type ambedding.</span>
<span class="sd">            The supported methods are &quot;Add&quot; and &quot;Concatenate&quot;.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransE&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="n">use_node_types</span><span class="p">,</span>
            <span class="n">node_types_combination</span><span class="o">=</span><span class="n">node_types_combination</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">node_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">edge_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int = None,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>distance_metric</strong> (str = "COSINE",):
The distance to use for the loss function.
Supported methods are L1, L2 and COSINE.</li>
<li><strong>node_types_combination</strong> (str = "Add",):
Method to combine the node embedding with the node type ambedding.
The supported methods are "Add" and "Concatenate".</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>model_name</strong> (str = "TransE",):
Name of the model.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Siamese">Siamese</a></dt>
                                <dd id="TransE.NODE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">NODE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransE.EDGE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">EDGE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransE.get_embedding_dataframe" class="function"><a href="#Siamese.get_embedding_dataframe">get_embedding_dataframe</a></dd>
                <dd id="TransE.embedding" class="variable"><a href="#Siamese.embedding">embedding</a></dd>
                <dd id="TransE.fit" class="function"><a href="#Siamese.fit">fit</a></dd>

            </div>
            <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="TransE.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="TransE.trainable" class="variable">trainable</dd>
                <dd id="TransE.summary" class="function">summary</dd>
                <dd id="TransE.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="TransE.save_embedding" class="function">save_embedding</dd>
                <dd id="TransE.name" class="variable">name</dd>
                <dd id="TransE.save_weights" class="function">save_weights</dd>
                <dd id="TransE.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TransH">
                                <div class="attr class">
        <a class="headerlink" href="#TransH">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TransH</span><wbr>(<span class="base"><a href="#TransE">grape.embiggen.TransE</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TransH</span><span class="p">(</span><span class="n">TransE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Siamese network for node-embedding including optionally node types and edge types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransH&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransH&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">destination_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">edge_type_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_types_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output of the model.&quot;&quot;&quot;</span>
        <span class="n">normal_edge_type_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;normal_edge_type_embedding_layer&quot;</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">edge_types_input</span><span class="p">)</span>

        <span class="n">normal_edge_type_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)(</span><span class="n">normal_edge_type_embedding</span><span class="p">)</span>

        <span class="n">source_node_embedding</span> <span class="o">-=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="n">normal_edge_type_embedding</span><span class="p">,</span>
            <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">source_node_embedding</span> <span class="o">*</span> <span class="n">normal_edge_type_embedding</span>

        <span class="n">destination_node_embedding</span> <span class="o">-=</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="n">normal_edge_type_embedding</span><span class="p">,</span>
            <span class="n">perm</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">destination_node_embedding</span> <span class="o">*</span> <span class="n">normal_edge_type_embedding</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
            <span class="n">source_node_embedding</span><span class="p">,</span>
            <span class="n">destination_node_embedding</span><span class="p">,</span>
            <span class="n">edge_type_embedding</span><span class="p">,</span>
            <span class="n">edge_types_input</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Siamese network for node-embedding including optionally node types and edge types.</p>
</div>


                            <div id="TransH.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TransH.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TransH</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    distance_metric: str = &#39;COSINE&#39;,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    model_name: str = &#39;TransH&#39;,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    support_mirrored_strategy: bool = False,
    use_gradient_centralization: str = &#39;auto&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransH&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransH&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int = None,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>distance_metric</strong> (str = "COSINE",):
The distance to use for the loss function.
Supported methods are L1, L2 and COSINE.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>model_name</strong> (str = "TransH",):
Name of the model.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div id="TransH.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TransH.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    batch_size: int = 32768,
    negative_samples_rate: float = 0.5,
    avoid_false_negatives: bool = False,
    graph_to_avoid: Graph = None,
    batches_per_epoch: Union[int, str] = &#39;auto&#39;,
    elapsed_epochs: int = 0,
    epochs: int = 1000,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_min_delta: float = 0.01,
    early_stopping_patience: int = 5,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_min_delta: float = 0.01,
    reduce_lr_patience: int = 2,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 2,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
Graph to embed.</li>
<li><strong>epochs</strong> (int = 100,):
Epochs to train the model for.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_min_delta</strong> (float = 0.1,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int = 5,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_min_delta</strong> (float = 1,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int = 3,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 2,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Siamese">Siamese</a></dt>
                                <dd id="TransH.NODE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">NODE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransH.EDGE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">EDGE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransH.get_embedding_dataframe" class="function"><a href="#Siamese.get_embedding_dataframe">get_embedding_dataframe</a></dd>
                <dd id="TransH.embedding" class="variable"><a href="#Siamese.embedding">embedding</a></dd>

            </div>
            <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="TransH.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="TransH.trainable" class="variable">trainable</dd>
                <dd id="TransH.summary" class="function">summary</dd>
                <dd id="TransH.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="TransH.save_embedding" class="function">save_embedding</dd>
                <dd id="TransH.name" class="variable">name</dd>
                <dd id="TransH.save_weights" class="function">save_weights</dd>
                <dd id="TransH.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TransR">
                                <div class="attr class">
        <a class="headerlink" href="#TransR">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TransR</span><wbr>(<span class="base"><a href="#TransE">grape.embiggen.TransE</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TransR</span><span class="p">(</span><span class="n">TransE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Siamese network for node-embedding including optionally node types and edge types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransR&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransR&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">destination_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">edge_type_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_types_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output of the model.&quot;&quot;&quot;</span>
        <span class="n">normal_edge_type_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;normal_edge_type_embedding_layer&quot;</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">edge_types_input</span><span class="p">)</span>

        <span class="n">normal_edge_type_embedding_matrix</span> <span class="o">=</span> <span class="n">Reshape</span><span class="p">((</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span>
        <span class="p">))(</span><span class="n">normal_edge_type_embedding</span><span class="p">)</span>

        <span class="n">source_node_embedding</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">l2_normalize</span><span class="p">(</span>
            <span class="n">normal_edge_type_embedding_matrix</span> <span class="o">*</span> <span class="n">source_node_embedding</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">destination_node_embedding</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">l2_normalize</span><span class="p">(</span>
            <span class="n">normal_edge_type_embedding_matrix</span> <span class="o">*</span> <span class="n">destination_node_embedding</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
            <span class="n">source_node_embedding</span><span class="p">,</span>
            <span class="n">destination_node_embedding</span><span class="p">,</span>
            <span class="n">edge_type_embedding</span><span class="p">,</span>
            <span class="n">edge_types_input</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Siamese network for node-embedding including optionally node types and edge types.</p>
</div>


                            <div id="TransR.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TransR.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TransR</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    distance_metric: str = &#39;COSINE&#39;,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    model_name: str = &#39;TransR&#39;,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    support_mirrored_strategy: bool = False,
    use_gradient_centralization: str = &#39;auto&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TransR&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;TransR&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">distance_metric</span><span class="o">=</span><span class="n">distance_metric</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int = None,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>distance_metric</strong> (str = "COSINE",):
The distance to use for the loss function.
Supported methods are L1, L2 and COSINE.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>model_name</strong> (str = "TransR",):
Name of the model.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div id="TransR.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TransR.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    batch_size: int = 32768,
    negative_samples_rate: float = 0.5,
    avoid_false_negatives: bool = False,
    graph_to_avoid: Graph = None,
    batches_per_epoch: Union[int, str] = &#39;auto&#39;,
    elapsed_epochs: int = 0,
    epochs: int = 1000,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_min_delta: float = 0.01,
    early_stopping_patience: int = 5,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_min_delta: float = 0.01,
    reduce_lr_patience: int = 2,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 2,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
Graph to embed.</li>
<li><strong>epochs</strong> (int = 100,):
Epochs to train the model for.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_min_delta</strong> (float = 0.1,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int = 5,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_min_delta</strong> (float = 1,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int = 3,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 2,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Siamese">Siamese</a></dt>
                                <dd id="TransR.NODE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">NODE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransR.EDGE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">EDGE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="TransR.get_embedding_dataframe" class="function"><a href="#Siamese.get_embedding_dataframe">get_embedding_dataframe</a></dd>
                <dd id="TransR.embedding" class="variable"><a href="#Siamese.embedding">embedding</a></dd>

            </div>
            <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="TransR.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="TransR.trainable" class="variable">trainable</dd>
                <dd id="TransR.summary" class="function">summary</dd>
                <dd id="TransR.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="TransR.save_embedding" class="function">save_embedding</dd>
                <dd id="TransR.name" class="variable">name</dd>
                <dd id="TransR.save_weights" class="function">save_weights</dd>
                <dd id="TransR.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SimplE">
                                <div class="attr class">
        <a class="headerlink" href="#SimplE">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SimplE</span><wbr>(<span class="base"><a href="#Siamese">grape.embiggen.Siamese</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SimplE</span><span class="p">(</span><span class="n">Siamese</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Siamese network for node-embedding including optionally node types and edge types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SimplE&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;SimplE&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">edge_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">destination_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">edge_type_embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_types_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output of the model.&quot;&quot;&quot;</span>
        <span class="n">reverse_edge_type_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reverse_edge_type_embedding_layer&quot;</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">edge_types_input</span><span class="p">)</span>
        <span class="n">reverse_edge_type_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)(</span><span class="n">reverse_edge_type_embedding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">source_node_embedding</span> <span class="o">*</span> <span class="n">edge_type_embedding</span> <span class="o">*</span> <span class="n">destination_node_embedding</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">destination_node_embedding</span> <span class="o">*</span> <span class="n">reverse_edge_type_embedding</span> <span class="o">*</span> <span class="n">source_node_embedding</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Siamese network for node-embedding including optionally node types and edge types.</p>
</div>


                            <div id="SimplE.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SimplE.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SimplE</span><span class="signature">(
    graph: Graph,
    embedding_size: int = 100,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame] = None,
    model_name: str = &#39;SimplE&#39;,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    support_mirrored_strategy: bool = False,
    use_gradient_centralization: str = &#39;auto&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SimplE&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;SimplE&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">edge_type_embedding_size</span><span class="o">=</span><span class="n">embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="n">support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int = None,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>embedding_size</strong> (int = 100,):
Dimension of the embedding.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>model_name</strong> (str = "SimplE",):
Name of the model.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Siamese">Siamese</a></dt>
                                <dd id="SimplE.NODE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">NODE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="SimplE.EDGE_TYPE_EMBEDDING_LAYER_NAME" class="variable"><a href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">EDGE_TYPE_EMBEDDING_LAYER_NAME</a></dd>
                <dd id="SimplE.get_embedding_dataframe" class="function"><a href="#Siamese.get_embedding_dataframe">get_embedding_dataframe</a></dd>
                <dd id="SimplE.embedding" class="variable"><a href="#Siamese.embedding">embedding</a></dd>
                <dd id="SimplE.fit" class="function"><a href="#Siamese.fit">fit</a></dd>

            </div>
            <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="SimplE.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="SimplE.trainable" class="variable">trainable</dd>
                <dd id="SimplE.summary" class="function">summary</dd>
                <dd id="SimplE.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="SimplE.save_embedding" class="function">save_embedding</dd>
                <dd id="SimplE.name" class="variable">name</dd>
                <dd id="SimplE.save_weights" class="function">save_weights</dd>
                <dd id="SimplE.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Siamese">
                                <div class="attr class">
        <a class="headerlink" href="#Siamese">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Siamese</span><wbr>(<span class="base">grape.embiggen.embedders.embedder.Embedder</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Siamese</span><span class="p">(</span><span class="n">Embedder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Siamese network for node-embedding including optionally node types and edge types.&quot;&quot;&quot;</span>

    <span class="n">NODE_TYPE_EMBEDDING_LAYER_NAME</span> <span class="o">=</span> <span class="s2">&quot;node_type_embedding_layer&quot;</span>
    <span class="n">EDGE_TYPE_EMBEDDING_LAYER_NAME</span> <span class="o">=</span> <span class="s2">&quot;edge_type_embedding_layer&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">use_node_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_types_combination</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Add&quot;</span><span class="p">,</span>
        <span class="n">use_edge_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">node_type_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">edge_type_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">relu_bias</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Siamese&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        use_node_types: Union[bool, str] = &quot;auto&quot;,</span>
<span class="sd">            Whether to use node type.</span>
<span class="sd">            By default, it will automatially use node types if the graph</span>
<span class="sd">            contains node type and does not contain any unknown node type.</span>
<span class="sd">        node_types_combination: str = &quot;Add&quot;,</span>
<span class="sd">            Method to combine the node embedding with the node type ambedding.</span>
<span class="sd">            The supported methods are &quot;Add&quot; and &quot;Concatenate&quot;.</span>
<span class="sd">        use_edge_types: Union[bool, str] = &quot;auto&quot;,</span>
<span class="sd">            Whether to use edge type.</span>
<span class="sd">            By default, it will automatially use edge types if the graph</span>
<span class="sd">            contains edge type and does not contain any unknown edge type.</span>
<span class="sd">        node_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        node_type_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding for the node types.</span>
<span class="sd">        edge_type_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding for the edge types.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        relu_bias: float = 1.0,</span>
<span class="sd">            The bias to use for the ReLu.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;Siamese&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_disconnected_nodes</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The graph contains disconnected nodes: these nodes will &quot;</span>
                <span class="s2">&quot;not be embedded in a semantically sensible way, but &quot;</span>
                <span class="s2">&quot;will only obtain a random node embedding vector which is &quot;</span>
                <span class="s2">&quot;far from all other nodes.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_node_types</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_node_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Node types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph does not have node types&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Node types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph contains unknown node types and this &quot;</span>
                    <span class="s2">&quot;type of model is not designed in order to handle &quot;</span>
                    <span class="s2">&quot;unknown node types.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_singleton_node_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The node types will be used in order to compute the node &quot;</span>
                    <span class="s2">&quot;embedding, but there are some singleton node types: these &quot;</span>
                    <span class="s2">&quot;node types will not capture any characteristic that is not &quot;</span>
                    <span class="s2">&quot;already captured by the node embedding, and may be an error &quot;</span>
                    <span class="s2">&quot;in the pipeline you have used to create this graph.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_homogeneous_node_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The graph contains exclusively nodes with a homogenous &quot;</span>
                    <span class="s2">&quot;node type!&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_multilabel_node_types</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_maximum_multilabel_count</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_types_number</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_edge_types</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_edge_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_edge_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Edge types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph does not have edge types&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Edge types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph contains unknown edge types and this &quot;</span>
                    <span class="s2">&quot;type of model is not designed in order to handle &quot;</span>
                    <span class="s2">&quot;unknown edge types.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_singleton_edge_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The edge types will be used in order to compute the edge &quot;</span>
                    <span class="s2">&quot;embedding, but there are some singleton edge types: these &quot;</span>
                    <span class="s2">&quot;edge types will not capture any characteristic that is not &quot;</span>
                    <span class="s2">&quot;already captured by the edge embedding, and may be an error &quot;</span>
                    <span class="s2">&quot;in the pipeline you have used to create this graph.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_homogeneous_edge_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The graph contains exclusively edges with a homogenous &quot;</span>
                    <span class="s2">&quot;edge type!&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge_types_number</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_combination</span> <span class="o">=</span> <span class="n">node_types_combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span> <span class="o">=</span> <span class="n">use_node_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span> <span class="o">=</span> <span class="n">use_edge_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_type_embedding_size</span> <span class="o">=</span> <span class="n">node_type_embedding_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span> <span class="o">=</span> <span class="n">edge_type_embedding_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span> <span class="o">=</span> <span class="n">distance_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relu_bias</span> <span class="o">=</span> <span class="n">relu_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">(),</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">node_embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Node2Vec model.&quot;&quot;&quot;</span>
        <span class="c1"># Creating the inputs layers</span>
        <span class="n">input_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">source_nodes_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;source_nodes&quot;</span><span class="p">)</span>
        <span class="n">input_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_nodes_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">:</span>
            <span class="n">source_node_types_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_node_types</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;source_node_types&quot;</span><span class="p">)</span>
            <span class="n">input_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_node_types_input</span><span class="p">)</span>

        <span class="n">destination_nodes_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;destination_nodes&quot;</span><span class="p">)</span>
        <span class="n">input_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">destination_nodes_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">:</span>
            <span class="n">destination_node_types_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_node_types</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;destination_node_types&quot;</span><span class="p">)</span>
            <span class="n">input_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">destination_node_types_input</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">:</span>
            <span class="n">edge_types_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;destination_edge_types&quot;</span><span class="p">)</span>
            <span class="n">input_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_types_input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_types_input</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Creating the embedding layer for the contexts</span>
        <span class="n">node_embedding_layer</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_vocabulary_size</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_embedding_size</span><span class="p">,</span>
            <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span>
        <span class="p">)</span>

        <span class="c1"># Get the node embedding</span>
        <span class="n">source_node_embedding</span> <span class="o">=</span> <span class="n">node_embedding_layer</span><span class="p">(</span><span class="n">source_nodes_input</span><span class="p">)</span>
        <span class="n">destination_node_embedding</span> <span class="o">=</span> <span class="n">node_embedding_layer</span><span class="p">(</span>
            <span class="n">destination_nodes_input</span>
        <span class="p">)</span>

        <span class="c1"># Appling UnitNorm to them</span>
        <span class="n">source_node_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">source_node_embedding</span><span class="p">)</span>
        <span class="n">destination_node_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">destination_node_embedding</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">:</span>
            <span class="n">node_type_embedding_layer</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
                <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">+</span>
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span><span class="p">),</span>
                <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_type_embedding_size</span><span class="p">,</span>
                <span class="n">input_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_node_types</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">Siamese</span><span class="o">.</span><span class="n">NODE_TYPE_EMBEDDING_LAYER_NAME</span><span class="p">,</span>
                <span class="n">mask_zero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span>
            <span class="p">)</span>
            <span class="n">source_node_types_embedding</span> <span class="o">=</span> <span class="n">node_type_embedding_layer</span><span class="p">(</span>
                <span class="n">source_node_types_input</span>
            <span class="p">)</span>
            <span class="n">destination_node_types_embedding</span> <span class="o">=</span> <span class="n">node_type_embedding_layer</span><span class="p">(</span>
                <span class="n">destination_node_types_input</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span><span class="p">:</span>
                <span class="n">global_average_layer</span> <span class="o">=</span> <span class="n">GlobalAveragePooling1D</span><span class="p">()</span>
                <span class="n">source_node_types_embedding</span> <span class="o">=</span> <span class="n">global_average_layer</span><span class="p">(</span>
                    <span class="n">source_node_types_embedding</span>
                <span class="p">)</span>
                <span class="n">destination_node_types_embedding</span> <span class="o">=</span> <span class="n">global_average_layer</span><span class="p">(</span>
                    <span class="n">destination_node_types_embedding</span>
                <span class="p">)</span>

            <span class="n">source_node_types_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span>
                <span class="n">source_node_types_embedding</span>
            <span class="p">)</span>
            <span class="n">destination_node_types_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span>
                <span class="n">destination_node_types_embedding</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_combination</span> <span class="o">==</span> <span class="s2">&quot;Add&quot;</span><span class="p">:</span>
                <span class="n">node_types_concatenation</span> <span class="o">=</span> <span class="n">Add</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_combination</span> <span class="o">==</span> <span class="s2">&quot;Concatenate&quot;</span><span class="p">:</span>
                <span class="n">node_types_concatenation</span> <span class="o">=</span> <span class="n">Concatenate</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Supported node types concatenations are Dot, Add and Concatenate.&quot;</span>
                <span class="p">)</span>
            
            <span class="n">source_node_embedding</span> <span class="o">=</span> <span class="n">node_types_concatenation</span><span class="p">([</span>
                <span class="n">source_node_embedding</span><span class="p">,</span>
                <span class="n">source_node_types_embedding</span>
            <span class="p">])</span>
            <span class="n">destination_node_embedding</span> <span class="o">=</span> <span class="n">node_types_concatenation</span><span class="p">([</span>
                <span class="n">destination_node_embedding</span><span class="p">,</span>
                <span class="n">destination_node_types_embedding</span>
            <span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">:</span>
            <span class="n">edge_type_embedding</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span>
                <span class="n">input_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span><span class="p">,</span>
                <span class="n">output_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span><span class="p">,</span>
                <span class="n">input_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">Siamese</span><span class="o">.</span><span class="n">EDGE_TYPE_EMBEDDING_LAYER_NAME</span><span class="p">,</span>
            <span class="p">)(</span><span class="n">edge_types_input</span><span class="p">)</span>
            <span class="n">edge_type_embedding</span> <span class="o">=</span> <span class="n">UnitNorm</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">edge_type_embedding</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_type_embedding</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Creating the actual model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">input_layers</span><span class="p">,</span>
            <span class="n">outputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
                <span class="n">source_node_embedding</span><span class="p">,</span>
                <span class="n">destination_node_embedding</span><span class="p">,</span>
                <span class="n">edge_type_embedding</span><span class="p">,</span>
                <span class="n">edge_types_input</span>
            <span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_name</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">destination_node_embedding</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------------</span>
<span class="sd">        source_node_embedding: tf.Tensor,</span>
<span class="sd">            Embedding of the source node.</span>
<span class="sd">        destination_node_embedding: tf.Tensor,</span>
<span class="sd">            Embedding of the destination node.</span>
<span class="sd">        args: List[tf.Tensor],</span>
<span class="sd">            Additional tensors that may be used</span>
<span class="sd">            in subclasses of this model.</span>
<span class="sd">        kwargs: Dict[str, tf.Tensor],</span>
<span class="sd">            Additional tensors that may be used</span>
<span class="sd">            in subclasses of this model.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------------------</span>
<span class="sd">        The distance for the Siamese network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span> <span class="o">==</span> <span class="s2">&quot;L1&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">source_node_embedding</span> <span class="o">-</span> <span class="n">destination_node_embedding</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span> <span class="o">==</span> <span class="s2">&quot;L2&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">source_node_embedding</span> <span class="o">-</span> <span class="n">destination_node_embedding</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span> <span class="o">==</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">cosine_similarity</span><span class="p">(</span><span class="n">source_node_embedding</span><span class="p">,</span> <span class="n">destination_node_embedding</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Given distance metric </span><span class="si">{}</span><span class="s2"> is not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_siamese_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute the siamese loss function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        y_true: tf.Tensor,</span>
<span class="sd">            The true values Tensor for this batch.</span>
<span class="sd">        y_pred: tf.Tensor,</span>
<span class="sd">            The predicted values Tensor for this batch.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        Loss function score related to this batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: check what happens with and without relu cutoff</span>
        <span class="n">y_true</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relu_bias</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_true</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_pred</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return terms embedding using given index names.&quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">(),</span>
            <span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">:</span>
            <span class="n">node_types_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span>
                <span class="n">Siamese</span><span class="o">.</span><span class="n">NODE_TYPE_EMBEDDING_LAYER_NAME</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span><span class="p">:</span>
                <span class="n">node_types_embedding</span> <span class="o">=</span> <span class="n">node_types_embedding</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">node_types_embedding</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">(),</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span>
                            <span class="n">Siamese</span><span class="o">.</span><span class="n">EDGE_TYPE_EMBEDDING_LAYER_NAME</span>
                        <span class="p">),</span>
                        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_edge_type_names</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compile model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_siamese_loss</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return model embeddings.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------------------</span>
<span class="sd">        NotImplementedError,</span>
<span class="sd">            If the current embedding model does not have an embedding layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO create multiple getters for the various embedding layers.</span>
        <span class="k">return</span> <span class="n">Embedder</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="n">EdgePredictionSequence</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">sequence</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Siamese network for node-embedding including optionally node types and edge types.</p>
</div>


                            <div id="Siamese.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Siamese.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Siamese</span><span class="signature">(
    graph: Graph,
    use_node_types: Union[bool, str] = &#39;auto&#39;,
    node_types_combination: str = &#39;Add&#39;,
    use_edge_types: Union[bool, str] = &#39;auto&#39;,
    node_embedding_size: int = 100,
    node_type_embedding_size: int = 100,
    edge_type_embedding_size: int = 100,
    distance_metric: str = &#39;COSINE&#39;,
    relu_bias: float = 1.0,
    embedding: Union[numpy.ndarray, pandas.core.frame.DataFrame, NoneType] = None,
    extra_features: Union[numpy.ndarray, pandas.core.frame.DataFrame, NoneType] = None,
    model_name: str = &#39;Siamese&#39;,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = None,
    support_mirrored_strategy: bool = False,
    use_gradient_centralization: str = &#39;auto&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">use_node_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_types_combination</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Add&quot;</span><span class="p">,</span>
        <span class="n">use_edge_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">node_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">node_type_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">edge_type_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">distance_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;COSINE&quot;</span><span class="p">,</span>
        <span class="n">relu_bias</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Siamese&quot;</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">support_mirrored_strategy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_gradient_centralization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new sequence Embedder model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------------------</span>
<span class="sd">        vocabulary_size: int = None,</span>
<span class="sd">            Number of terms to embed.</span>
<span class="sd">            In a graph this is the number of nodes, while in a text is the</span>
<span class="sd">            number of the unique words.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        use_node_types: Union[bool, str] = &quot;auto&quot;,</span>
<span class="sd">            Whether to use node type.</span>
<span class="sd">            By default, it will automatially use node types if the graph</span>
<span class="sd">            contains node type and does not contain any unknown node type.</span>
<span class="sd">        node_types_combination: str = &quot;Add&quot;,</span>
<span class="sd">            Method to combine the node embedding with the node type ambedding.</span>
<span class="sd">            The supported methods are &quot;Add&quot; and &quot;Concatenate&quot;.</span>
<span class="sd">        use_edge_types: Union[bool, str] = &quot;auto&quot;,</span>
<span class="sd">            Whether to use edge type.</span>
<span class="sd">            By default, it will automatially use edge types if the graph</span>
<span class="sd">            contains edge type and does not contain any unknown edge type.</span>
<span class="sd">        node_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding.</span>
<span class="sd">            If None, the seed embedding must be provided.</span>
<span class="sd">            It is not possible to provide both at once.</span>
<span class="sd">        node_type_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding for the node types.</span>
<span class="sd">        edge_type_embedding_size: int = 100,</span>
<span class="sd">            Dimension of the embedding for the edge types.</span>
<span class="sd">        distance_metric: str = &quot;COSINE&quot;,</span>
<span class="sd">            The distance to use for the loss function.</span>
<span class="sd">            Supported methods are L1, L2 and COSINE.</span>
<span class="sd">        relu_bias: float = 1.0,</span>
<span class="sd">            The bias to use for the ReLu.</span>
<span class="sd">        embedding: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            The seed embedding to be used.</span>
<span class="sd">            Note that it is not possible to provide at once both</span>
<span class="sd">            the embedding and either the vocabulary size or the embedding size.</span>
<span class="sd">        extra_features: Union[np.ndarray, pd.DataFrame] = None,</span>
<span class="sd">            Optional extra features to be used during the computation</span>
<span class="sd">            of the embedding. The features must be available for all the</span>
<span class="sd">            elements considered for the embedding.</span>
<span class="sd">        model_name: str = &quot;Siamese&quot;,</span>
<span class="sd">            Name of the model.</span>
<span class="sd">        optimizer: Union[str, Optimizer] = &quot;nadam&quot;,</span>
<span class="sd">            The optimizer to be used during the training of the model.</span>
<span class="sd">        support_mirrored_strategy: bool = False,</span>
<span class="sd">            Wethever to patch support for mirror strategy.</span>
<span class="sd">            At the time of writing, TensorFlow&#39;s MirrorStrategy does not support</span>
<span class="sd">            input values different from floats, therefore to support it we need</span>
<span class="sd">            to convert the unsigned int 32 values that represent the indices of</span>
<span class="sd">            the embedding layers we receive from Ensmallen to floats.</span>
<span class="sd">            This will generally slow down performance, but in the context of</span>
<span class="sd">            exploiting multiple GPUs it may be unnoticeable.</span>
<span class="sd">        use_gradient_centralization: bool = True,</span>
<span class="sd">            Whether to wrap the provided optimizer into a normalized</span>
<span class="sd">            one that centralizes the gradient.</span>
<span class="sd">            It is automatically enabled if the current version of</span>
<span class="sd">            TensorFlow supports gradient transformers.</span>
<span class="sd">            More detail here: https://arxiv.org/pdf/2004.01461.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_disconnected_nodes</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The graph contains disconnected nodes: these nodes will &quot;</span>
                <span class="s2">&quot;not be embedded in a semantically sensible way, but &quot;</span>
                <span class="s2">&quot;will only obtain a random node embedding vector which is &quot;</span>
                <span class="s2">&quot;far from all other nodes.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_node_types</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_node_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Node types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph does not have node types&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_node_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Node types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph contains unknown node types and this &quot;</span>
                    <span class="s2">&quot;type of model is not designed in order to handle &quot;</span>
                    <span class="s2">&quot;unknown node types.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_singleton_node_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The node types will be used in order to compute the node &quot;</span>
                    <span class="s2">&quot;embedding, but there are some singleton node types: these &quot;</span>
                    <span class="s2">&quot;node types will not capture any characteristic that is not &quot;</span>
                    <span class="s2">&quot;already captured by the node embedding, and may be an error &quot;</span>
                    <span class="s2">&quot;in the pipeline you have used to create this graph.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_homogeneous_node_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The graph contains exclusively nodes with a homogenous &quot;</span>
                    <span class="s2">&quot;node type!&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_multilabel_node_types</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_node_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_maximum_multilabel_count</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_types_number</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_edge_types</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_edge_types</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">use_edge_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Edge types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph does not have edge types&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_unknown_edge_types</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Edge types are to be used to embed the given graph, &quot;</span>
                    <span class="s2">&quot;but the graph contains unknown edge types and this &quot;</span>
                    <span class="s2">&quot;type of model is not designed in order to handle &quot;</span>
                    <span class="s2">&quot;unknown edge types.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_singleton_edge_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The edge types will be used in order to compute the edge &quot;</span>
                    <span class="s2">&quot;embedding, but there are some singleton edge types: these &quot;</span>
                    <span class="s2">&quot;edge types will not capture any characteristic that is not &quot;</span>
                    <span class="s2">&quot;already captured by the edge embedding, and may be an error &quot;</span>
                    <span class="s2">&quot;in the pipeline you have used to create this graph.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_homogeneous_edge_types</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The graph contains exclusively edges with a homogenous &quot;</span>
                    <span class="s2">&quot;edge type!&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_edge_types_number</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_combination</span> <span class="o">=</span> <span class="n">node_types_combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span> <span class="o">=</span> <span class="n">use_node_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span> <span class="o">=</span> <span class="n">use_edge_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_type_embedding_size</span> <span class="o">=</span> <span class="n">node_type_embedding_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_type_embedding_size</span> <span class="o">=</span> <span class="n">edge_type_embedding_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance_metric</span> <span class="o">=</span> <span class="n">distance_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relu_bias</span> <span class="o">=</span> <span class="n">relu_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span> <span class="o">=</span> <span class="n">support_mirrored_strategy</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">vocabulary_size</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">(),</span>
            <span class="n">embedding_size</span><span class="o">=</span><span class="n">node_embedding_size</span><span class="p">,</span>
            <span class="n">embedding</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span>
            <span class="n">extra_features</span><span class="o">=</span><span class="n">extra_features</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
            <span class="n">use_gradient_centralization</span><span class="o">=</span><span class="n">use_gradient_centralization</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new sequence Embedder model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>vocabulary_size</strong> (int = None,):
Number of terms to embed.
In a graph this is the number of nodes, while in a text is the
number of the unique words.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>use_node_types</strong> (Union[bool, str] = "auto",):
Whether to use node type.
By default, it will automatially use node types if the graph
contains node type and does not contain any unknown node type.</li>
<li><strong>node_types_combination</strong> (str = "Add",):
Method to combine the node embedding with the node type ambedding.
The supported methods are "Add" and "Concatenate".</li>
<li><strong>use_edge_types</strong> (Union[bool, str] = "auto",):
Whether to use edge type.
By default, it will automatially use edge types if the graph
contains edge type and does not contain any unknown edge type.</li>
<li><strong>node_embedding_size</strong> (int = 100,):
Dimension of the embedding.
If None, the seed embedding must be provided.
It is not possible to provide both at once.</li>
<li><strong>node_type_embedding_size</strong> (int = 100,):
Dimension of the embedding for the node types.</li>
<li><strong>edge_type_embedding_size</strong> (int = 100,):
Dimension of the embedding for the edge types.</li>
<li><strong>distance_metric</strong> (str = "COSINE",):
The distance to use for the loss function.
Supported methods are L1, L2 and COSINE.</li>
<li><strong>relu_bias</strong> (float = 1.0,):
The bias to use for the ReLu.</li>
<li><strong>embedding</strong> (Union[np.ndarray, pd.DataFrame] = None,):
The seed embedding to be used.
Note that it is not possible to provide at once both
the embedding and either the vocabulary size or the embedding size.</li>
<li><strong>extra_features</strong> (Union[np.ndarray, pd.DataFrame] = None,):
Optional extra features to be used during the computation
of the embedding. The features must be available for all the
elements considered for the embedding.</li>
<li><strong>model_name</strong> (str = "Siamese",):
Name of the model.</li>
<li><strong>optimizer</strong> (Union[str, Optimizer] = "nadam",):
The optimizer to be used during the training of the model.</li>
<li><strong>support_mirrored_strategy</strong> (bool = False,):
Wethever to patch support for mirror strategy.
At the time of writing, TensorFlow's MirrorStrategy does not support
input values different from floats, therefore to support it we need
to convert the unsigned int 32 values that represent the indices of
the embedding layers we receive from Ensmallen to floats.
This will generally slow down performance, but in the context of
exploiting multiple GPUs it may be unnoticeable.</li>
<li><strong>use_gradient_centralization</strong> (bool = True,):
Whether to wrap the provided optimizer into a normalized
one that centralizes the gradient.
It is automatically enabled if the current version of
TensorFlow supports gradient transformers.
More detail here: https://arxiv.org/pdf/2004.01461.pdf</li>
</ul>
</div>


                            </div>
                            <div id="Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Siamese.NODE_TYPE_EMBEDDING_LAYER_NAME">#&nbsp;&nbsp</a>

        <span class="name">NODE_TYPE_EMBEDDING_LAYER_NAME</span><span class="default_value"> = &#39;node_type_embedding_layer&#39;</span>
    </div>

    

                            </div>
                            <div id="Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Siamese.EDGE_TYPE_EMBEDDING_LAYER_NAME">#&nbsp;&nbsp</a>

        <span class="name">EDGE_TYPE_EMBEDDING_LAYER_NAME</span><span class="default_value"> = &#39;edge_type_embedding_layer&#39;</span>
    </div>

    

                            </div>
                            <div id="Siamese.get_embedding_dataframe" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Siamese.get_embedding_dataframe">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_embedding_dataframe</span><span class="signature">(self) -&gt; List[pandas.core.frame.DataFrame]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_embedding_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return terms embedding using given index names.&quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span><span class="n">Embedder</span><span class="o">.</span><span class="n">TERMS_EMBEDDING_LAYER_NAME</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">(),</span>
            <span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">:</span>
            <span class="n">node_types_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span>
                <span class="n">Siamese</span><span class="o">.</span><span class="n">NODE_TYPE_EMBEDDING_LAYER_NAME</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilabel_node_types</span><span class="p">:</span>
                <span class="n">node_types_embedding</span> <span class="o">=</span> <span class="n">node_types_embedding</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">node_types_embedding</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">(),</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_layer_weights</span><span class="p">(</span>
                            <span class="n">Siamese</span><span class="o">.</span><span class="n">EDGE_TYPE_EMBEDDING_LAYER_NAME</span>
                        <span class="p">),</span>
                        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="o">.</span><span class="n">get_unique_edge_type_names</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">values</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return terms embedding using given index names.</p>
</div>


                            </div>
                            <div id="Siamese.embedding" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Siamese.embedding">#&nbsp;&nbsp</a>

        <span class="name">embedding</span><span class="annotation">: numpy.ndarray</span>
    </div>

            <div class="docstring"><p>Return model embeddings.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>NotImplementedError,</strong>: If the current embedding model does not have an embedding layer.</li>
</ul>
</div>


                            </div>
                            <div id="Siamese.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Siamese.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    batch_size: int = 1048576,
    negative_samples_rate: float = 0.5,
    avoid_false_negatives: bool = False,
    graph_to_avoid: Graph = None,
    batches_per_epoch: Union[int, str] = &#39;auto&#39;,
    elapsed_epochs: int = 0,
    epochs: int = 1000,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_min_delta: float = 0.01,
    early_stopping_patience: int = 5,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_min_delta: float = 0.01,
    reduce_lr_patience: int = 2,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 2,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">negative_samples_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">avoid_false_negatives</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_to_avoid</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batches_per_epoch</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">elapsed_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            Graph to embed.</span>
<span class="sd">        epochs: int = 100,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_min_delta: float = 0.1,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int = 5,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_min_delta: float = 1,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int = 3,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 2,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="n">EdgePredictionSequence</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">avoid_false_negatives</span><span class="o">=</span><span class="n">avoid_false_negatives</span><span class="p">,</span>
            <span class="n">support_mirrored_strategy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_support_mirrored_strategy</span><span class="p">,</span>
            <span class="n">graph_to_avoid</span><span class="o">=</span><span class="n">graph_to_avoid</span><span class="p">,</span>
            <span class="n">use_node_types</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_node_types</span><span class="p">,</span>
            <span class="n">use_edge_types</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_edge_types</span><span class="p">,</span>
            <span class="n">negative_samples_rate</span><span class="o">=</span><span class="n">negative_samples_rate</span><span class="p">,</span>
            <span class="n">elapsed_epochs</span><span class="o">=</span><span class="n">elapsed_epochs</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">batches_per_epoch</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">sequence</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">early_stopping_monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
            <span class="n">early_stopping_min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
            <span class="n">early_stopping_patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
            <span class="n">early_stopping_mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
            <span class="n">reduce_lr_min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
            <span class="n">reduce_lr_patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
            <span class="n">reduce_lr_mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
            <span class="n">reduce_lr_factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
Graph to embed.</li>
<li><strong>epochs</strong> (int = 100,):
Epochs to train the model for.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_min_delta</strong> (float = 0.1,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int = 5,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_min_delta</strong> (float = 1,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int = 3,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 2,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>grape.embiggen.embedders.embedder.Embedder</dt>
                                <dd id="Siamese.TERMS_EMBEDDING_LAYER_NAME" class="variable">TERMS_EMBEDDING_LAYER_NAME</dd>
                <dd id="Siamese.trainable" class="variable">trainable</dd>
                <dd id="Siamese.summary" class="function">summary</dd>
                <dd id="Siamese.get_layer_weights" class="function">get_layer_weights</dd>
                <dd id="Siamese.save_embedding" class="function">save_embedding</dd>
                <dd id="Siamese.name" class="variable">name</dd>
                <dd id="Siamese.save_weights" class="function">save_weights</dd>
                <dd id="Siamese.load_weights" class="function">load_weights</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GraphConvolutionalNeuralNetwork">
                                <div class="attr class">
        <a class="headerlink" href="#GraphConvolutionalNeuralNetwork">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GraphConvolutionalNeuralNetwork</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphConvolutionalNeuralNetwork</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Graph Convolutional Neural Network (GCNN) model for graph embedding.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">use_weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">use_class_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">node_features_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">node_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">number_of_hidden_layers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">number_of_units_per_hidden_layer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">use_dense_hidden_layers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">activations_per_hidden_layer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;relu&quot;</span><span class="p">,</span>
        <span class="n">kernel_initializer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Initializer</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;glorot_uniform&#39;</span><span class="p">,</span>
        <span class="n">bias_initializer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Initializer</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
        <span class="n">kernel_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bias_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">activity_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kernel_constraint</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bias_constraint</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">features_dropout_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nadam&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            The data for which to build the model.</span>
<span class="sd">        use_class_weights: bool = True,</span>
<span class="sd">            Whether to use class weights to rebalance the loss relative to unbalanced classes.</span>
<span class="sd">            Learn more about class weights here: https://www.tensorflow.org/tutorials/structured_data/imbalanced_data</span>
<span class="sd">        number_of_units_per_hidden_layer: Union[int, List[int]] = 16,</span>
<span class="sd">            Number of units per hidden layer.</span>
<span class="sd">        use_dense_hidden_layers: bool = False,</span>
<span class="sd">            Whether to use dense layer for the hidden layers.</span>
<span class="sd">            It is useful in the context of a shallow GCN, when it is not</span>
<span class="sd">            feaseable to use the batch size equal to the number of nodes in the graph.</span>
<span class="sd">        use_weights: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to expect weights in input to execute the graph convolution.</span>
<span class="sd">            The weights may be used in order to compute for instance a weighting</span>
<span class="sd">            using the symmetric normalized Laplacian method.</span>
<span class="sd">        number_of_nodes: Optional[int] = None,</span>
<span class="sd">            Number of nodes in the considered.</span>
<span class="sd">            If the node features are provided, the nodes number is extracted by the node features.</span>
<span class="sd">        node_features_number: Optional[int] = None,</span>
<span class="sd">            Number of node features.</span>
<span class="sd">            If the node features are provided, the features number is extracted by the node features.</span>
<span class="sd">        node_features: Optional[Union[np.ndarray, pd.DataFrame]] = None,</span>
<span class="sd">            Vector with the provided node features.</span>
<span class="sd">        trainable: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to make the node features trainable.</span>
<span class="sd">            By default, with &quot;auto&quot;, the embedding is trainable if no node features where provided.</span>
<span class="sd">        number_of_hidden_layers: int = 1,</span>
<span class="sd">            Number of graph convolution layer.</span>
<span class="sd">        number_of_units_per_hidden_layer: Union[int, List[int]] = 16,</span>
<span class="sd">            Number of units per hidden layer.</span>
<span class="sd">        kernel_initializer: Union[str, Initializer] = &#39;glorot_uniform&#39;,</span>
<span class="sd">            Initializer for the kernel weights matrix.</span>
<span class="sd">        bias_initializer: Union[str, Initializer] = &#39;zeros&#39;,</span>
<span class="sd">            Initializer for the bias vector.</span>
<span class="sd">        kernel_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the kernel weights matrix.</span>
<span class="sd">        bias_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the bias vector.</span>
<span class="sd">        activity_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the output of the activation function.</span>
<span class="sd">        kernel_constraint: Union[str, Constraint] = None,</span>
<span class="sd">            Constraint function applied to the kernel matrix.</span>
<span class="sd">        bias_constraint: Union[str, Constraint] = None,</span>
<span class="sd">            Constraint function applied to the bias vector.</span>
<span class="sd">        features_dropout_rate: float = 0.5,</span>
<span class="sd">            Float between 0 and 1. Fraction of the input units to drop.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number_of_units_per_hidden_layer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">number_of_units_per_hidden_layer</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_of_units_per_hidden_layer</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">number_of_hidden_layers</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">activations_per_hidden_layer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">activations_per_hidden_layer</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">activations_per_hidden_layer</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">number_of_hidden_layers</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">number_of_units_per_hidden_layer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">number_of_hidden_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of hidden layers must match&quot;</span>
                <span class="s2">&quot;the number of the hidden units per layer provided&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">activations_per_hidden_layer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">number_of_hidden_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of hidden layers must match&quot;</span>
                <span class="s2">&quot;the number of the activations per layer provided&quot;</span>
            <span class="p">)</span>

        <span class="n">use_weights_supported_values</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_weights</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">use_weights_supported_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;The provided value for `use_weights`, &#39;</span><span class="si">{}</span><span class="s2">&#39;, is not among the supported values &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">use_weights</span><span class="p">,</span> <span class="n">use_weights_supported_values</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">node_features</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The provided node features DataFrame is not aligned with the &quot;</span>
                <span class="s2">&quot;provided graph nodes.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_features_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Eiter the number of node features or the node features &quot;</span>
                <span class="s2">&quot;themselves must be provided.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_weights</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_weights</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_features_number</span> <span class="o">=</span> <span class="n">node_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_weights</span> <span class="o">=</span> <span class="n">use_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_class_weights</span> <span class="o">=</span> <span class="n">use_class_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_features_number</span> <span class="o">=</span> <span class="n">node_features_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_features</span> <span class="o">=</span> <span class="n">node_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_types_number</span><span class="p">()</span>
        <span class="n">number_of_units_per_hidden_layer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_hidden_layers</span> <span class="o">=</span> <span class="n">number_of_hidden_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_dense_hidden_layers</span> <span class="o">=</span> <span class="n">use_dense_hidden_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_initializer</span> <span class="o">=</span> <span class="n">kernel_initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_initializer</span> <span class="o">=</span> <span class="n">bias_initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_regularizer</span> <span class="o">=</span> <span class="n">kernel_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_regularizer</span> <span class="o">=</span> <span class="n">bias_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_activity_regularizer</span> <span class="o">=</span> <span class="n">activity_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_constraint</span> <span class="o">=</span> <span class="n">kernel_constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_constraint</span> <span class="o">=</span> <span class="n">bias_constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_dropout_rate</span> <span class="o">=</span> <span class="n">features_dropout_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_units_per_hidden_layer</span> <span class="o">=</span> <span class="n">number_of_units_per_hidden_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multi_label</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_multilabel_node_types</span><span class="p">()</span>
        <span class="n">activations_per_hidden_layer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sigmoid&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multi_label</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;softmax&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_activations_per_hidden_layer</span> <span class="o">=</span> <span class="n">activations_per_hidden_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span> <span class="o">=</span> <span class="n">graph_to_sparse_tensor</span><span class="p">(</span>
            <span class="n">graph</span><span class="p">,</span>
            <span class="n">use_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_weights</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_model</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_model</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GCN model.&quot;&quot;&quot;</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span><span class="p">,),</span>
            <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">input_graph_convolution</span> <span class="o">=</span> <span class="n">GraphConvolution</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_units_per_hidden_layer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_activations_per_hidden_layer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">features_dropout_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_features_dropout_rate</span><span class="p">,</span>
            <span class="n">kernel_initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_initializer</span><span class="p">,</span>
            <span class="n">bias_initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_initializer</span><span class="p">,</span>
            <span class="n">kernel_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_regularizer</span><span class="p">,</span>
            <span class="n">bias_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_regularizer</span><span class="p">,</span>
            <span class="n">activity_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_activity_regularizer</span><span class="p">,</span>
            <span class="n">kernel_constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_constraint</span><span class="p">,</span>
            <span class="n">bias_constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_constraint</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">input_graph_convolution</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_features_number</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_features</span> <span class="o">=</span> <span class="n">input_graph_convolution</span><span class="o">.</span><span class="n">add_weight</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;node_features&quot;</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_features_number</span><span class="p">),</span>
                <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">initializer</span><span class="o">=</span><span class="s2">&quot;glorot_normal&quot;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_features</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span>
                <span class="n">initial_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_features</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">validate_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;node_features&quot;</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_features_number</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>

        <span class="n">hidden</span> <span class="o">=</span> <span class="n">input_graph_convolution</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">node_features</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_hidden_layers</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_of_units_per_hidden_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_activations_per_hidden_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">kernel_initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_initializer</span><span class="p">,</span>
                <span class="n">bias_initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_initializer</span><span class="p">,</span>
                <span class="n">kernel_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_regularizer</span><span class="p">,</span>
                <span class="n">bias_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_regularizer</span><span class="p">,</span>
                <span class="n">activity_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_activity_regularizer</span><span class="p">,</span>
                <span class="n">kernel_constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_constraint</span><span class="p">,</span>
                <span class="n">bias_constraint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bias_constraint</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_dense_hidden_layers</span><span class="p">:</span>
                <span class="n">hidden</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">hidden</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gcn_hidden</span> <span class="o">=</span> <span class="n">GraphConvolution</span><span class="p">(</span>
                    <span class="n">features_dropout_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_features_dropout_rate</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">gcn_hidden</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_of_units_per_hidden_layer</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">hidden</span> <span class="o">=</span> <span class="n">gcn_hidden</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">hidden</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">adjacency_matrix</span><span class="p">,</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">hidden</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;GCN&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compile_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compile model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;binary_crossentropy&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multi_label</span> <span class="k">else</span> <span class="s2">&quot;categorical_crossentropy&quot;</span><span class="p">,</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="p">,</span>
            <span class="n">weighted_metrics</span><span class="o">=</span><span class="n">get_minimal_multiclass_metrics</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print model summary.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_batch_size_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs check for valid batch size given the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        batch_size: int,</span>
<span class="sd">            The batch size to check.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given batch size is not compatible with the</span>
<span class="sd">            current model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------</span>
<span class="sd">        Validated batch size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_hidden_layers</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_dense_hidden_layers</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If the number of GCN layers is greater than 1, &quot;</span>
                <span class="s2">&quot;the batch size must be equal to the number of &quot;</span>
                <span class="s2">&quot;nodes in the graph.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Alternatively you can use Dense layers for the &quot;</span>
                <span class="s2">&quot;hidden layers.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">batch_size</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">train_graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">validation_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">validation_graph</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        train_graph: Graph,</span>
<span class="sd">            Graph to use for the training.</span>
<span class="sd">        batch_size: Union[int, str] = &quot;auto&quot;,</span>
<span class="sd">            Batch size for the training epochs.</span>
<span class="sd">            If the model has a single GCN layer it is possible</span>
<span class="sd">            to specify a variable batch size.</span>
<span class="sd">        validation_freq: int = 1,</span>
<span class="sd">            The frequency when to run the validation.</span>
<span class="sd">            Note that in sparse tensors, this step is apparently</span>
<span class="sd">            extremely slow and seems to be happening in GPU.</span>
<span class="sd">            You may want to increase it to a higher value than one.</span>
<span class="sd">        early_stopping_min_delta: float,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        reduce_lr_min_delta: float,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        validation_graph: Graph = None,</span>
<span class="sd">            Tuple to use for the validation.</span>
<span class="sd">        epochs: int = 10000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 1,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tqdm.keras</span> <span class="kn">import</span> <span class="n">TqdmCallback</span>
            <span class="n">traditional_verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">traditional_verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">validate_verbose</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">validation_graph</span><span class="p">:</span>
            <span class="n">validation_data</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
                <span class="n">validation_graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                <span class="c1"># This is a known hack to get around limitations from the current</span>
                <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">validation_graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">validation_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_class_weights</span><span class="p">:</span>
            <span class="n">class_weight</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node_type_id</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span> <span class="o">/</span> <span class="n">count</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span>
                <span class="k">for</span> <span class="n">node_type_id</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">train_graph</span><span class="o">.</span><span class="n">get_node_type_id_counts_hashmap</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_weight</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;callbacks&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span> <span class="n">train_graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
            <span class="c1"># This is a known hack to get around limitations from the current</span>
            <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">train_graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)),</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="n">validation_data</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">traditional_verbose</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
            <span class="n">validation_freq</span><span class="o">=</span><span class="n">validation_freq</span><span class="p">,</span>
            <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span>
                <span class="n">EarlyStopping</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
                    <span class="n">min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">ReduceLROnPlateau</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
                    <span class="n">min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
                    <span class="n">factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="o">*</span><span class="p">((</span><span class="n">TqdmCallback</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">traditional_verbose</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">()),</span>
                <span class="o">*</span><span class="n">callbacks</span>
            <span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Run predictions on the provided graph.&quot;&quot;&quot;</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">predictions</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">(),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Run evaluation of the model over the provided graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">metrics_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">(),</span>
                <span class="o">*</span> <span class="n">args</span><span class="p">,</span>
                <span class="c1"># This is a known hack to get around limitations from the current</span>
                <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)),</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Graph Convolutional Neural Network (GCNN) model for graph embedding.</p>
</div>


                            <div id="GraphConvolutionalNeuralNetwork.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GraphConvolutionalNeuralNetwork</span><span class="signature">(
    graph: Graph,
    use_weights: Union[str, bool] = &#39;auto&#39;,
    use_class_weights: bool = True,
    node_features_number: Union[int, NoneType] = None,
    node_features: Union[pandas.core.frame.DataFrame, NoneType] = None,
    number_of_hidden_layers: int = 1,
    number_of_units_per_hidden_layer: Union[int, List[int]] = 16,
    use_dense_hidden_layers: bool = False,
    activations_per_hidden_layer: Union[str, List[str]] = &#39;relu&#39;,
    kernel_initializer: Union[str, keras.initializers.initializers_v2.Initializer] = &#39;glorot_uniform&#39;,
    bias_initializer: Union[str, keras.initializers.initializers_v2.Initializer] = &#39;zeros&#39;,
    kernel_regularizer: Union[str, keras.regularizers.Regularizer] = None,
    bias_regularizer: Union[str, keras.regularizers.Regularizer] = None,
    activity_regularizer: Union[str, keras.regularizers.Regularizer] = None,
    kernel_constraint: Union[str, keras.constraints.Constraint] = None,
    bias_constraint: Union[str, keras.constraints.Constraint] = None,
    features_dropout_rate: float = 0.5,
    optimizer: Union[str, keras.optimizer_v2.optimizer_v2.OptimizerV2] = &#39;nadam&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">use_weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">use_class_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">node_features_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">node_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">number_of_hidden_layers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">number_of_units_per_hidden_layer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">use_dense_hidden_layers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">activations_per_hidden_layer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;relu&quot;</span><span class="p">,</span>
        <span class="n">kernel_initializer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Initializer</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;glorot_uniform&#39;</span><span class="p">,</span>
        <span class="n">bias_initializer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Initializer</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
        <span class="n">kernel_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bias_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">activity_regularizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Regularizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kernel_constraint</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bias_constraint</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">features_dropout_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nadam&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new GloVe-based Embedder object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------------------</span>
<span class="sd">        graph: Graph,</span>
<span class="sd">            The data for which to build the model.</span>
<span class="sd">        use_class_weights: bool = True,</span>
<span class="sd">            Whether to use class weights to rebalance the loss relative to unbalanced classes.</span>
<span class="sd">            Learn more about class weights here: https://www.tensorflow.org/tutorials/structured_data/imbalanced_data</span>
<span class="sd">        number_of_units_per_hidden_layer: Union[int, List[int]] = 16,</span>
<span class="sd">            Number of units per hidden layer.</span>
<span class="sd">        use_dense_hidden_layers: bool = False,</span>
<span class="sd">            Whether to use dense layer for the hidden layers.</span>
<span class="sd">            It is useful in the context of a shallow GCN, when it is not</span>
<span class="sd">            feaseable to use the batch size equal to the number of nodes in the graph.</span>
<span class="sd">        use_weights: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to expect weights in input to execute the graph convolution.</span>
<span class="sd">            The weights may be used in order to compute for instance a weighting</span>
<span class="sd">            using the symmetric normalized Laplacian method.</span>
<span class="sd">        number_of_nodes: Optional[int] = None,</span>
<span class="sd">            Number of nodes in the considered.</span>
<span class="sd">            If the node features are provided, the nodes number is extracted by the node features.</span>
<span class="sd">        node_features_number: Optional[int] = None,</span>
<span class="sd">            Number of node features.</span>
<span class="sd">            If the node features are provided, the features number is extracted by the node features.</span>
<span class="sd">        node_features: Optional[Union[np.ndarray, pd.DataFrame]] = None,</span>
<span class="sd">            Vector with the provided node features.</span>
<span class="sd">        trainable: Union[str, bool] = &quot;auto&quot;,</span>
<span class="sd">            Whether to make the node features trainable.</span>
<span class="sd">            By default, with &quot;auto&quot;, the embedding is trainable if no node features where provided.</span>
<span class="sd">        number_of_hidden_layers: int = 1,</span>
<span class="sd">            Number of graph convolution layer.</span>
<span class="sd">        number_of_units_per_hidden_layer: Union[int, List[int]] = 16,</span>
<span class="sd">            Number of units per hidden layer.</span>
<span class="sd">        kernel_initializer: Union[str, Initializer] = &#39;glorot_uniform&#39;,</span>
<span class="sd">            Initializer for the kernel weights matrix.</span>
<span class="sd">        bias_initializer: Union[str, Initializer] = &#39;zeros&#39;,</span>
<span class="sd">            Initializer for the bias vector.</span>
<span class="sd">        kernel_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the kernel weights matrix.</span>
<span class="sd">        bias_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the bias vector.</span>
<span class="sd">        activity_regularizer: Union[str, Regularizer] = None,</span>
<span class="sd">            Regularizer function applied to the output of the activation function.</span>
<span class="sd">        kernel_constraint: Union[str, Constraint] = None,</span>
<span class="sd">            Constraint function applied to the kernel matrix.</span>
<span class="sd">        bias_constraint: Union[str, Constraint] = None,</span>
<span class="sd">            Constraint function applied to the bias vector.</span>
<span class="sd">        features_dropout_rate: float = 0.5,</span>
<span class="sd">            Float between 0 and 1. Fraction of the input units to drop.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number_of_units_per_hidden_layer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">number_of_units_per_hidden_layer</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_of_units_per_hidden_layer</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">number_of_hidden_layers</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">activations_per_hidden_layer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">activations_per_hidden_layer</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">activations_per_hidden_layer</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">number_of_hidden_layers</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">number_of_units_per_hidden_layer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">number_of_hidden_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of hidden layers must match&quot;</span>
                <span class="s2">&quot;the number of the hidden units per layer provided&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">activations_per_hidden_layer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">number_of_hidden_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of hidden layers must match&quot;</span>
                <span class="s2">&quot;the number of the activations per layer provided&quot;</span>
            <span class="p">)</span>

        <span class="n">use_weights_supported_values</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_weights</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">use_weights_supported_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;The provided value for `use_weights`, &#39;</span><span class="si">{}</span><span class="s2">&#39;, is not among the supported values &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">use_weights</span><span class="p">,</span> <span class="n">use_weights_supported_values</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">node_features</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The provided node features DataFrame is not aligned with the &quot;</span>
                <span class="s2">&quot;provided graph nodes.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">node_features_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Eiter the number of node features or the node features &quot;</span>
                <span class="s2">&quot;themselves must be provided.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_weights</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">use_weights</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_features_number</span> <span class="o">=</span> <span class="n">node_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_weights</span> <span class="o">=</span> <span class="n">use_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_class_weights</span> <span class="o">=</span> <span class="n">use_class_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_features_number</span> <span class="o">=</span> <span class="n">node_features_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_features</span> <span class="o">=</span> <span class="n">node_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_number_of_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_node_types_number</span><span class="p">()</span>
        <span class="n">number_of_units_per_hidden_layer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_hidden_layers</span> <span class="o">=</span> <span class="n">number_of_hidden_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_dense_hidden_layers</span> <span class="o">=</span> <span class="n">use_dense_hidden_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_initializer</span> <span class="o">=</span> <span class="n">kernel_initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_initializer</span> <span class="o">=</span> <span class="n">bias_initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_regularizer</span> <span class="o">=</span> <span class="n">kernel_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_regularizer</span> <span class="o">=</span> <span class="n">bias_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_activity_regularizer</span> <span class="o">=</span> <span class="n">activity_regularizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_constraint</span> <span class="o">=</span> <span class="n">kernel_constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bias_constraint</span> <span class="o">=</span> <span class="n">bias_constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_dropout_rate</span> <span class="o">=</span> <span class="n">features_dropout_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_units_per_hidden_layer</span> <span class="o">=</span> <span class="n">number_of_units_per_hidden_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multi_label</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_multilabel_node_types</span><span class="p">()</span>
        <span class="n">activations_per_hidden_layer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sigmoid&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multi_label</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;softmax&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_activations_per_hidden_layer</span> <span class="o">=</span> <span class="n">activations_per_hidden_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span> <span class="o">=</span> <span class="n">graph_to_sparse_tensor</span><span class="p">(</span>
            <span class="n">graph</span><span class="p">,</span>
            <span class="n">use_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_use_weights</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_model</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_model</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create new GloVe-based Embedder object.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>graph</strong> (Graph,):
The data for which to build the model.</li>
<li><strong>use_class_weights</strong> (bool = True,):
Whether to use class weights to rebalance the loss relative to unbalanced classes.
Learn more about class weights here: https://www.tensorflow.org/tutorials/structured_data/imbalanced_data</li>
<li><strong>number_of_units_per_hidden_layer</strong> (Union[int, List[int]] = 16,):
Number of units per hidden layer.</li>
<li><strong>use_dense_hidden_layers</strong> (bool = False,):
Whether to use dense layer for the hidden layers.
It is useful in the context of a shallow GCN, when it is not
feaseable to use the batch size equal to the number of nodes in the graph.</li>
<li><strong>use_weights</strong> (Union[str, bool] = "auto",):
Whether to expect weights in input to execute the graph convolution.
The weights may be used in order to compute for instance a weighting
using the symmetric normalized Laplacian method.</li>
<li><strong>number_of_nodes</strong> (Optional[int] = None,):
Number of nodes in the considered.
If the node features are provided, the nodes number is extracted by the node features.</li>
<li><strong>node_features_number</strong> (Optional[int] = None,):
Number of node features.
If the node features are provided, the features number is extracted by the node features.</li>
<li><strong>node_features</strong> (Optional[Union[np.ndarray, pd.DataFrame]] = None,):
Vector with the provided node features.</li>
<li><strong>trainable</strong> (Union[str, bool] = "auto",):
Whether to make the node features trainable.
By default, with "auto", the embedding is trainable if no node features where provided.</li>
<li><strong>number_of_hidden_layers</strong> (int = 1,):
Number of graph convolution layer.</li>
<li><strong>number_of_units_per_hidden_layer</strong> (Union[int, List[int]] = 16,):
Number of units per hidden layer.</li>
<li><strong>kernel_initializer</strong> (Union[str, Initializer] = 'glorot_uniform',):
Initializer for the kernel weights matrix.</li>
<li><strong>bias_initializer</strong> (Union[str, Initializer] = 'zeros',):
Initializer for the bias vector.</li>
<li><strong>kernel_regularizer</strong> (Union[str, Regularizer] = None,):
Regularizer function applied to the kernel weights matrix.</li>
<li><strong>bias_regularizer</strong> (Union[str, Regularizer] = None,):
Regularizer function applied to the bias vector.</li>
<li><strong>activity_regularizer</strong> (Union[str, Regularizer] = None,):
Regularizer function applied to the output of the activation function.</li>
<li><strong>kernel_constraint</strong> (Union[str, Constraint] = None,):
Constraint function applied to the kernel matrix.</li>
<li><strong>bias_constraint</strong> (Union[str, Constraint] = None,):
Constraint function applied to the bias vector.</li>
<li><strong>features_dropout_rate</strong> (float = 0.5,):
Float between 0 and 1. Fraction of the input units to drop.</li>
</ul>
</div>


                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.name" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.name">#&nbsp;&nbsp</a>

        <span class="name">name</span><span class="annotation">: str</span>
    </div>

    

                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.summary" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.summary">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">summary</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print model summary.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print model summary.</p>
</div>


                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.run_batch_size_check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.run_batch_size_check">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">run_batch_size_check</span><span class="signature">(self, batch_size: Union[int, str]) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">run_batch_size_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs check for valid batch size given the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        batch_size: int,</span>
<span class="sd">            The batch size to check.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If the given batch size is not compatible with the</span>
<span class="sd">            current model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------</span>
<span class="sd">        Validated batch size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_hidden_layers</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_dense_hidden_layers</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If the number of GCN layers is greater than 1, &quot;</span>
                <span class="s2">&quot;the batch size must be equal to the number of &quot;</span>
                <span class="s2">&quot;nodes in the graph.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Alternatively you can use Dense layers for the &quot;</span>
                <span class="s2">&quot;hidden layers.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">batch_size</span>
</pre></div>

        </details>

            <div class="docstring"><p>Runs check for valid batch size given the model.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>batch_size</strong> (int,):
The batch size to check.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If the given batch size is not compatible with the
current model.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Validated batch size.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.fit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.fit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">fit</span><span class="signature">(
    self,
    train_graph: Graph,
    batch_size: Union[int, str] = &#39;auto&#39;,
    validation_freq: int = 1,
    early_stopping_min_delta: float = 0.001,
    early_stopping_patience: int = 10,
    reduce_lr_min_delta: float = 0.001,
    reduce_lr_patience: int = 5,
    validation_graph: Graph = None,
    epochs: int = 1000,
    early_stopping_monitor: str = &#39;loss&#39;,
    early_stopping_mode: str = &#39;min&#39;,
    reduce_lr_monitor: str = &#39;loss&#39;,
    reduce_lr_mode: str = &#39;min&#39;,
    reduce_lr_factor: float = 0.9,
    verbose: int = 2,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">train_graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">validation_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">early_stopping_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">early_stopping_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reduce_lr_min_delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">reduce_lr_patience</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">validation_graph</span><span class="p">:</span> <span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_stopping_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">early_stopping_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_monitor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">reduce_lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return pandas dataframe with training history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------------------</span>
<span class="sd">        train_graph: Graph,</span>
<span class="sd">            Graph to use for the training.</span>
<span class="sd">        batch_size: Union[int, str] = &quot;auto&quot;,</span>
<span class="sd">            Batch size for the training epochs.</span>
<span class="sd">            If the model has a single GCN layer it is possible</span>
<span class="sd">            to specify a variable batch size.</span>
<span class="sd">        validation_freq: int = 1,</span>
<span class="sd">            The frequency when to run the validation.</span>
<span class="sd">            Note that in sparse tensors, this step is apparently</span>
<span class="sd">            extremely slow and seems to be happening in GPU.</span>
<span class="sd">            You may want to increase it to a higher value than one.</span>
<span class="sd">        early_stopping_min_delta: float,</span>
<span class="sd">            Minimum delta of metric to stop the training.</span>
<span class="sd">        early_stopping_patience: int,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which trigger early stopping.</span>
<span class="sd">        reduce_lr_min_delta: float,</span>
<span class="sd">            Minimum delta of metric to reduce learning rate.</span>
<span class="sd">        reduce_lr_patience: int,</span>
<span class="sd">            Number of epochs to wait for when the given minimum delta is not</span>
<span class="sd">            achieved after which reducing learning rate.</span>
<span class="sd">        validation_graph: Graph = None,</span>
<span class="sd">            Tuple to use for the validation.</span>
<span class="sd">        epochs: int = 10000,</span>
<span class="sd">            Epochs to train the model for.</span>
<span class="sd">        early_stopping_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for early stopping.</span>
<span class="sd">        early_stopping_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for early stopping.</span>
<span class="sd">        reduce_lr_monitor: str = &quot;loss&quot;,</span>
<span class="sd">            Metric to monitor for reducing learning rate.</span>
<span class="sd">        reduce_lr_mode: str = &quot;min&quot;,</span>
<span class="sd">            Direction of the variation of the monitored metric for learning rate.</span>
<span class="sd">        reduce_lr_factor: float = 0.9,</span>
<span class="sd">            Factor for reduction of learning rate.</span>
<span class="sd">        verbose: int = 1,</span>
<span class="sd">            Wethever to show the loading bar.</span>
<span class="sd">            Specifically, the options are:</span>
<span class="sd">            * 0 or False: No loading bar.</span>
<span class="sd">            * 1 or True: Showing only the loading bar for the epochs.</span>
<span class="sd">            * 2: Showing loading bar for both epochs and batches.</span>
<span class="sd">        **kwargs: Dict,</span>
<span class="sd">            Additional kwargs to pass to the Keras fit call.</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------------------</span>
<span class="sd">        ValueError,</span>
<span class="sd">            If given verbose value is not within the available set (-1, 0, 1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -----------------------</span>
<span class="sd">        Dataframe with training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tqdm.keras</span> <span class="kn">import</span> <span class="n">TqdmCallback</span>
            <span class="n">traditional_verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">traditional_verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">validate_verbose</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">validation_graph</span><span class="p">:</span>
            <span class="n">validation_data</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
                <span class="n">validation_graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                <span class="c1"># This is a known hack to get around limitations from the current</span>
                <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">validation_graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">validation_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_class_weights</span><span class="p">:</span>
            <span class="n">class_weight</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node_type_id</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_number</span> <span class="o">/</span> <span class="n">count</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_types_number</span>
                <span class="k">for</span> <span class="n">node_type_id</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">train_graph</span><span class="o">.</span><span class="n">get_node_type_id_counts_hashmap</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_weight</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;callbacks&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span> <span class="n">train_graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
            <span class="c1"># This is a known hack to get around limitations from the current</span>
            <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">train_graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)),</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="n">validation_data</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">traditional_verbose</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
            <span class="n">validation_freq</span><span class="o">=</span><span class="n">validation_freq</span><span class="p">,</span>
            <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span>
                <span class="n">EarlyStopping</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">early_stopping_monitor</span><span class="p">,</span>
                    <span class="n">min_delta</span><span class="o">=</span><span class="n">early_stopping_min_delta</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">early_stopping_patience</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">early_stopping_mode</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">ReduceLROnPlateau</span><span class="p">(</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="n">reduce_lr_monitor</span><span class="p">,</span>
                    <span class="n">min_delta</span><span class="o">=</span><span class="n">reduce_lr_min_delta</span><span class="p">,</span>
                    <span class="n">patience</span><span class="o">=</span><span class="n">reduce_lr_patience</span><span class="p">,</span>
                    <span class="n">factor</span><span class="o">=</span><span class="n">reduce_lr_factor</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">reduce_lr_mode</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="o">*</span><span class="p">((</span><span class="n">TqdmCallback</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">traditional_verbose</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">()),</span>
                <span class="o">*</span><span class="n">callbacks</span>
            <span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return pandas dataframe with training history.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>train_graph</strong> (Graph,):
Graph to use for the training.</li>
<li><strong>batch_size</strong> (Union[int, str] = "auto",):
Batch size for the training epochs.
If the model has a single GCN layer it is possible
to specify a variable batch size.</li>
<li><strong>validation_freq</strong> (int = 1,):
The frequency when to run the validation.
Note that in sparse tensors, this step is apparently
extremely slow and seems to be happening in GPU.
You may want to increase it to a higher value than one.</li>
<li><strong>early_stopping_min_delta</strong> (float,):
Minimum delta of metric to stop the training.</li>
<li><strong>early_stopping_patience</strong> (int,):
Number of epochs to wait for when the given minimum delta is not
achieved after which trigger early stopping.</li>
<li><strong>reduce_lr_min_delta</strong> (float,):
Minimum delta of metric to reduce learning rate.</li>
<li><strong>reduce_lr_patience</strong> (int,):
Number of epochs to wait for when the given minimum delta is not
achieved after which reducing learning rate.</li>
<li><strong>validation_graph</strong> (Graph = None,):
Tuple to use for the validation.</li>
<li><strong>epochs</strong> (int = 10000,):
Epochs to train the model for.</li>
<li><strong>early_stopping_monitor</strong> (str = "loss",):
Metric to monitor for early stopping.</li>
<li><strong>early_stopping_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for early stopping.</li>
<li><strong>reduce_lr_monitor</strong> (str = "loss",):
Metric to monitor for reducing learning rate.</li>
<li><strong>reduce_lr_mode</strong> (str = "min",):
Direction of the variation of the monitored metric for learning rate.</li>
<li><strong>reduce_lr_factor</strong> (float = 0.9,):
Factor for reduction of learning rate.</li>
<li><strong>verbose</strong> (int = 1,):
Wethever to show the loading bar.
Specifically, the options are:
<ul>
<li>0 or False: No loading bar.</li>
<li>1 or True: Showing only the loading bar for the epochs.</li>
<li>2: Showing loading bar for both epochs and batches.</li>
</ul></li>
<li><strong>**kwargs</strong> (Dict,):
Additional kwargs to pass to the Keras fit call.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError,</strong>: If given verbose value is not within the available set (-1, 0, 1).</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>Dataframe with training history.</strong></li>
</ul>
</div>


                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.predict" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.predict">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">predict</span><span class="signature">(
    self,
    graph: Graph,
    *args: List,
    batch_size: Union[int, str] = &#39;auto&#39;,
    **kwargs: Dict
) -&gt; pandas.core.frame.DataFrame</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Run predictions on the provided graph.&quot;&quot;&quot;</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">predictions</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_unique_node_type_names</span><span class="p">(),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">get_node_names</span><span class="p">()</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Run predictions on the provided graph.</p>
</div>


                            </div>
                            <div id="GraphConvolutionalNeuralNetwork.evaluate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GraphConvolutionalNeuralNetwork.evaluate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">evaluate</span><span class="signature">(
    self,
    graph: Graph,
    *args: List,
    batch_size: Union[int, str] = &#39;auto&#39;,
    **kwargs: Dict
) -&gt; Dict[str, float]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Run evaluation of the model over the provided graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">metrics_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency_matrix</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">get_one_hot_encoded_node_types</span><span class="p">(),</span>
                <span class="o">*</span> <span class="n">args</span><span class="p">,</span>
                <span class="c1"># This is a known hack to get around limitations from the current</span>
                <span class="c1"># implementation that handles the sample weights in TensorFlow.</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">graph</span><span class="o">.</span><span class="n">get_known_node_types_mask</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)),</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_batch_size_check</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Run evaluation of the model over the provided graph.</p>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>